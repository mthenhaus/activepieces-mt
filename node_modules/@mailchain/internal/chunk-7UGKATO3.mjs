import {
  PreflightCheckError
} from "./chunk-IJ72ALQS.mjs";
import {
  createMailPayloads
} from "./chunk-ZUX77U4A.mjs";
import {
  SenderVerifier
} from "./chunk-DIZUCS2B.mjs";
import {
  MessagingKeys
} from "./chunk-NK6CIHSE.mjs";

// src/sending/mail/prepare.ts
import { ProvidedMessagingKeyIncorrectError } from "@mailchain/signatures";
var MailPreparer = class {
  constructor(messagingKeys, senderVerifier) {
    this.messagingKeys = messagingKeys;
    this.senderVerifier = senderVerifier;
  }
  static create(configuration) {
    return new MailPreparer(MessagingKeys.create(configuration), SenderVerifier.create(configuration));
  }
  async prepareMail(params) {
    const { message, senderMessagingKey } = params;
    if (message.subject.length === 0) {
      return { error: new PreflightCheckError("Subject must not be empty.") };
    }
    if (message.plainTextMessage.length === 0) {
      return { error: new PreflightCheckError("Content plaintext must not be empty.") };
    }
    if (message.message.length === 0) {
      return { error: new PreflightCheckError("Content html must not be empty.") };
    }
    const allRecipients = [
      ...message.recipients,
      ...message.blindCarbonCopyRecipients,
      ...message.carbonCopyRecipients
    ];
    if (allRecipients.length === 0) {
      return { error: new PreflightCheckError("No recipients found.") };
    }
    const isSenderMatching = await this.senderVerifier.verifySenderOwnsFromAddress(
      message.from.address,
      senderMessagingKey.publicKey
    );
    if (!isSenderMatching) {
      return { error: new ProvidedMessagingKeyIncorrectError("sender") };
    }
    const allParticipants = [...allRecipients, message.from];
    if (message.replyTo != null) {
      allParticipants.push(message.replyTo);
    }
    const { data: resolvedAddresses, error } = await this.messagingKeys.resolveMany(
      allParticipants.map((x) => x.address)
    );
    if (error) {
      return { error };
    }
    const messagePayloads = await createMailPayloads(
      params.senderMessagingKey,
      resolvedAddresses,
      message,
      params.payloadPluginHeaders
    );
    return {
      data: {
        distributions: messagePayloads.distributions,
        message: messagePayloads.original,
        resolvedAddresses
      }
    };
  }
};

export {
  MailPreparer
};
