"use strict";Object.defineProperty(exports, "__esModule", {value: true});

var _chunkESCCOX3Vjs = require('./chunk-ESCCOX3V.js');


var _chunkFJ3BB6CVjs = require('./chunk-FJ3BB6CV.js');


var _chunkPCGAQDYDjs = require('./chunk-PCGAQDYD.js');

// src/messagingKeys/privateMessagingKeys.ts
var _crypto = require('@mailchain/crypto');
var _signatures = require('@mailchain/signatures');
var PrivateMessagingKeys = class {
  constructor(messagingKeys, addressNonce) {
    this.messagingKeys = messagingKeys;
    this.addressNonce = addressNonce;
  }
  static create(config) {
    return new PrivateMessagingKeys(_chunkESCCOX3Vjs.MessagingKeys.create(config), _chunkFJ3BB6CVjs.AddressNonce.create(config));
  }
  async getExportablePrivateMessagingKey(address, keyRing) {
    const { data: resolvedAddress, error: resolveAddressError } = await this.messagingKeys.resolve(address);
    if (resolveAddressError != null) {
      return { error: resolveAddressError };
    }
    const { data: getMessagingKeyLatestNonce, error: getMessagingKeyLatestNonceError } = await this.addressNonce.getMessagingKeyLatestNonce(
      resolvedAddress.protocolAddress,
      resolvedAddress.protocol
    );
    if (getMessagingKeyLatestNonceError != null) {
      return { error: getMessagingKeyLatestNonceError };
    }
    if (resolvedAddress.type === "vended") {
      return { error: new (0, _chunkPCGAQDYDjs.AddressNotRegisteredError)() };
    }
    const privateMessagingKey = keyRing.addressExportableMessagingKey(
      resolvedAddress.protocolAddress,
      resolvedAddress.protocol,
      getMessagingKeyLatestNonce
    );
    if (!_crypto.isPublicKeyEqual.call(void 0, privateMessagingKey.publicKey, resolvedAddress.messagingKey)) {
      return { error: new (0, _signatures.ProvidedMessagingKeyIncorrectError)("address") };
    }
    return { data: privateMessagingKey };
  }
};



exports.PrivateMessagingKeys = PrivateMessagingKeys;
