import {
  InvalidContractResponseError,
  MessagingKeyNotFoundInContractError
} from "./chunk-TACI5AZH.mjs";

// src/messagingKeys/contractResolvers/near.ts
import { encodeUtf8, decodeBase64, decodeHex } from "@mailchain/encoding";
import { publicKeyFromKind } from "@mailchain/crypto";
import axios from "axios";
import { NEAR } from "@mailchain/addressing";
var NearContractCallResolver = class {
  constructor(rpcEndpoint, axiosInstance) {
    this.rpcEndpoint = rpcEndpoint;
    this.axiosInstance = axiosInstance;
  }
  static create(config, axiosInstance = axios.create()) {
    return new NearContractCallResolver(config.nearRpcUrl, axiosInstance);
  }
  async resolve(contract) {
    const rpcResponse = await this.callContract(contract);
    const result = encodeUtf8(Uint8Array.from(rpcResponse.result));
    if (result === "null") {
      return { error: new MessagingKeyNotFoundInContractError() };
    }
    const parsedResult = parseMessagingKeyContractResult(result);
    if (parsedResult.error != null) {
      return parsedResult;
    }
    return {
      data: {
        messagingKey: parsedResult.data.messagingKey,
        protocol: NEAR,
        proof: {
          source: "ContractCall",
          call: contract
        }
      }
    };
  }
  async latestNonce(contract) {
    const rpcResponse = await this.callContract(contract);
    const result = encodeUtf8(Uint8Array.from(rpcResponse.result));
    if (result === "null") {
      throw new MessagingKeyNotFoundInContractError();
    }
    return parseInt(result, 10);
  }
  async callContract(contract) {
    if (contract.body.length === 0) {
      throw new Error("No body on contract call");
    }
    const body = encodeUtf8(decodeBase64(contract.body));
    const postData = JSON.parse(body);
    const response = await this.axiosInstance.request({
      method: contract.method,
      url: this.rpcEndpoint,
      data: postData
    });
    if (response.status !== 200) {
      throw new Error(
        `Failed to get messaging key from near, status: ${response.status}, response: ${response.data}`
      );
    }
    const { data } = response;
    if (data.result.error != null) {
      throw new Error(`Contract error; error=${data.result.error}`);
    }
    if (!data.result.result) {
      throw new Error(`No error but missing result response: ${data}`);
    }
    return data.result;
  }
};
function parseMessagingKeyContractResult(result) {
  const parsedResult = JSON.parse(result);
  if (typeof parsedResult !== "object") {
    return { error: new InvalidContractResponseError("Object expected.") };
  }
  const [curve, messageKey] = parsedResult;
  if (curve == null || messageKey == null) {
    return { error: new InvalidContractResponseError("Result does not have correct number of elements.") };
  }
  if (typeof curve !== "string") {
    return { error: new InvalidContractResponseError("Curve format must be string.") };
  }
  if (typeof messageKey !== "string") {
    return { error: new InvalidContractResponseError("Message key format must be string.") };
  }
  return { data: { messagingKey: publicKeyFromKind(curve, decodeHex(messageKey)) } };
}

export {
  NearContractCallResolver
};
