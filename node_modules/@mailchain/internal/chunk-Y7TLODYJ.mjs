import {
  MailchainAddressOwnershipIssuer
} from "./chunk-M64YVUDC.mjs";
import {
  CredentialPayloadTypes
} from "./chunk-UFSDCVPQ.mjs";
import {
  defaultConfiguration
} from "./chunk-TT2KNKAH.mjs";
import {
  ValidationError
} from "./chunk-6FVMZQ5S.mjs";

// src/verifiableCredentials/verifiableMailchainAddressOwner/factory.ts
import { checkAddressForErrors } from "@mailchain/addressing";
var VerifiableMailchainAddressOwnerCreator = class {
  constructor(signer, mailchainAddressOwnershipIssuer, mailchainAddressDomain) {
    this.signer = signer;
    this.mailchainAddressOwnershipIssuer = mailchainAddressOwnershipIssuer;
    this.mailchainAddressDomain = mailchainAddressDomain;
  }
  static create(signer, configuration = defaultConfiguration) {
    return new VerifiableMailchainAddressOwnerCreator(
      signer,
      MailchainAddressOwnershipIssuer.create(configuration),
      configuration.mailchainAddressDomain
    );
  }
  /**
   * Creates a verifiable presentation JWT for a mailchain address owner.
   * @param request - The verifiable presentation request containing the necessary information to create the JWT.
   * @returns A promise that resolves to a MailchainResult containing either the verifiable presentation JWT or an error.
   */
  async createVerifiableMailchainAddressOwner(request) {
    const validationError = validateVerifiablePresentationRequest(request, this.mailchainAddressDomain);
    if (validationError) {
      return {
        error: validationError
      };
    }
    const {
      requestId,
      from,
      to,
      actions,
      resources,
      signedCredentialExpiresAfter,
      signedCredentialExpiresAt,
      nonce
    } = request;
    return this.mailchainAddressOwnershipIssuer.createVerifiableMailchainAddressOwnership({
      address: to,
      requester: from,
      actions,
      resources,
      signer: this.signer,
      options: {
        requestId,
        expiresAt: signedCredentialExpiresAt,
        expiresIn: signedCredentialExpiresAfter,
        nonce
      }
    });
  }
};
function validateVerifiablePresentationRequest(request, mailchainAddressDomain) {
  const {
    from: requestFrom,
    to: requestTo,
    actions,
    requestExpiresAfter,
    signedCredentialExpiresAt,
    signedCredentialExpiresAfter
  } = request;
  if (CredentialPayloadTypes.indexOf(request.type) === -1) {
    return new ValidationError(`invalid type ${request.type}`);
  }
  if (request.version !== "1.0") {
    return new ValidationError(`invalid version ${request.version}`);
  }
  if (request.requestId == null || request.requestId.length === 0) {
    throw new ValidationError("requestId is empty");
  }
  if (requestExpiresAfter && signedCredentialExpiresAt && requestExpiresAfter > signedCredentialExpiresAt) {
    return new ValidationError("requestExpiresAfter must be before signedCredentialExpiresAt");
  }
  if (requestExpiresAfter instanceof Date && /* @__PURE__ */ new Date() > requestExpiresAfter) {
    return new ValidationError("request has expired");
  }
  if (signedCredentialExpiresAt && signedCredentialExpiresAt < /* @__PURE__ */ new Date()) {
    return new ValidationError("signed credential has expired");
  }
  if (signedCredentialExpiresAfter && signedCredentialExpiresAfter < 0) {
    return new ValidationError("signed credential signedCredentialExpiresAfter must be greater than 0");
  }
  if (actions.length === 0) {
    return new ValidationError("actions is empty");
  }
  if (request.resources.length === 0) {
    return new ValidationError("resources is empty");
  }
  const fromAddressError = checkAddressForErrors(requestFrom, mailchainAddressDomain);
  if (fromAddressError) {
    return fromAddressError;
  }
  const toAddressError = checkAddressForErrors(requestTo, mailchainAddressDomain);
  if (toAddressError) {
    return toAddressError;
  }
  if (request.approvedCallback.url.trim() === "") {
    return new ValidationError("approvedCallback.url is empty");
  }
  return void 0;
}

export {
  VerifiableMailchainAddressOwnerCreator,
  validateVerifiablePresentationRequest
};
