import {
  X_IDENTITY_KEYS
} from "./chunk-TM5VJXLZ.mjs";
import {
  simpleMimeHeaderParser
} from "./chunk-EQMT5WZC.mjs";

// src/formatters/parse.ts
import { ALL_PROTOCOLS } from "@mailchain/addressing";
import { publicKeyFromBytes } from "@mailchain/crypto";
import { decodeBase64, decodeHexZeroX, encodeUtf8 } from "@mailchain/encoding";
import { HEADER_LABELS } from "@mailchain/message-composer";
function decodeNodeContent(node) {
  const [, rawContent] = node.raw.split("\n\n");
  let decodedContent = null;
  if (node.contentTransferEncoding) {
    switch (node.contentTransferEncoding.value.toLowerCase()) {
      case "base64":
        decodedContent = decodeBase64(rawContent);
        break;
      case "7bit":
        try {
          return decodeURIComponent(rawContent);
        } catch (e) {
          return rawContent;
        }
      default:
        throw new Error(`unsupported content transfer encoding [${node.contentTransferEncoding.value}]`);
    }
  }
  if (decodedContent == null) {
    throw new Error("could not extract decodedContent from rawContent");
  }
  switch (node.contentType?.params?.charset?.toUpperCase()) {
    case "UTF-8":
      return encodeUtf8(decodedContent);
    case void 0:
      return decodedContent;
    default:
      throw new Error(`unsupported content charset [${node.contentType?.params?.charset}]`);
  }
}
function extractContent(nodes) {
  const extracted = { messages: {}, attachments: [] };
  for (const node of nodes) {
    const { contentType, headers } = node;
    if (contentType?.value === "multipart/alternative") {
      const childContent = extractContent(node.childNodes);
      extracted.messages = { ...childContent.messages, ...extracted.messages };
      extracted.attachments = [...extracted.attachments, ...childContent.attachments];
    } else if (contentType?.value === "text/plain" || contentType?.value === "text/html") {
      const content = decodeNodeContent(node);
      if (typeof content !== "string")
        throw new Error("cannot process message content being non-string");
      extracted.messages = { ...extracted.messages, [contentType.value]: content };
    } else if (headers["content-disposition"]?.[0]?.value === "attachment") {
      const content = decodeNodeContent(node);
      if (typeof content === "string")
        throw new Error("cannot process attachment content being string");
      extracted.attachments.push(content);
    }
  }
  return extracted;
}
async function parseMimeText(content) {
  const parse = (await import("emailjs-mime-parser")).default;
  const text = content.toString("utf-8");
  const headersMap = simpleMimeHeaderParser(text);
  const parsedParticipants = await parseParticipants(headersMap);
  const parsedMessage = parse(text);
  const { headers } = parsedMessage;
  const addressIdentityKeys = parseIdentityKeys(headersMap.get(X_IDENTITY_KEYS) ?? "");
  const extractedContent = parsedMessage.childNodes.length > 0 ? extractContent(parsedMessage.childNodes) : extractContent([parsedMessage]);
  const mailData = {
    id: parseMessageId(headers["message-id"][0].initial),
    date: new Date(headers["date"][0].value),
    ...parsedParticipants,
    subject: parseSubjectHeader(headers.subject?.[0].initial),
    plainTextMessage: extractedContent.messages["text/plain"],
    message: extractedContent.messages["text/html"]
  };
  return { mailData, addressIdentityKeys };
}
async function parseParticipants(headers) {
  const { parseOneAddress, parseAddressList } = (await import("email-addresses")).default;
  const fromValue = headers.get(HEADER_LABELS.From);
  const parsedFrom = parseOneAddress({ input: fromValue ?? "", rfc6532: true, rejectTLD: true });
  if (parsedFrom == null)
    throw new Error(`message doesn't include valid 'from' header field [${fromValue}]`);
  const from = isParsedMailbox(parsedFrom) ? { name: parsedFrom.name ?? "", address: parsedFrom.address } : { name: parsedFrom.name, address: parsedFrom.addresses[0].address };
  const replyTooValue = headers.get(HEADER_LABELS.ReplyTo);
  const parsedReplyTo = parseOneAddress({ input: replyTooValue ?? "", rfc6532: true, rejectTLD: true });
  let replyTo = void 0;
  if (parsedReplyTo != null) {
    replyTo = isParsedMailbox(parsedReplyTo) ? { name: parsedReplyTo.name ?? "", address: parsedReplyTo.address } : { name: parsedReplyTo.name, address: parsedReplyTo.addresses[0].address };
  }
  function parseAddresses(headerLabel) {
    const result = [];
    const headerValue = headers.get(headerLabel);
    if (headerValue != null) {
      const parsedAddresses = parseAddressList({ input: headerValue, rfc6532: true, rejectTLD: true }) ?? [];
      for (const address of parsedAddresses) {
        if (isParsedMailbox(address)) {
          result.push({ name: address.name ?? "", address: address.address });
        } else {
          result.push(
            ...address.addresses.map((a) => ({ name: a.name ?? address.name, address: a.address }))
          );
        }
      }
    }
    return result;
  }
  const recipients = parseAddresses(HEADER_LABELS.To);
  const carbonCopyRecipients = parseAddresses(HEADER_LABELS.Cc);
  const blindCarbonCopyRecipients = parseAddresses(HEADER_LABELS.Bcc);
  return { from, replyTo, recipients, carbonCopyRecipients, blindCarbonCopyRecipients };
}
function isParsedMailbox(mailboxOrGroup) {
  return mailboxOrGroup.type === "mailbox";
}
function parseMessageId(messageIdHeader) {
  if (messageIdHeader.startsWith("<") && messageIdHeader.endsWith(">")) {
    return messageIdHeader.slice(1, -1);
  }
  return messageIdHeader;
}
function parseSubjectHeader(rawSubject) {
  if (!rawSubject.startsWith("=?"))
    return rawSubject;
  const lines = rawSubject.split("	");
  let encodedContent = "";
  let contentEncoding = null;
  let contentCharset = null;
  for (const line of lines) {
    const [, charset, encoding, encodedText] = line.split("?");
    if (contentEncoding == null) {
      contentEncoding = encoding;
    } else if (contentEncoding !== encoding) {
      throw new Error(`mixed encoding of subject lines, expected [${contentEncoding}], received [${encoding}]`);
    }
    if (contentCharset == null) {
      contentCharset = charset;
    } else if (contentCharset !== charset) {
      throw new Error(`mixed charset of subject lines, expected [${contentCharset}], received [${charset}]`);
    }
    encodedContent += encodedText;
  }
  let decodedContent = null;
  if (contentEncoding === "B") {
    decodedContent = decodeBase64(encodedContent);
  }
  let charsetEncodedContent = null;
  if (decodedContent) {
    if (contentCharset?.toUpperCase() === "UTF-8") {
      charsetEncodedContent = encodeUtf8(decodedContent);
    }
  }
  if (charsetEncodedContent && charsetEncodedContent.indexOf("%") > -1) {
    try {
      return decodeURIComponent(charsetEncodedContent);
    } catch (e) {
    }
  }
  return charsetEncodedContent ?? encodedContent;
}
function parseIdentityKeys(attrStr) {
  const result = /* @__PURE__ */ new Map();
  for (const attrPairStr of attrStr.split(";")) {
    const [attrKey, quotedValue] = attrPairStr.trim().split("=");
    if (attrKey == null || attrKey.length === 0 || quotedValue == null || quotedValue.length === 0)
      continue;
    const value = quotedValue.substring(1, quotedValue.length - 1);
    if (attrKey === "v") {
      if (value !== "1") {
        console.warn(`unsupported ${X_IDENTITY_KEYS} version of [${value}]`);
        return /* @__PURE__ */ new Map();
      }
    } else {
      const [encodedIdentityKey, protocol] = value.split(":");
      if (!ALL_PROTOCOLS.includes(protocol)) {
        console.warn(`address [${attrKey}] has unsupported protocol [${protocol}]`);
      }
      try {
        const identityKey = publicKeyFromBytes(decodeHexZeroX(encodedIdentityKey));
        result.set(attrKey, { ...{ identityKey, protocol } });
      } catch (e) {
        console.warn(
          `failed decoding identity key of address [${attrKey}] for value [${encodedIdentityKey}]`,
          e
        );
      }
    }
  }
  return result;
}

export {
  parseMimeText
};
