"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _chunkM3LP2VEGjs = require('./chunk-M3LP2VEG.js');


var _chunkEYBVHNHSjs = require('./chunk-EYBVHNHS.js');


var _chunkFNO5PLBJjs = require('./chunk-FNO5PLBJ.js');


var _chunkR63BUJ2Xjs = require('./chunk-R63BUJ2X.js');


var _chunkMPOR65BQjs = require('./chunk-MPOR65BQ.js');

// src/receiving/mail/mail.ts
var _axios = require('axios'); var _axios2 = _interopRequireDefault(_axios);
var _encoding = require('@mailchain/encoding');
var MailReceiver = class {
  constructor(deliveryRequests, mailerReceiver, payloadReceiver, mailchainAddressDomain) {
    this.deliveryRequests = deliveryRequests;
    this.mailerReceiver = mailerReceiver;
    this.payloadReceiver = payloadReceiver;
    this.mailchainAddressDomain = mailchainAddressDomain;
  }
  static create(configuration, receiverMessagingKeyDecrypter, axiosInstance = _axios2.default.create()) {
    return new MailReceiver(
      _chunkR63BUJ2Xjs.DeliveryRequests.create(configuration, receiverMessagingKeyDecrypter),
      _chunkEYBVHNHSjs.MailerContentResolver.create(configuration, axiosInstance),
      _chunkFNO5PLBJjs.PayloadReceiver.create(configuration, receiverMessagingKeyDecrypter, axiosInstance),
      configuration.mailchainAddressDomain
    );
  }
  /**
   * Confirm the delivery of a mail has been completed.
   * @param hash of the delivery request.
   */
  async confirmDelivery(deliveryRequestHash) {
    await this.deliveryRequests.confirmDelivery(deliveryRequestHash);
  }
  /**
   * Get all undelivered mail.
   * @returns the mail that has been received.
   */
  async getUndelivered() {
    const undeliveredPayloads = await this.payloadReceiver.getUndelivered();
    return Promise.all(
      undeliveredPayloads.map(async (undeliveredPayload) => {
        switch (undeliveredPayload.status) {
          case "success":
            return this.processReceivedPayload(undeliveredPayload);
          case "error-payload":
          case "error-delivery-request":
            return {
              status: "failure",
              cause: undeliveredPayload.cause
            };
          default:
            return {
              status: "failure",
              cause: new Error("failed processing received payload, unknown status")
            };
        }
      })
    );
  }
  async processReceivedPayload(undeliveredPayload) {
    try {
      return {
        status: "success",
        payload: await this.processReceivedPayloadData(undeliveredPayload.payload),
        deliveryRequestHash: undeliveredPayload.deliveryRequestHash
      };
    } catch (e) {
      return { status: "failure", cause: new Error("failed processing received payload", { cause: e }) };
    }
  }
  /**
   * creates the mail content from the payload.
   * @param payload the decrypted payload received from the network.
   * @returns
   */
  async processReceivedPayloadData(payload) {
    switch (payload.Headers.ContentType) {
      case "message/x.mailchain":
        return payload;
      case "message/x.mailchain-mailer":
        return await this.mailerReceiver.get(payload);
      case "application/vnd.mailchain.verified-credential-request":
        const validationError = _chunkM3LP2VEGjs.validateVerifiablePresentationRequest.call(void 0, 
          _chunkMPOR65BQjs.parseVerifiablePresentationRequest.call(void 0, _encoding.encodeUtf8.call(void 0, payload.Content)),
          this.mailchainAddressDomain
        );
        if (validationError)
          throw new Error(`Invalid Verifiable Presentation Request`, { cause: validationError });
        return payload;
      default:
        throw new Error(`Unsupported content type: ${payload.Headers.ContentType}`);
    }
  }
};



exports.MailReceiver = MailReceiver;
