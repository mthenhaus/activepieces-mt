"use strict";Object.defineProperty(exports, "__esModule", {value: true});// src/mailbox/addressHasher.ts
var _addressing = require('@mailchain/addressing');
var _sha3 = require('@noble/hashes/sha3');
function mailchainAddressHasher(identityKeyResolver, keyRing) {
  const accountIdentityKey = keyRing.accountIdentityKey().publicKey;
  return async (addresses) => {
    const addressesHashes = /* @__PURE__ */ new Map();
    for (const address of addresses) {
      const nsAddress = _addressing.parseNameServiceAddress.call(void 0, address);
      const addressHashes = [];
      try {
        const result = await identityKeyResolver(nsAddress);
        if (result) {
          const { identityKey, protocol } = result;
          const hash2 = createAddressIdentityKeyHash(accountIdentityKey, identityKey, protocol);
          addressHashes.push({ hash: hash2, type: "identity-key" });
        }
      } catch (e) {
        console.warn(`failed creating AddressIdentityKey hash for address [${address}]`, e);
      }
      const hash = createAddressValueHash(accountIdentityKey, nsAddress.username);
      addressHashes.push({ hash, type: "username" });
      addressesHashes.set(address, addressHashes);
    }
    return addressesHashes;
  };
}
function createAddressIdentityKeyHash(accountIdentity, addressIdentity, protocol) {
  const input = new Uint8Array([...addressIdentity.bytes, ...Buffer.from(protocol), ...accountIdentity.bytes]);
  return _sha3.sha3_256.call(void 0, input).slice(0, 16);
}
function createAddressValueHash(accountIdentity, addressValue) {
  const input = new Uint8Array([...Buffer.from(addressValue), ...accountIdentity.bytes]);
  return _sha3.sha3_256.call(void 0, input).slice(0, 16);
}
function getAddressHash(hashMap, address, ...types) {
  const hashes = hashMap.get(address);
  if (hashes == null)
    throw new Error(`hash for address ${address} not found`);
  for (const type of types) {
    const typeHash = hashes.find((h) => h.type === type);
    if (typeHash != null)
      return typeHash.hash;
  }
  throw new Error(`hash of types [${types}] not found for address [${address}]`);
}
function getAddressHashes(hashMap, address) {
  const hashes = hashMap.get(address);
  if (hashes == null || hashes.length === 0)
    throw new Error(`hash for address ${address} not found`);
  return hashes.map((h) => h.hash);
}
function getAddressesHashes(hashMap, addresses) {
  return addresses.flatMap((address) => getAddressHashes(hashMap, address));
}
function getMailAddressesHashes(hashMap, addresses) {
  return getAddressesHashes(
    hashMap,
    addresses.map((a) => a.address)
  );
}







exports.mailchainAddressHasher = mailchainAddressHasher; exports.getAddressHash = getAddressHash; exports.getAddressHashes = getAddressHashes; exports.getAddressesHashes = getAddressesHashes; exports.getMailAddressesHashes = getMailAddressesHashes;
