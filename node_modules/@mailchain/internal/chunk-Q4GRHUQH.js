"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } }

var _chunkQOTIAHF7js = require('./chunk-QOTIAHF7.js');

// src/nameservices/nameservices.ts
var _crypto = require('@mailchain/crypto');
var _encoding = require('@mailchain/encoding');









var _addressing = require('@mailchain/addressing');
var _nameservices = require('@mailchain/addressing/nameservices');
var _api = require('@mailchain/api');
var PROTOCOLS_SUPPORTING_NAMESERVICE = [_addressing.ETHEREUM, _addressing.TEZOS, _addressing.SOLANA];
var Nameservices = class {
  constructor(identityKeysApi, identityKeysService, mailchainAddressDomain) {
    this.identityKeysApi = identityKeysApi;
    this.identityKeysService = identityKeysService;
    this.mailchainAddressDomain = mailchainAddressDomain;
  }
  static create(config) {
    const identityKeysApi = _api.IdentityKeysApiFactory.call(void 0, _api.createAxiosConfiguration.call(void 0, config.apiPath));
    const identityKeysService = _chunkQOTIAHF7js.IdentityKeys.create(config);
    return new Nameservices(identityKeysApi, identityKeysService, config.mailchainAddressDomain);
  }
  async reverseResolveNames(identityKey, kind) {
    return this.identityKeysApi.getIdentityKeyResolvableNames(_encoding.encodeHexZeroX.call(void 0, _crypto.publicKeyToBytes.call(void 0, identityKey)), kind).then(({ data }) => {
      return (_nullishCoalesce(data.resolvableNames, () => ( []))).map((resolved) => ({
        kind: resolved.kind,
        address: _addressing.parseNameServiceAddress.call(void 0, resolved.fullAddress),
        resolver: resolved.resolver,
        metadata: _nullishCoalesce(resolved.metadata, () => ( void 0))
      }));
    });
  }
  async nameResolvesToMailbox(nsName, mailboxIdentityKey) {
    for (const nsDesc of _nameservices.NAMESERVICE_DESCRIPTIONS) {
      const nsAddress = _addressing.createNameServiceAddress.call(void 0, nsName, nsDesc.name, this.mailchainAddressDomain);
      try {
        const addressIdentityKey = await this.identityKeysService.getAddressIdentityKey(nsAddress);
        if (addressIdentityKey != null && _crypto.isPublicKeyEqual.call(void 0, addressIdentityKey.identityKey, mailboxIdentityKey)) {
          return nsAddress;
        }
      } catch (e) {
        console.log(`failed to resolve address: ${_addressing.formatAddress.call(void 0, nsAddress, "mail")}`, e);
      }
    }
    return null;
  }
  async tokenResolvesToMailbox(tokenId, contractAddress, mailbox) {
    const { protocol } = mailbox.messagingKeyParams;
    const contractNsAddress = _addressing.createNameServiceAddress.call(void 0, contractAddress, protocol, this.mailchainAddressDomain);
    const contractAddressError = _addressing.checkAddressForErrors.call(void 0, 
      _addressing.formatAddress.call(void 0, contractNsAddress, "mail"),
      this.mailchainAddressDomain
    );
    if (contractAddressError != null) {
      throw new Error(`Invalid contract address ${contractAddress} for protocol ${protocol}`);
    }
    const tokenNsAddress = _addressing.createNameServiceAddress.call(void 0, 
      `${tokenId}.${contractAddress}`,
      protocol,
      this.mailchainAddressDomain
    );
    if (!_addressing.isTokenAddress.call(void 0, tokenNsAddress)) {
      throw new Error(`Invalid address ${_addressing.formatAddress.call(void 0, tokenNsAddress, "mail")}`);
    }
    try {
      const tokenAddressIdentityKey = await this.identityKeysService.getAddressIdentityKey(tokenNsAddress);
      if (tokenAddressIdentityKey != null && _crypto.isPublicKeyEqual.call(void 0, tokenAddressIdentityKey.identityKey, mailbox.identityKey)) {
        return tokenNsAddress;
      }
    } catch (e) {
      console.log(`failed to resolve address: ${_addressing.formatAddress.call(void 0, tokenNsAddress, "mail")}`, e);
    }
    return null;
  }
};




exports.PROTOCOLS_SUPPORTING_NAMESERVICE = PROTOCOLS_SUPPORTING_NAMESERVICE; exports.Nameservices = Nameservices;
