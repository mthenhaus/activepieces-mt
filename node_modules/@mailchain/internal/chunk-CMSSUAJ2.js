"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _chunkQOTIAHF7js = require('./chunk-QOTIAHF7.js');

// src/messageSync/previousMessageSync.ts
var _crypto = require('@mailchain/crypto');
var _encoding = require('@mailchain/encoding');
var _protocols = require('@mailchain/addressing/protocols');
var _functions = require('@mailchain/keyring/functions');





var _api = require('@mailchain/api');
var _uniqByjs = require('lodash/uniqBy.js'); var _uniqByjs2 = _interopRequireDefault(_uniqByjs);
var _addressing = require('@mailchain/addressing');
var PreviousMessageSync = class {
  constructor(identityKeys, messagingKeysApiFactory, keyRing, messageSync) {
    this.identityKeys = identityKeys;
    this.messagingKeysApiFactory = messagingKeysApiFactory;
    this.keyRing = keyRing;
    this.messageSync = messageSync;
  }
  static create(sdkConfig, keyRing, messageSync) {
    const axiosConfig = _api.createAxiosConfiguration.call(void 0, sdkConfig.apiPath);
    return new PreviousMessageSync(
      _chunkQOTIAHF7js.IdentityKeys.create(sdkConfig),
      (messagingKey) => _api.MessagingKeysApiFactory.call(void 0, axiosConfig, void 0, _api.getAxiosWithSigner.call(void 0, messagingKey)),
      keyRing,
      messageSync
    );
  }
  async sync(mailbox) {
    const messagingKeysApi = this.messagingKeysApiFactory(
      this.keyRing.addressMessagingKey(
        _addressing.encodeAddressByProtocol.call(void 0, mailbox.messagingKeyParams.address, mailbox.messagingKeyParams.protocol).encoded,
        mailbox.messagingKeyParams.protocol,
        mailbox.messagingKeyParams.nonce
      )
    );
    const encodedIdentityKey = _encoding.encodeHexZeroX.call(void 0, _crypto.publicKeyToBytes.call(void 0, mailbox.identityKey));
    const addresses = await this.identityKeys.reverse(mailbox.identityKey);
    const allAddresses = _uniqByjs2.default.call(void 0, 
      [
        ...addresses.map(
          (x) => ({
            protocol: x.protocol,
            address: x.value
          })
        ),
        ...mailbox.aliases.map(
          (x) => ({
            address: x.address.username,
            protocol: mailbox.messagingKeyParams.protocol
          })
        )
      ],
      (x) => x.address + x.protocol
    );
    const aliasMessagingKeys = await Promise.allSettled(
      allAddresses.map(async (x) => {
        if (!_protocols.isBlockchainProtocolEnabled.call(void 0, x.protocol)) {
          throw new Error(`unsupported protocol of [${x.protocol}] for [${x.address}]`);
        }
        const { privateKey: apiPrivateKey } = await messagingKeysApi.getVendedPrivateMessagingKey(x.address, x.protocol, encodedIdentityKey).then((r) => r.data);
        return { address: x, messagingKey: _api.ApiKeyConvert.private(apiPrivateKey) };
      })
    );
    const filteredAliasMessagingKeys = [];
    aliasMessagingKeys.forEach((x) => {
      if (x.status === "fulfilled") {
        filteredAliasMessagingKeys.push(x.value);
      }
    });
    const results = [];
    for (const x of filteredAliasMessagingKeys) {
      const { address, messagingKey } = x;
      const tmpResult = await this.messageSync.syncWithMessagingKey(mailbox, _functions.ecdhKeyRingDecrypter.call(void 0, messagingKey));
      results.push({ ...tmpResult, address });
    }
    return results;
  }
};



exports.PreviousMessageSync = PreviousMessageSync;
