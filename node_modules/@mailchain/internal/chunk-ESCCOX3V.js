"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }

var _chunk7SVBKWIYjs = require('./chunk-7SVBKWIY.js');





var _chunkPCGAQDYDjs = require('./chunk-PCGAQDYD.js');


var _chunkIVVOMLHBjs = require('./chunk-IVVOMLHB.js');


var _chunkRH2527U6js = require('./chunk-RH2527U6.js');


var _chunkXXPGZHWZjs = require('./chunk-XXPGZHWZ.js');

// src/messagingKeys/messagingKeys.ts
var _encoding = require('@mailchain/encoding');







var _addressing = require('@mailchain/addressing');
var _crypto = require('@mailchain/crypto');






var _api = require('@mailchain/api');
var _apiKeyToCryptoKey = require('@mailchain/api/helpers/apiKeyToCryptoKey');
var _axios = require('axios');
var ResoleAddressesFailuresError = class extends Error {
  constructor(successes, failures) {
    super(`Not all addresses were resolved. Check the failed resolutions for more information.`);
    this.successes = successes;
    this.failures = failures;
    _chunkXXPGZHWZjs.__publicField.call(void 0, this, "type", "resolve_addresses_failures");
    _chunkXXPGZHWZjs.__publicField.call(void 0, this, "docs", "https://docs.mailchain.com/developer/errors/codes#resolve_addresses_failures");
  }
};
var MessagingKeys = class {
  constructor(addressApi, identityKeysApi, messagingKeyContractCall, mailchainAddressDomain) {
    this.addressApi = addressApi;
    this.identityKeysApi = identityKeysApi;
    this.messagingKeyContractCall = messagingKeyContractCall;
    this.mailchainAddressDomain = mailchainAddressDomain;
  }
  static create(configuration) {
    return new MessagingKeys(
      _api.AddressesApiFactory.call(void 0, _api.createAxiosConfiguration.call(void 0, configuration.apiPath)),
      _api.IdentityKeysApiFactory.call(void 0, _api.createAxiosConfiguration.call(void 0, configuration.apiPath)),
      _chunk7SVBKWIYjs.MessagingKeyContractCall.create(configuration),
      configuration.mailchainAddressDomain
    );
  }
  /**
   * Resolve the messaging key for the given address.
   *
   * @param address Address to resolve.
   * @param at Date to resolve the address at. When no date is provided, the address resolves using the latest block.
   *
   * @returns A {@link ResolvedAddress resolved address} which may be a registered or vended.
   *
   * @example
   * import { messagingKeys } from '@mailchain/sdk';
   *
   * const resolvedAddress = await messagingKeys.resolve(address);
   * console.log(resolvedAddress);
   *
   */
  async resolve(address, at) {
    const validateAddressError = _addressing.checkAddressForErrors.call(void 0, address, this.mailchainAddressDomain);
    if (validateAddressError != null) {
      return { error: validateAddressError };
    }
    const { data: addressMessagingKeyResponse, error: addressMessagingKeyError } = await this.getAddressMessagingKey(address, at);
    if (addressMessagingKeyError != null) {
      return { error: addressMessagingKeyError };
    }
    const { data: resolvedAddress, error: resolveAddressError } = await this.messagingKeyContractCall.resolve(
      addressMessagingKeyResponse.contractCall,
      addressMessagingKeyResponse.identityKey ? _apiKeyToCryptoKey.convertPublic.call(void 0, addressMessagingKeyResponse.identityKey) : void 0
    );
    if (resolveAddressError) {
      return { error: resolveAddressError };
    }
    return { data: { ...resolvedAddress, mailchainAddress: address } };
  }
  async resolveMany(addresses, at) {
    const deduplicatedAddresses = [...new Set(addresses)];
    const resolvedAddresses = await Promise.all(
      deduplicatedAddresses.map(async (address) => {
        const resolvedAddress = await this.resolve(address, at);
        return { params: address, result: resolvedAddress };
      })
    );
    const { failures, successes } = _chunkIVVOMLHBjs.partitionMailchainResults.call(void 0, resolvedAddresses);
    if (failures.length > 0) {
      return { error: new ResoleAddressesFailuresError(successes, failures) };
    }
    return {
      data: new Map(successes.map((r) => [r.params, r.data]))
    };
  }
  async update(proof) {
    const encodedIdentityKey = _encoding.encodeHexZeroX.call(void 0, _crypto.publicKeyToBytes.call(void 0, proof.identityKey));
    const encodedAddress = _addressing.encodeAddressByProtocol.call(void 0, proof.address, proof.protocol);
    await this.identityKeysApi.putMsgKeyByIDKey(encodedIdentityKey, {
      address: {
        encoding: _api.encodingTypeToEncodingEnum.call(void 0, encodedAddress.encoding),
        value: encodedAddress.encoded,
        network: proof.network,
        protocol: proof.protocol
      },
      locale: proof.locale,
      messageVariant: proof.messageVariant,
      messagingKey: _api.CryptoKeyConvert.public(proof.messagingKey),
      nonce: proof.nonce,
      signature: _encoding.encodeHexZeroX.call(void 0, proof.signature),
      signatureMethod: proof.signatureMethod
    });
  }
  async getAddressMessagingKey(address, at) {
    try {
      const atDate = at ? Math.round(at.getTime() / 1e3) : void 0;
      const { data } = await this.addressApi.getAddressMessagingKey(address, atDate);
      const protocol = data.contractCall.protocol;
      if (!_addressing.ALL_PROTOCOLS.includes(protocol)) {
        return { error: new (0, _addressing.ProtocolNotSupportedError)(protocol) };
      }
      return { data };
    } catch (e) {
      if (_axios.isAxiosError.call(void 0, e)) {
        switch (_optionalChain([e, 'access', _ => _.response, 'optionalAccess', _2 => _2.data, 'optionalAccess', _3 => _3.code])) {
          case "identity_provider_unsupported":
            return {
              error: new (0, _chunkPCGAQDYDjs.IdentityProviderUnsupportedError)()
            };
          case "identity_expired":
            return {
              error: new (0, _chunkPCGAQDYDjs.IdentityExpiredError)()
            };
          case "identity_provider_address_unsupported":
            return {
              error: new (0, _chunkPCGAQDYDjs.IdentityProviderAddressUnsupportedError)()
            };
          case "identity_not_found":
            return {
              error: new (0, _chunkPCGAQDYDjs.IdentityNotFoundError)()
            };
          case "address_format_invalid":
          case "tld_unknown":
            return {
              error: new (0, _addressing.BadlyFormattedAddressError)()
            };
          case "identity_address_invalid":
            return {
              error: new (0, _addressing.IdentityProviderAddressInvalidError)()
            };
        }
      }
      return {
        error: new (0, _chunkRH2527U6js.UnexpectedMailchainError)(`Failed to resolve messaging key of address ${address}`, {
          cause: e
        })
      };
    }
  }
  async getAddressMessagingKeyStatus(address, at) {
    try {
      const atDate = at ? Math.round(at.getTime() / 1e3) : void 0;
      const { data } = await this.addressApi.getAddressMessagingKeyStatus(address, atDate);
      return { data: data.status };
    } catch (e) {
      return {
        error: new (0, _chunkPCGAQDYDjs.IdentityProviderUnsupportedError)()
      };
    }
  }
};




exports.ResoleAddressesFailuresError = ResoleAddressesFailuresError; exports.MessagingKeys = MessagingKeys;
