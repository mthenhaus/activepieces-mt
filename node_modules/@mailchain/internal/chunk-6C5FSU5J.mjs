import {
  encodeMailbox
} from "./chunk-EVV6JC6T.mjs";
import {
  parseVerifiablePresentationRequest
} from "./chunk-5DOTHQDR.mjs";
import {
  createMailchainMessageIdCreator
} from "./chunk-5TEMBX3F.mjs";
import {
  MessageMailboxOwnerMatcher
} from "./chunk-547VXI5B.mjs";
import {
  getAllMessagePreviewMigrations,
  preview
} from "./chunk-JK3UKI2T.mjs";
import {
  createMailchainUserMailboxHasher
} from "./chunk-EG2KUVUT.mjs";
import {
  IdentityKeys
} from "./chunk-7AQ4G6HT.mjs";
import {
  getAddressHash,
  getMailAddressesHashes,
  mailchainAddressHasher
} from "./chunk-ZKY3XRKG.mjs";
import {
  createMailchainApiAddressIdentityKeyResolver
} from "./chunk-NQ7EKPUI.mjs";
import {
  createMailchainMessageCrypto
} from "./chunk-54VUFHLB.mjs";
import {
  parseMimeText
} from "./chunk-A3TD54MW.mjs";

// src/mailbox/mailboxOperations.ts
import { formatAddress, parseNameServiceAddress } from "@mailchain/addressing";
import {
  InboxApiFactory,
  PutEncryptedMessageRequestBodyFolderEnum,
  createAxiosConfiguration,
  getAxiosWithSigner
} from "@mailchain/api";
import { publicKeyFromBytes, publicKeyToBytes } from "@mailchain/crypto";
import { decodeBase64, decodeHex, encodeBase64, encodeHex, encodeUtf8 } from "@mailchain/encoding";
import striptags from "striptags";
import { sha3_256 } from "@noble/hashes/sha3";
var MailchainMailboxOperations = class {
  constructor(inboxApi, messagePreviewCrypto, messageCrypto, messageMailboxOwnerMatcher, addressHasher, messageIdCreator, userMailboxHasher, messageDateOffset, migration, ruleEngine) {
    this.inboxApi = inboxApi;
    this.messagePreviewCrypto = messagePreviewCrypto;
    this.messageCrypto = messageCrypto;
    this.messageMailboxOwnerMatcher = messageMailboxOwnerMatcher;
    this.addressHasher = addressHasher;
    this.messageIdCreator = messageIdCreator;
    this.userMailboxHasher = userMailboxHasher;
    this.messageDateOffset = messageDateOffset;
    this.migration = migration;
    this.ruleEngine = ruleEngine;
  }
  static create(sdkConfig, keyRing, mailboxRuleEngine) {
    const axiosConfig = createAxiosConfiguration(sdkConfig.apiPath);
    const axiosClient = getAxiosWithSigner(keyRing.accountMessagingKey());
    const inboxApi = InboxApiFactory(axiosConfig, void 0, axiosClient);
    const messagePreviewCrypto = keyRing.inboxKey();
    const messageMessageCrypto = createMailchainMessageCrypto(keyRing);
    const messageMailboxOwnerMatcher = MessageMailboxOwnerMatcher.create(sdkConfig);
    const addressHasher = mailchainAddressHasher(
      createMailchainApiAddressIdentityKeyResolver(IdentityKeys.create(sdkConfig)),
      keyRing
    );
    const messageHasher = createMailchainMessageIdCreator(keyRing);
    const userMailboxHasher = createMailchainUserMailboxHasher(keyRing);
    const mailboxOperations = new MailchainMailboxOperations(
      inboxApi,
      messagePreviewCrypto,
      messageMessageCrypto,
      messageMailboxOwnerMatcher,
      addressHasher,
      messageHasher,
      userMailboxHasher,
      keyRing.inboxMessageDateOffset(),
      getAllMessagePreviewMigrations(sdkConfig),
      mailboxRuleEngine
    );
    return mailboxOperations;
  }
  async getMessage(messageId) {
    const message = await this.inboxApi.getMessage(messageId).then((res) => res.data.message);
    return this.handleMessagePreview(message);
  }
  async getInboxMessages(params) {
    return this.getMessagesInView(this.inboxApi.getMessagesInInboxView, params);
  }
  async getStarredMessages(params) {
    return this.getMessagesInView(this.inboxApi.getMessagesInStarredView, params);
  }
  async getTrashMessages(params) {
    return this.getMessagesInView(this.inboxApi.getMessagesInTrashView, params);
  }
  async getUnreadMessages(params) {
    return this.getMessagesInView(this.inboxApi.getMessagesInUnreadView, params);
  }
  async getSentMessages(params) {
    return this.getMessagesInView(this.inboxApi.getMessagesInSentView, params);
  }
  async getOutboxMessages(params) {
    return this.getMessagesInView(this.inboxApi.getMessagesInOutboxView, params);
  }
  async getArchivedMessages(params) {
    return this.getMessagesInView(this.inboxApi.getMessagesInArchivedView, params);
  }
  async getSpamMessages_unstable(params) {
    return this.getMessagesInView(this.inboxApi.getMessagesInSpamView, params);
  }
  async getMessagesInView(viewMethod, params) {
    const hashedMailbox = Array.isArray(params?.userMailboxes) ? (await Promise.all(params.userMailboxes.map((m) => this.userMailboxHasher(m)))).map(encodeHex) : void 0;
    const labels = void 0, from = void 0, to = void 0;
    const {
      data: { messages }
    } = await viewMethod(labels, from, to, params?.offset, params?.limit, hashedMailbox);
    return this.handleMessagePreviews(messages);
  }
  async handleMessagePreviews(messages) {
    const messagePreviews = [];
    for (const message of messages) {
      try {
        messagePreviews.push(await this.handleMessagePreview(message));
      } catch (error) {
        console.error(
          `failed to read message preview: version=${message.version};messageId=${message.messageId}`,
          error
        );
      }
    }
    return messagePreviews;
  }
  async handleMessagePreview(apiMessage) {
    const encryptedPreviewData = decodeBase64(apiMessage.encryptedPreview);
    const originalPreviewData = {
      version: apiMessage.version,
      messagePreview: preview.MessagePreview.decode(
        await this.messagePreviewCrypto.decrypt(encryptedPreviewData)
      )
    };
    const message = await this.migration.shouldApply(originalPreviewData) ? await this.migration.apply(originalPreviewData) : originalPreviewData;
    if (apiMessage.version !== message.version) {
      console.debug(`${apiMessage.messageId} migrated from v${apiMessage.version} to v${message.version}`);
    }
    const { messagePreview } = message;
    return {
      kind: apiMessage.kind,
      mailbox: publicKeyFromBytes(messagePreview.mailbox),
      messageId: apiMessage.messageId,
      owner: messagePreview.owner,
      to: messagePreview.to,
      bcc: messagePreview.bcc,
      cc: messagePreview.cc,
      from: messagePreview.from,
      subject: messagePreview.subject,
      snippet: messagePreview.snippet,
      hasAttachment: messagePreview.hasAttachment,
      timestamp: new Date(messagePreview.timestamp * 1e3),
      isRead: !apiMessage.systemLabels.includes("unread"),
      systemLabels: apiMessage.systemLabels
    };
  }
  async getFullMessage(messageId) {
    const encryptedMessage = await this.inboxApi.getEncryptedMessageBody(messageId, { responseType: "arraybuffer" }).then((res) => res.data);
    const messageData = await this.messageCrypto.decrypt(new Uint8Array(encryptedMessage));
    switch (messageData.Headers.ContentType) {
      case "application/vnd.mailchain.verified-credential-request":
        return { body: encodeUtf8(messageData.Content), payloadHeaders: messageData.Headers };
      case "message/x.mailchain":
      case "message/x.mailchain-mailer":
        const { mailData } = await this.extractPayloadInfo(messageData);
        return {
          replyTo: mailData.replyTo ? mailData.replyTo.address : void 0,
          body: mailData.message,
          payloadHeaders: messageData.Headers
        };
      default:
        throw new Error(`Unsupported content type of full message: ${messageData.Headers.ContentType}`);
    }
  }
  async getMessagesOverview(mailboxes) {
    const hashedMailboxes = new Map(
      await Promise.all(
        mailboxes.map(
          (mailbox) => this.userMailboxHasher(mailbox).then(
            (mailboxHash) => [encodeHex(mailboxHash), mailbox]
          )
        )
      )
    );
    const folders = /* @__PURE__ */ new Map();
    const messagesOverview = { total: 0, unread: 0, folders };
    const { data: apiMessagesOverview } = await this.inboxApi.getMailboxOverview([...hashedMailboxes.keys()]);
    apiMessagesOverview.mailboxes.forEach((apiMailboxOverview) => {
      const mailbox = hashedMailboxes.get(apiMailboxOverview.mailbox);
      if (mailbox == null) {
        console.warn(
          `getMailboxOverview returned mailbox (${apiMailboxOverview.mailbox}) that was not requested mailboxes`
        );
        return;
      }
      apiMailboxOverview.labels.forEach((apiLabelOverview) => {
        const folderOverview = folders.get(apiLabelOverview.label) ?? {
          total: 0,
          unread: 0,
          mailboxes: /* @__PURE__ */ new Map()
        };
        folderOverview.total += apiLabelOverview.total;
        folderOverview.unread += apiLabelOverview.unread;
        if (!["starred"].includes(apiLabelOverview.label)) {
          messagesOverview.total += apiLabelOverview.total;
          messagesOverview.unread += apiLabelOverview.unread;
        }
        folderOverview.mailboxes.set(encodeMailbox(mailbox), {
          total: apiLabelOverview.total,
          unread: apiLabelOverview.unread
        });
        folders.set(apiLabelOverview.label, folderOverview);
      });
    });
    return messagesOverview;
  }
  async saveSentMessage(params) {
    const messageId = await this.messageIdCreator({ type: "sent", mailData: params.content });
    const owner = parseNameServiceAddress(params.content.from.address);
    return this.saveMessage(messageId, params.payload, params.content, params.userMailbox, owner, "outbox");
  }
  async extractPayloadInfo(payload) {
    switch (payload.Headers.ContentType) {
      case "message/x.mailchain":
      case "message/x.mailchain-mailer":
        return parseMimeText(payload.Content);
      case "application/vnd.mailchain.verified-credential-request":
        const jsonStr = encodeUtf8(payload.Content);
        const messageId = encodeHex(
          sha3_256(
            Uint8Array.from([
              ...payload.Content,
              ...decodeHex(payload.Headers.Created.getTime().toString())
            ])
          )
        );
        const vcRequest = parseVerifiablePresentationRequest(jsonStr);
        const vcMailData = {
          id: messageId,
          subject: "Verifiable Presentation Request",
          from: {
            address: vcRequest.from,
            name: vcRequest.from
          },
          date: payload.Headers.Created,
          recipients: [
            {
              address: vcRequest.to,
              name: vcRequest.to
            }
          ],
          carbonCopyRecipients: [],
          blindCarbonCopyRecipients: [],
          message: jsonStr,
          plainTextMessage: `Request for ${vcRequest.resources.join(
            ", "
          )} to perform ${vcRequest.actions.join(", ")}).`
        };
        return {
          mailData: vcMailData,
          addressIdentityKeys: /* @__PURE__ */ new Map()
        };
      default:
        throw new Error(`Unsupported content type: ${payload.Headers.ContentType}`);
    }
  }
  async saveReceivedMessage({
    userMailbox,
    receivedTransportPayload
  }) {
    const payload = receivedTransportPayload;
    const { mailData, addressIdentityKeys } = await this.extractPayloadInfo(payload);
    const owners = await this.messageMailboxOwnerMatcher.withMessageIdentityKeys(addressIdentityKeys).findMatches(mailData, userMailbox);
    if (owners.length === 0)
      throw new Error("no owners found for message");
    const savedMessages = [];
    for (const { address: owner } of owners) {
      const messageId = await this.messageIdCreator({
        type: "received",
        mailData,
        owner: formatAddress(owner, "mail"),
        mailbox: userMailbox.identityKey
      });
      const savedMessage = await this.saveMessage(messageId, payload, mailData, userMailbox, owner, "inbox");
      if (this.ruleEngine != null) {
        const ruleEngineOutput = await this.ruleEngine.apply({ message: savedMessage });
        savedMessages.push(ruleEngineOutput.message);
      } else {
        savedMessages.push(savedMessage);
      }
    }
    if (savedMessages.length === 0) {
      throw new Error(`no message was saved for message with ID [${mailData.id}]`);
    }
    return savedMessages;
  }
  async saveMessage(messageId, payload, content, userMailbox, owner, folder) {
    const ownerAddress = formatAddress(owner, "mail");
    const protoMessagePreview = createProtoMessagePreview(userMailbox, owner, content);
    const encodedProtoMessagePreview = preview.MessagePreview.encode(protoMessagePreview).finish();
    const encryptedProtoMessagePreview = await this.messagePreviewCrypto.encrypt(encodedProtoMessagePreview);
    const messagePreview = {
      kind: payload.Headers.ContentType === "application/vnd.mailchain.verified-credential-request" ? "vc-request" : "mail",
      mailbox: userMailbox.identityKey,
      messageId,
      from: protoMessagePreview.from,
      to: protoMessagePreview.to,
      cc: protoMessagePreview.cc,
      bcc: protoMessagePreview.bcc,
      subject: protoMessagePreview.subject,
      owner: protoMessagePreview.owner,
      snippet: protoMessagePreview.snippet,
      isRead: folder === "outbox",
      systemLabels: folder === "outbox" ? ["outbox"] : ["unread", "inbox"],
      hasAttachment: false,
      timestamp: new Date(protoMessagePreview.timestamp * 1e3)
    };
    const encryptedMessage = await this.messageCrypto.encrypt(payload);
    const { recipients: to, carbonCopyRecipients: cc, blindCarbonCopyRecipients: bcc } = content;
    const addresses = [content.from, ...to, ...cc, ...bcc].map((a) => a.address);
    addresses.push(ownerAddress);
    const addressHashes = await this.addressHasher(addresses);
    const { resourceId } = await this.inboxApi.postEncryptedMessageBody(encryptedMessage).then((res) => res.data);
    await this.inboxApi.putEncryptedMessage(messageId, {
      kind: messagePreview.kind,
      version: 3,
      folder: folder === "outbox" ? PutEncryptedMessageRequestBodyFolderEnum.Outbox : PutEncryptedMessageRequestBodyFolderEnum.Inbox,
      date: messagePreview.timestamp.getTime() / 1e3 - this.messageDateOffset,
      mailbox: Array.from(await this.userMailboxHasher(userMailbox)),
      // Note: 'hashedOwner' is only 'username' hash because there is no need for 'identity-key' because that is covered by 'mailbox'
      hashedOwner: Array.from(getAddressHash(addressHashes, ownerAddress, "username")),
      // Note: 'hashedFrom' takes only single type of hash because there is API type restriction, so 'identity-key' hash is proffered.
      hashedFrom: Array.from(getAddressHash(addressHashes, content.from.address, "identity-key", "username")),
      hashedTo: getMailAddressesHashes(addressHashes, to).map((h) => Array.from(h)),
      hashedCc: getMailAddressesHashes(addressHashes, cc).map((h) => Array.from(h)),
      hashedBcc: getMailAddressesHashes(addressHashes, bcc).map((h) => Array.from(h)),
      encryptedPreview: encodeBase64(encryptedProtoMessagePreview),
      messageBodyResourceId: resourceId
    });
    return messagePreview;
  }
  async markOutboxMessageAsSent(messageId) {
    await this.modifySystemLabel(messageId, "outbox", false);
    await this.modifySystemLabel(messageId, "sent", true);
  }
  async modifyArchiveMessage(messageId, archived) {
    await this.modifySystemLabel(messageId, "archive", archived);
  }
  async modifyIsReadMessage(messageId, isRead) {
    await this.modifySystemLabel(messageId, "unread", !isRead);
  }
  async modifyTrashMessage(messageId, trash) {
    await this.modifySystemLabel(messageId, "trash", trash);
  }
  async modifyStarredMessage(messageId, isStarred) {
    await this.modifySystemLabel(messageId, "starred", isStarred);
  }
  async modifySpamMessage_unstable(messageId, isSpam) {
    await this.modifySystemLabel(messageId, "spam", isSpam);
  }
  async modifySystemLabel(messageId, systemLabel, include) {
    await this.modifyUserLabel(messageId, systemLabel, include);
  }
  async modifyUserLabel(messageId, userLabel, include) {
    if (include) {
      await this.inboxApi.putMessageLabel(messageId, userLabel);
    } else {
      await this.inboxApi.deleteMessageLabel(messageId, userLabel);
    }
  }
};
function createProtoMessagePreview(userMailbox, owner, content, snippetLength = 100) {
  return preview.MessagePreview.create({
    owner: formatAddress(owner, "mail"),
    mailbox: publicKeyToBytes(userMailbox.identityKey),
    to: content.recipients.map((it) => it.address),
    cc: content.carbonCopyRecipients.map((it) => it.address),
    bcc: content.blindCarbonCopyRecipients.map((it) => it.address),
    from: content.from.address,
    subject: content.subject,
    snippet: createMessagePreviewSnippet(content, snippetLength),
    hasAttachment: false,
    // TODO: replace with value from content.attachment when available,
    timestamp: Math.round(content.date.getTime() / 1e3)
  });
}
function createMessagePreviewSnippet(content, snippetLength = 100) {
  const plainTextMessage = striptags(content.plainTextMessage).replace(/\s+/g, " ");
  return plainTextMessage.substring(0, snippetLength - 1).trim();
}

export {
  MailchainMailboxOperations
};
