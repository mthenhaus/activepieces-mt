"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }




var _chunkPCGAQDYDjs = require('./chunk-PCGAQDYD.js');


var _chunkRH2527U6js = require('./chunk-RH2527U6.js');

// src/metadata/metadata.ts




var _addressing = require('@mailchain/addressing');
var _api = require('@mailchain/api');
var _axios = require('axios');
var MetaData = class {
  constructor(addressApi, mailchainAddressDomain) {
    this.addressApi = addressApi;
    this.mailchainAddressDomain = mailchainAddressDomain;
  }
  static create(configuration) {
    return new MetaData(
      _api.AddressesApiFactory.call(void 0, _api.createAxiosConfiguration.call(void 0, configuration.apiPath)),
      configuration.mailchainAddressDomain
    );
  }
  /**
   * Get metadata for the given address.
   *
   * @param address Address to get metadata for.
   *
   * @returns A {@link Metadata for address} which may be a token or an image.
   *
   * @example
   * import { metadata } from '@mailchain/sdk';
   *
   * const addressMetadata = await metadata.addressMetadata(address);
   * console.log(resolvedAddress);
   *
   */
  async addressMetadata(address) {
    const validateAddressError = _addressing.checkAddressForErrors.call(void 0, address, this.mailchainAddressDomain);
    if (validateAddressError != null) {
      return { error: validateAddressError };
    }
    const { data, error } = await this.getAddressMetadata(address);
    if (error != null) {
      return { error };
    }
    return { data };
  }
  async getAddressMetadata(address) {
    try {
      const { data } = await this.addressApi.getAddressMetadata(address);
      return { data };
    } catch (e) {
      if (_axios.isAxiosError.call(void 0, e)) {
        switch (_optionalChain([e, 'access', _ => _.response, 'optionalAccess', _2 => _2.data, 'optionalAccess', _3 => _3.code])) {
          case "identity_provider_unsupported":
            return {
              error: new (0, _chunkPCGAQDYDjs.IdentityProviderUnsupportedError)()
            };
          case "identity_expired":
            return {
              error: new (0, _chunkPCGAQDYDjs.IdentityExpiredError)()
            };
          case "identity_provider_address_unsupported":
            return {
              error: new (0, _chunkPCGAQDYDjs.IdentityProviderAddressUnsupportedError)()
            };
          case "identity_not_found":
            return {
              error: new (0, _chunkPCGAQDYDjs.IdentityNotFoundError)()
            };
          case "address_format_invalid":
          case "tld_unknown":
            return {
              error: new (0, _addressing.BadlyFormattedAddressError)()
            };
          case "identity_address_invalid":
            return {
              error: new (0, _addressing.IdentityProviderAddressInvalidError)()
            };
        }
      }
      return {
        error: new (0, _chunkRH2527U6js.UnexpectedMailchainError)(`Failed to get metadata for address ${address}`, {
          cause: e
        })
      };
    }
  }
};



exports.MetaData = MetaData;
