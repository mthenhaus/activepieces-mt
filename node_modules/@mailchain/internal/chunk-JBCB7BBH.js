"use strict";Object.defineProperty(exports, "__esModule", {value: true});

var _chunkWXB5VTLGjs = require('./chunk-WXB5VTLG.js');


var _chunkNJFE5JSPjs = require('./chunk-NJFE5JSP.js');


var _chunk5FSOOI2Gjs = require('./chunk-5FSOOI2G.js');


var _chunkESCCOX3Vjs = require('./chunk-ESCCOX3V.js');

// src/sending/mail/prepare.ts
var _signatures = require('@mailchain/signatures');
var MailPreparer = class {
  constructor(messagingKeys, senderVerifier) {
    this.messagingKeys = messagingKeys;
    this.senderVerifier = senderVerifier;
  }
  static create(configuration) {
    return new MailPreparer(_chunkESCCOX3Vjs.MessagingKeys.create(configuration), _chunk5FSOOI2Gjs.SenderVerifier.create(configuration));
  }
  async prepareMail(params) {
    const { message, senderMessagingKey } = params;
    if (message.subject.length === 0) {
      return { error: new (0, _chunkWXB5VTLGjs.PreflightCheckError)("Subject must not be empty.") };
    }
    if (message.plainTextMessage.length === 0) {
      return { error: new (0, _chunkWXB5VTLGjs.PreflightCheckError)("Content plaintext must not be empty.") };
    }
    if (message.message.length === 0) {
      return { error: new (0, _chunkWXB5VTLGjs.PreflightCheckError)("Content html must not be empty.") };
    }
    const allRecipients = [
      ...message.recipients,
      ...message.blindCarbonCopyRecipients,
      ...message.carbonCopyRecipients
    ];
    if (allRecipients.length === 0) {
      return { error: new (0, _chunkWXB5VTLGjs.PreflightCheckError)("No recipients found.") };
    }
    const isSenderMatching = await this.senderVerifier.verifySenderOwnsFromAddress(
      message.from.address,
      senderMessagingKey.publicKey
    );
    if (!isSenderMatching) {
      return { error: new (0, _signatures.ProvidedMessagingKeyIncorrectError)("sender") };
    }
    const allParticipants = [...allRecipients, message.from];
    if (message.replyTo != null) {
      allParticipants.push(message.replyTo);
    }
    const { data: resolvedAddresses, error } = await this.messagingKeys.resolveMany(
      allParticipants.map((x) => x.address)
    );
    if (error) {
      return { error };
    }
    const messagePayloads = await _chunkNJFE5JSPjs.createMailPayloads.call(void 0, 
      params.senderMessagingKey,
      resolvedAddresses,
      message,
      params.payloadPluginHeaders
    );
    return {
      data: {
        distributions: messagePayloads.distributions,
        message: messagePayloads.original,
        resolvedAddresses
      }
    };
  }
};



exports.MailPreparer = MailPreparer;
