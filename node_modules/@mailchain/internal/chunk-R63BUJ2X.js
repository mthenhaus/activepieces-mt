"use strict";Object.defineProperty(exports, "__esModule", {value: true});

var _chunkZIJL3L6Hjs = require('./chunk-ZIJL3L6H.js');

// src/receiving/deliveryRequests/deliveryRequests.ts




var _api = require('@mailchain/api');
var _crypto = require('@mailchain/crypto');
var _encoding = require('@mailchain/encoding');
var _signatures = require('@mailchain/signatures');
var DeliveryRequests = class {
  constructor(transportApi, messagingKey) {
    this.transportApi = transportApi;
    this.messagingKey = messagingKey;
  }
  static create(configuration, receiverMessagingKeyDecrypter) {
    return new DeliveryRequests(
      _api.TransportApiFactory.call(void 0, 
        _api.createAxiosConfiguration.call(void 0, configuration.apiPath),
        void 0,
        _api.getAxiosWithSigner.call(void 0, receiverMessagingKeyDecrypter)
      ),
      receiverMessagingKeyDecrypter
    );
  }
  async confirmDelivery(hash) {
    const signature = await _signatures.signMailchainDeliveryConfirmation.call(void 0, this.messagingKey, hash);
    await this.transportApi.putDeliveryRequestConfirmation(_encoding.encodeHexZeroX.call(void 0, hash), {
      signature: _encoding.encodeHexZeroX.call(void 0, signature)
    });
  }
  async getUndelivered() {
    const processed = this.transportApi.getDeliveryRequests().then(({ data: { deliveryRequests } }) => {
      return Promise.all(
        deliveryRequests.map((dr) => {
          const delivery = _chunkZIJL3L6Hjs.protocol.Delivery.decode(_encoding.decodeBase64.call(void 0, dr.data));
          return this.processDeliveryRequest(this.messagingKey, delivery, _encoding.decodeHexZeroX.call(void 0, dr.hash));
        })
      );
    });
    return processed;
  }
  async processDeliveryRequest(messagingKey, delivery, deliveryRequestHash) {
    try {
      const { envelope } = delivery;
      if (!envelope) {
        throw new Error("envelope is undefined");
      }
      const { ecdhKeyBundle, encryptedMessageKey, encryptedMessageUri } = envelope;
      if (!ecdhKeyBundle) {
        throw new Error("envelope does not contain ECDH key bundle");
      }
      if (!encryptedMessageKey) {
        throw new Error("envelope does not contain encryptedMessageKey");
      }
      if (!encryptedMessageUri) {
        throw new Error("envelope does not contain encryptedMessageUri");
      }
      if (!ecdhKeyBundle.publicEphemeralKey) {
        throw new Error("ECDH key bundle does not contain publicEphemeralKey");
      }
      const payloadRootEncryptionKeyBytes = await messagingKey.ecdhDecrypt(
        _crypto.publicKeyFromBytes.call(void 0, ecdhKeyBundle.publicEphemeralKey),
        encryptedMessageKey
      );
      if (payloadRootEncryptionKeyBytes.length === 0) {
        throw new Error("payloadRootEncryptionKey is empty");
      }
      const payloadRootEncryptionKey = _crypto.ED25519ExtendedPrivateKey.fromPrivateKey(
        _crypto.privateKeyFromBytes.call(void 0, payloadRootEncryptionKeyBytes)
      );
      const payloadUriBytes = await messagingKey.ecdhDecrypt(
        _crypto.publicKeyFromBytes.call(void 0, ecdhKeyBundle.publicEphemeralKey),
        encryptedMessageUri
      );
      if (payloadUriBytes.length === 0) {
        throw new Error("payloadUri is empty");
      }
      const payloadUri = _encoding.encodeUtf8.call(void 0, payloadUriBytes);
      return {
        status: "success",
        payloadRootEncryptionKey,
        payloadUri,
        deliveryRequestHash
      };
    } catch (error) {
      return {
        status: "failure",
        cause: error,
        deliveryRequestHash
      };
    }
  }
};



exports.DeliveryRequests = DeliveryRequests;
