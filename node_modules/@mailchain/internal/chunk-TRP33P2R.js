"use strict";Object.defineProperty(exports, "__esModule", {value: true});

var _chunkZ554MM7Zjs = require('./chunk-Z554MM7Z.js');


var _chunkZIJL3L6Hjs = require('./chunk-ZIJL3L6H.js');


var _chunkIVVOMLHBjs = require('./chunk-IVVOMLHB.js');

// src/sending/deliveryRequests/deliveryRequests.ts
var _crypto = require('@mailchain/crypto');
var _encoding = require('@mailchain/encoding');




var _api = require('@mailchain/api');
var SomeDeliveryRequestsFailedError = class extends Error {
  constructor(successes, failures) {
    super(
      `Not all delivery requests were successfully sent. Check the failed delivery requests to retry failed requests.`
    );
    this.successes = successes;
    this.failures = failures;
  }
};
var SendDeliveryRequestTransportError = class extends Error {
  constructor(cause, params) {
    super("failed sending delivery request", { cause });
    this.params = params;
  }
};
var DeliveryRequests = class {
  constructor(transportApi) {
    this.transportApi = transportApi;
  }
  static create(configuration, sender) {
    return new DeliveryRequests(
      _api.TransportApiFactory.call(void 0, _api.createAxiosConfiguration.call(void 0, configuration.apiPath), void 0, _api.getAxiosWithSigner.call(void 0, sender))
    );
  }
  /**
   * Send the same payload delivery request to multiple recipients
   */
  async sendManyDeliveryRequests(params) {
    const { recipients, payloadUri, payloadRootEncryptionKey } = params;
    const results = await Promise.all(
      recipients.map(async (recipientMessageKey) => {
        const sendDeliveryRequestParams = {
          recipientMessageKey,
          payloadUri,
          payloadRootEncryptionKey
        };
        const result = await this.sendDeliveryRequest(sendDeliveryRequestParams);
        return { result, params: sendDeliveryRequestParams };
      })
    );
    const { successes: sent, failures: failed } = _chunkIVVOMLHBjs.partitionMailchainResults.call(void 0, results);
    if (failed.length > 0) {
      return {
        error: new SomeDeliveryRequestsFailedError(sent, failed)
      };
    }
    return {
      data: sent.map((s) => s.data)
    };
  }
  /**
   * Create delivery request for the recipient of the message providing the key used to encrypt the payload.
   *
   * @param recipientMessageKey the key of the message
   * @param messageUri the URL to get the message from
   * @param payloadRootEncryptionKey the root ephemeral key used to encrypt the Payload
   */
  async sendDeliveryRequest(params) {
    const { recipientMessageKey, payloadRootEncryptionKey, payloadUri } = params;
    const deliveryCreated = await _chunkZ554MM7Zjs.createDelivery.call(void 0, recipientMessageKey, payloadRootEncryptionKey, payloadUri);
    try {
      const { deliveryRequestID: deliveryRequestId } = await this.transportApi.postDeliveryRequest({
        encryptedDeliveryRequest: _encoding.encodeBase64.call(void 0, _chunkZIJL3L6Hjs.protocol.Delivery.encode(deliveryCreated).finish()),
        recipientMessagingKey: _encoding.encodeHexZeroX.call(void 0, _crypto.publicKeyToBytes.call(void 0, recipientMessageKey))
      }).then((response) => response.data);
      return { data: { deliveryRequestId, recipientMessageKey } };
    } catch (e) {
      return {
        error: new SendDeliveryRequestTransportError(e, params)
      };
    }
  }
};





exports.SomeDeliveryRequestsFailedError = SomeDeliveryRequestsFailedError; exports.SendDeliveryRequestTransportError = SendDeliveryRequestTransportError; exports.DeliveryRequests = DeliveryRequests;
