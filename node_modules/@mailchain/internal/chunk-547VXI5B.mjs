import {
  IdentityKeys
} from "./chunk-7AQ4G6HT.mjs";
import {
  createMailchainApiAddressIdentityKeyResolver,
  createMessageHeaderIdentityKeyResolver
} from "./chunk-NQ7EKPUI.mjs";

// src/mailbox/messageMailboxOwnerMatcher.ts
import { parseNameServiceAddress } from "@mailchain/addressing";
import { isPublicKeyEqual } from "@mailchain/crypto";
import uniqBy from "lodash/uniqBy.js";
var MessageMailboxOwnerMatcher = class {
  constructor(addressIdentityKeyResolvers) {
    this.addressIdentityKeyResolvers = addressIdentityKeyResolvers;
  }
  /** Create {@link MessageMailboxOwnerMatcher} with {@link createMailchainApiAddressIdentityKeyResolver} as default resolver.  */
  static create(config) {
    const identityKeys = IdentityKeys.create(config);
    return new MessageMailboxOwnerMatcher([
      ["mailchain-api", createMailchainApiAddressIdentityKeyResolver(identityKeys)]
    ]);
  }
  /**
   * Build new {@link MessageMailboxOwnerMatcher} with an additional identity key resolver {@link createMessageHeaderIdentityKeyResolver}.
   *
   * Note: this doesn't modify the original {@link MessageMailboxOwnerMatcher}.
   */
  withMessageIdentityKeys(addressIdentityKeys) {
    const resolver = createMessageHeaderIdentityKeyResolver(addressIdentityKeys);
    return new MessageMailboxOwnerMatcher([["message-header", resolver], ...this.addressIdentityKeyResolvers]);
  }
  /** Find the matching {@link Alias} from the provided `mailData` that match to the `userMailbox`. */
  async findMatches(mailData, userMailbox) {
    const allRecipients = uniqBy(
      [...mailData.recipients, ...mailData.carbonCopyRecipients, ...mailData.blindCarbonCopyRecipients],
      (r) => r.address
    );
    const matches = [];
    for (const recipient of allRecipients) {
      const address = parseNameServiceAddress(recipient.address);
      for (const [matchBy, resolver] of this.addressIdentityKeyResolvers) {
        const result = await resolver(address);
        if (result != null && isPublicKeyEqual(result.identityKey, userMailbox.identityKey)) {
          matches.push({ address: parseNameServiceAddress(recipient.address), matchBy });
          break;
        }
      }
    }
    if (matches.length === 0) {
      return [{ address: userMailbox.aliases[0].address, matchBy: "fallback" }];
    }
    return matches;
  }
};

export {
  MessageMailboxOwnerMatcher
};
