import {
  createOriginHeader,
  createSignatureHeader,
  headersMapFromBuffers,
  parseOriginHeader,
  parseSignatureHeader
} from "./chunk-4L3C6JUD.mjs";
import {
  isResolvedMailerHeaders
} from "./chunk-QDOZM76B.mjs";
import {
  createContentBuffer,
  parseMailerContentFromJSON
} from "./chunk-5J52SPEE.mjs";

// src/transport/payload/headersSerialize.ts
import canonicalize from "canonicalize";
var HEADER_CONTENT_ENCODING = "Content-Encoding";
var HEADER_CONTENT_ENCRYPTION = "Content-Encryption";
var HEADER_CONTENT_LENGTH = "Content-Length";
var HEADER_CONTENT_SIGNATURE = "Content-Signature";
var HEADER_CONTENT_TYPE = "Content-Type";
var HEADER_CREATED = "Created";
var HEADER_ORIGIN = "Origin";
var HEADER_MAILER_CONTENT = "Mailer-Content";
var HEADER_PLUGINS = "Plugin";
var SerializablePayloadHeadersImpl = class {
  deserialize(buffer) {
    const { headers } = headersMapFromBuffers(buffer, [
      HEADER_CONTENT_ENCODING,
      HEADER_CONTENT_ENCRYPTION,
      HEADER_CONTENT_LENGTH,
      HEADER_CONTENT_SIGNATURE,
      HEADER_CONTENT_TYPE,
      HEADER_CREATED,
      HEADER_ORIGIN
    ]);
    const output = {
      ContentEncoding: headers.get(HEADER_CONTENT_ENCODING).toString(),
      ContentEncryption: headers.get(HEADER_CONTENT_ENCRYPTION).toString(),
      ContentLength: Number.parseInt(headers.get(HEADER_CONTENT_LENGTH).toString()),
      ContentSignature: parseSignatureHeader(headers.get(HEADER_CONTENT_SIGNATURE).toString()),
      ContentType: headers.get(HEADER_CONTENT_TYPE).toString(),
      Created: new Date(headers.get(HEADER_CREATED).toString()),
      Origin: parseOriginHeader(headers.get(HEADER_ORIGIN).toString()),
      PluginHeaders: headers.has(HEADER_PLUGINS) ? JSON.parse(headers.get(HEADER_PLUGINS)) : void 0
    };
    if (headers.get(HEADER_MAILER_CONTENT)) {
      const mailerOutput = {
        ...output,
        ContentType: output.ContentType,
        MailerContent: parseMailerContentFromJSON(headers.get(HEADER_MAILER_CONTENT).toString())
      };
      return mailerOutput;
    }
    return output;
  }
  serialize(headers) {
    const headersList = [];
    headersList.push(`${HEADER_CONTENT_ENCODING}: ${headers.ContentEncoding}`);
    headersList.push(`${HEADER_CONTENT_ENCRYPTION}: ${headers.ContentEncryption}`);
    headersList.push(`${HEADER_CONTENT_LENGTH}: ${headers.ContentLength}`);
    headersList.push(
      `${HEADER_CONTENT_SIGNATURE}: ${createSignatureHeader(headers.ContentSignature, headers.Origin)}`
    );
    headersList.push(`${HEADER_CONTENT_TYPE}: ${headers.ContentType}`);
    headersList.push(`${HEADER_CREATED}: ${headers.Created.toISOString()}`);
    headersList.push(`${HEADER_ORIGIN}: ${createOriginHeader(headers.Origin)}`);
    if (headers.PluginHeaders) {
      headersList.push(`${HEADER_PLUGINS}: ${canonicalize(headers.PluginHeaders)}`);
    }
    if (isResolvedMailerHeaders(headers)) {
      headersList.push(`${HEADER_MAILER_CONTENT}:  ${createContentBuffer(headers.MailerContent)}`);
    }
    return Buffer.from(headersList.join("\r\n"), "utf8");
  }
};

export {
  SerializablePayloadHeadersImpl
};
