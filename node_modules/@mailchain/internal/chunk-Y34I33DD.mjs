import {
  IdentityKeys
} from "./chunk-7AQ4G6HT.mjs";

// src/messageSync/previousMessageSync.ts
import { publicKeyToBytes } from "@mailchain/crypto";
import { encodeHexZeroX } from "@mailchain/encoding";
import { isBlockchainProtocolEnabled } from "@mailchain/addressing/protocols";
import { ecdhKeyRingDecrypter } from "@mailchain/keyring/functions";
import {
  MessagingKeysApiFactory,
  ApiKeyConvert,
  createAxiosConfiguration,
  getAxiosWithSigner
} from "@mailchain/api";
import uniqBy from "lodash/uniqBy.js";
import { encodeAddressByProtocol } from "@mailchain/addressing";
var PreviousMessageSync = class {
  constructor(identityKeys, messagingKeysApiFactory, keyRing, messageSync) {
    this.identityKeys = identityKeys;
    this.messagingKeysApiFactory = messagingKeysApiFactory;
    this.keyRing = keyRing;
    this.messageSync = messageSync;
  }
  static create(sdkConfig, keyRing, messageSync) {
    const axiosConfig = createAxiosConfiguration(sdkConfig.apiPath);
    return new PreviousMessageSync(
      IdentityKeys.create(sdkConfig),
      (messagingKey) => MessagingKeysApiFactory(axiosConfig, void 0, getAxiosWithSigner(messagingKey)),
      keyRing,
      messageSync
    );
  }
  async sync(mailbox) {
    const messagingKeysApi = this.messagingKeysApiFactory(
      this.keyRing.addressMessagingKey(
        encodeAddressByProtocol(mailbox.messagingKeyParams.address, mailbox.messagingKeyParams.protocol).encoded,
        mailbox.messagingKeyParams.protocol,
        mailbox.messagingKeyParams.nonce
      )
    );
    const encodedIdentityKey = encodeHexZeroX(publicKeyToBytes(mailbox.identityKey));
    const addresses = await this.identityKeys.reverse(mailbox.identityKey);
    const allAddresses = uniqBy(
      [
        ...addresses.map(
          (x) => ({
            protocol: x.protocol,
            address: x.value
          })
        ),
        ...mailbox.aliases.map(
          (x) => ({
            address: x.address.username,
            protocol: mailbox.messagingKeyParams.protocol
          })
        )
      ],
      (x) => x.address + x.protocol
    );
    const aliasMessagingKeys = await Promise.allSettled(
      allAddresses.map(async (x) => {
        if (!isBlockchainProtocolEnabled(x.protocol)) {
          throw new Error(`unsupported protocol of [${x.protocol}] for [${x.address}]`);
        }
        const { privateKey: apiPrivateKey } = await messagingKeysApi.getVendedPrivateMessagingKey(x.address, x.protocol, encodedIdentityKey).then((r) => r.data);
        return { address: x, messagingKey: ApiKeyConvert.private(apiPrivateKey) };
      })
    );
    const filteredAliasMessagingKeys = [];
    aliasMessagingKeys.forEach((x) => {
      if (x.status === "fulfilled") {
        filteredAliasMessagingKeys.push(x.value);
      }
    });
    const results = [];
    for (const x of filteredAliasMessagingKeys) {
      const { address, messagingKey } = x;
      const tmpResult = await this.messageSync.syncWithMessagingKey(mailbox, ecdhKeyRingDecrypter(messagingKey));
      results.push({ ...tmpResult, address });
    }
    return results;
  }
};

export {
  PreviousMessageSync
};
