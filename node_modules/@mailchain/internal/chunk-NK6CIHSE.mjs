import {
  MessagingKeyContractCall
} from "./chunk-FGMUYFWH.mjs";
import {
  IdentityExpiredError,
  IdentityNotFoundError,
  IdentityProviderAddressUnsupportedError,
  IdentityProviderUnsupportedError
} from "./chunk-E5ONHO3D.mjs";
import {
  partitionMailchainResults
} from "./chunk-TVSW4CHH.mjs";
import {
  UnexpectedMailchainError
} from "./chunk-QQZCHFKV.mjs";
import {
  __publicField
} from "./chunk-NHABU752.mjs";

// src/messagingKeys/messagingKeys.ts
import { encodeHexZeroX } from "@mailchain/encoding";
import {
  ALL_PROTOCOLS,
  BadlyFormattedAddressError,
  checkAddressForErrors,
  encodeAddressByProtocol,
  IdentityProviderAddressInvalidError,
  ProtocolNotSupportedError
} from "@mailchain/addressing";
import { publicKeyToBytes } from "@mailchain/crypto";
import {
  AddressesApiFactory,
  createAxiosConfiguration,
  IdentityKeysApiFactory,
  CryptoKeyConvert,
  encodingTypeToEncodingEnum
} from "@mailchain/api";
import { convertPublic } from "@mailchain/api/helpers/apiKeyToCryptoKey";
import { isAxiosError } from "axios";
var ResoleAddressesFailuresError = class extends Error {
  constructor(successes, failures) {
    super(`Not all addresses were resolved. Check the failed resolutions for more information.`);
    this.successes = successes;
    this.failures = failures;
    __publicField(this, "type", "resolve_addresses_failures");
    __publicField(this, "docs", "https://docs.mailchain.com/developer/errors/codes#resolve_addresses_failures");
  }
};
var MessagingKeys = class {
  constructor(addressApi, identityKeysApi, messagingKeyContractCall, mailchainAddressDomain) {
    this.addressApi = addressApi;
    this.identityKeysApi = identityKeysApi;
    this.messagingKeyContractCall = messagingKeyContractCall;
    this.mailchainAddressDomain = mailchainAddressDomain;
  }
  static create(configuration) {
    return new MessagingKeys(
      AddressesApiFactory(createAxiosConfiguration(configuration.apiPath)),
      IdentityKeysApiFactory(createAxiosConfiguration(configuration.apiPath)),
      MessagingKeyContractCall.create(configuration),
      configuration.mailchainAddressDomain
    );
  }
  /**
   * Resolve the messaging key for the given address.
   *
   * @param address Address to resolve.
   * @param at Date to resolve the address at. When no date is provided, the address resolves using the latest block.
   *
   * @returns A {@link ResolvedAddress resolved address} which may be a registered or vended.
   *
   * @example
   * import { messagingKeys } from '@mailchain/sdk';
   *
   * const resolvedAddress = await messagingKeys.resolve(address);
   * console.log(resolvedAddress);
   *
   */
  async resolve(address, at) {
    const validateAddressError = checkAddressForErrors(address, this.mailchainAddressDomain);
    if (validateAddressError != null) {
      return { error: validateAddressError };
    }
    const { data: addressMessagingKeyResponse, error: addressMessagingKeyError } = await this.getAddressMessagingKey(address, at);
    if (addressMessagingKeyError != null) {
      return { error: addressMessagingKeyError };
    }
    const { data: resolvedAddress, error: resolveAddressError } = await this.messagingKeyContractCall.resolve(
      addressMessagingKeyResponse.contractCall,
      addressMessagingKeyResponse.identityKey ? convertPublic(addressMessagingKeyResponse.identityKey) : void 0
    );
    if (resolveAddressError) {
      return { error: resolveAddressError };
    }
    return { data: { ...resolvedAddress, mailchainAddress: address } };
  }
  async resolveMany(addresses, at) {
    const deduplicatedAddresses = [...new Set(addresses)];
    const resolvedAddresses = await Promise.all(
      deduplicatedAddresses.map(async (address) => {
        const resolvedAddress = await this.resolve(address, at);
        return { params: address, result: resolvedAddress };
      })
    );
    const { failures, successes } = partitionMailchainResults(resolvedAddresses);
    if (failures.length > 0) {
      return { error: new ResoleAddressesFailuresError(successes, failures) };
    }
    return {
      data: new Map(successes.map((r) => [r.params, r.data]))
    };
  }
  async update(proof) {
    const encodedIdentityKey = encodeHexZeroX(publicKeyToBytes(proof.identityKey));
    const encodedAddress = encodeAddressByProtocol(proof.address, proof.protocol);
    await this.identityKeysApi.putMsgKeyByIDKey(encodedIdentityKey, {
      address: {
        encoding: encodingTypeToEncodingEnum(encodedAddress.encoding),
        value: encodedAddress.encoded,
        network: proof.network,
        protocol: proof.protocol
      },
      locale: proof.locale,
      messageVariant: proof.messageVariant,
      messagingKey: CryptoKeyConvert.public(proof.messagingKey),
      nonce: proof.nonce,
      signature: encodeHexZeroX(proof.signature),
      signatureMethod: proof.signatureMethod
    });
  }
  async getAddressMessagingKey(address, at) {
    try {
      const atDate = at ? Math.round(at.getTime() / 1e3) : void 0;
      const { data } = await this.addressApi.getAddressMessagingKey(address, atDate);
      const protocol = data.contractCall.protocol;
      if (!ALL_PROTOCOLS.includes(protocol)) {
        return { error: new ProtocolNotSupportedError(protocol) };
      }
      return { data };
    } catch (e) {
      if (isAxiosError(e)) {
        switch (e.response?.data?.code) {
          case "identity_provider_unsupported":
            return {
              error: new IdentityProviderUnsupportedError()
            };
          case "identity_expired":
            return {
              error: new IdentityExpiredError()
            };
          case "identity_provider_address_unsupported":
            return {
              error: new IdentityProviderAddressUnsupportedError()
            };
          case "identity_not_found":
            return {
              error: new IdentityNotFoundError()
            };
          case "address_format_invalid":
          case "tld_unknown":
            return {
              error: new BadlyFormattedAddressError()
            };
          case "identity_address_invalid":
            return {
              error: new IdentityProviderAddressInvalidError()
            };
        }
      }
      return {
        error: new UnexpectedMailchainError(`Failed to resolve messaging key of address ${address}`, {
          cause: e
        })
      };
    }
  }
  async getAddressMessagingKeyStatus(address, at) {
    try {
      const atDate = at ? Math.round(at.getTime() / 1e3) : void 0;
      const { data } = await this.addressApi.getAddressMessagingKeyStatus(address, atDate);
      return { data: data.status };
    } catch (e) {
      return {
        error: new IdentityProviderUnsupportedError()
      };
    }
  }
};

export {
  ResoleAddressesFailuresError,
  MessagingKeys
};
