"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _chunkOO5CPMZPjs = require('./chunk-OO5CPMZP.js');


var _chunkQOTIAHF7js = require('./chunk-QOTIAHF7.js');

// src/mailbox/migrations.ts
var _crypto = require('@mailchain/crypto');
var _ed25519 = require('@mailchain/crypto/ed25519');
var _public = require('@mailchain/crypto/secp256k1/public');
var _addressing = require('@mailchain/addressing');

// src/protobuf/inbox/inbox.js
var _minimaljs = require('protobufjs/minimal.js'); var _minimaljs2 = _interopRequireDefault(_minimaljs);
var $Reader = _minimaljs2.default.Reader;
var $Writer = _minimaljs2.default.Writer;
var $util = _minimaljs2.default.util;
var $root = _minimaljs2.default.roots["default"] || (_minimaljs2.default.roots["default"] = {});
var preview = $root.preview = (() => {
  const preview2 = {};
  preview2.MessagePreview = function() {
    function MessagePreview(properties) {
      this.to = [];
      this.cc = [];
      this.bcc = [];
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    MessagePreview.prototype.from = "";
    MessagePreview.prototype.subject = "";
    MessagePreview.prototype.snippet = "";
    MessagePreview.prototype.hasAttachment = false;
    MessagePreview.prototype.timestamp = 0;
    MessagePreview.prototype.to = $util.emptyArray;
    MessagePreview.prototype.cc = $util.emptyArray;
    MessagePreview.prototype.bcc = $util.emptyArray;
    MessagePreview.prototype.owner = "";
    MessagePreview.prototype.mailbox = $util.newBuffer([]);
    MessagePreview.create = function create(properties) {
      return new MessagePreview(properties);
    };
    MessagePreview.encode = function encode(message, writer) {
      if (!writer)
        writer = $Writer.create();
      if (message.from != null && Object.hasOwnProperty.call(message, "from"))
        writer.uint32(
          /* id 1, wireType 2 =*/
          10
        ).string(message.from);
      if (message.subject != null && Object.hasOwnProperty.call(message, "subject"))
        writer.uint32(
          /* id 2, wireType 2 =*/
          18
        ).string(message.subject);
      if (message.snippet != null && Object.hasOwnProperty.call(message, "snippet"))
        writer.uint32(
          /* id 3, wireType 2 =*/
          26
        ).string(message.snippet);
      if (message.hasAttachment != null && Object.hasOwnProperty.call(message, "hasAttachment"))
        writer.uint32(
          /* id 4, wireType 0 =*/
          32
        ).bool(message.hasAttachment);
      if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
        writer.uint32(
          /* id 5, wireType 0 =*/
          40
        ).int32(message.timestamp);
      if (message.to != null && message.to.length)
        for (let i = 0; i < message.to.length; ++i)
          writer.uint32(
            /* id 6, wireType 2 =*/
            50
          ).string(message.to[i]);
      if (message.cc != null && message.cc.length)
        for (let i = 0; i < message.cc.length; ++i)
          writer.uint32(
            /* id 7, wireType 2 =*/
            58
          ).string(message.cc[i]);
      if (message.bcc != null && message.bcc.length)
        for (let i = 0; i < message.bcc.length; ++i)
          writer.uint32(
            /* id 8, wireType 2 =*/
            66
          ).string(message.bcc[i]);
      if (message.owner != null && Object.hasOwnProperty.call(message, "owner"))
        writer.uint32(
          /* id 9, wireType 2 =*/
          74
        ).string(message.owner);
      if (message.mailbox != null && Object.hasOwnProperty.call(message, "mailbox"))
        writer.uint32(
          /* id 10, wireType 2 =*/
          82
        ).bytes(message.mailbox);
      return writer;
    };
    MessagePreview.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };
    MessagePreview.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader))
        reader = $Reader.create(reader);
      let end = length === void 0 ? reader.len : reader.pos + length, message = new $root.preview.MessagePreview();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            message.from = reader.string();
            break;
          }
          case 2: {
            message.subject = reader.string();
            break;
          }
          case 3: {
            message.snippet = reader.string();
            break;
          }
          case 4: {
            message.hasAttachment = reader.bool();
            break;
          }
          case 5: {
            message.timestamp = reader.int32();
            break;
          }
          case 6: {
            if (!(message.to && message.to.length))
              message.to = [];
            message.to.push(reader.string());
            break;
          }
          case 7: {
            if (!(message.cc && message.cc.length))
              message.cc = [];
            message.cc.push(reader.string());
            break;
          }
          case 8: {
            if (!(message.bcc && message.bcc.length))
              message.bcc = [];
            message.bcc.push(reader.string());
            break;
          }
          case 9: {
            message.owner = reader.string();
            break;
          }
          case 10: {
            message.mailbox = reader.bytes();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    MessagePreview.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader))
        reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };
    MessagePreview.verify = function verify(message) {
      if (typeof message !== "object" || message === null)
        return "object expected";
      if (message.from != null && message.hasOwnProperty("from")) {
        if (!$util.isString(message.from))
          return "from: string expected";
      }
      if (message.subject != null && message.hasOwnProperty("subject")) {
        if (!$util.isString(message.subject))
          return "subject: string expected";
      }
      if (message.snippet != null && message.hasOwnProperty("snippet")) {
        if (!$util.isString(message.snippet))
          return "snippet: string expected";
      }
      if (message.hasAttachment != null && message.hasOwnProperty("hasAttachment")) {
        if (typeof message.hasAttachment !== "boolean")
          return "hasAttachment: boolean expected";
      }
      if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
        if (!$util.isInteger(message.timestamp))
          return "timestamp: integer expected";
      }
      if (message.to != null && message.hasOwnProperty("to")) {
        if (!Array.isArray(message.to))
          return "to: array expected";
        for (let i = 0; i < message.to.length; ++i)
          if (!$util.isString(message.to[i]))
            return "to: string[] expected";
      }
      if (message.cc != null && message.hasOwnProperty("cc")) {
        if (!Array.isArray(message.cc))
          return "cc: array expected";
        for (let i = 0; i < message.cc.length; ++i)
          if (!$util.isString(message.cc[i]))
            return "cc: string[] expected";
      }
      if (message.bcc != null && message.hasOwnProperty("bcc")) {
        if (!Array.isArray(message.bcc))
          return "bcc: array expected";
        for (let i = 0; i < message.bcc.length; ++i)
          if (!$util.isString(message.bcc[i]))
            return "bcc: string[] expected";
      }
      if (message.owner != null && message.hasOwnProperty("owner")) {
        if (!$util.isString(message.owner))
          return "owner: string expected";
      }
      if (message.mailbox != null && message.hasOwnProperty("mailbox")) {
        if (!(message.mailbox && typeof message.mailbox.length === "number" || $util.isString(message.mailbox)))
          return "mailbox: buffer expected";
      }
      return null;
    };
    MessagePreview.fromObject = function fromObject(object) {
      if (object instanceof $root.preview.MessagePreview)
        return object;
      let message = new $root.preview.MessagePreview();
      if (object.from != null)
        message.from = String(object.from);
      if (object.subject != null)
        message.subject = String(object.subject);
      if (object.snippet != null)
        message.snippet = String(object.snippet);
      if (object.hasAttachment != null)
        message.hasAttachment = Boolean(object.hasAttachment);
      if (object.timestamp != null)
        message.timestamp = object.timestamp | 0;
      if (object.to) {
        if (!Array.isArray(object.to))
          throw TypeError(".preview.MessagePreview.to: array expected");
        message.to = [];
        for (let i = 0; i < object.to.length; ++i)
          message.to[i] = String(object.to[i]);
      }
      if (object.cc) {
        if (!Array.isArray(object.cc))
          throw TypeError(".preview.MessagePreview.cc: array expected");
        message.cc = [];
        for (let i = 0; i < object.cc.length; ++i)
          message.cc[i] = String(object.cc[i]);
      }
      if (object.bcc) {
        if (!Array.isArray(object.bcc))
          throw TypeError(".preview.MessagePreview.bcc: array expected");
        message.bcc = [];
        for (let i = 0; i < object.bcc.length; ++i)
          message.bcc[i] = String(object.bcc[i]);
      }
      if (object.owner != null)
        message.owner = String(object.owner);
      if (object.mailbox != null) {
        if (typeof object.mailbox === "string")
          $util.base64.decode(object.mailbox, message.mailbox = $util.newBuffer($util.base64.length(object.mailbox)), 0);
        else if (object.mailbox.length >= 0)
          message.mailbox = object.mailbox;
      }
      return message;
    };
    MessagePreview.toObject = function toObject(message, options) {
      if (!options)
        options = {};
      let object = {};
      if (options.arrays || options.defaults) {
        object.to = [];
        object.cc = [];
        object.bcc = [];
      }
      if (options.defaults) {
        object.from = "";
        object.subject = "";
        object.snippet = "";
        object.hasAttachment = false;
        object.timestamp = 0;
        object.owner = "";
        if (options.bytes === String)
          object.mailbox = "";
        else {
          object.mailbox = [];
          if (options.bytes !== Array)
            object.mailbox = $util.newBuffer(object.mailbox);
        }
      }
      if (message.from != null && message.hasOwnProperty("from"))
        object.from = message.from;
      if (message.subject != null && message.hasOwnProperty("subject"))
        object.subject = message.subject;
      if (message.snippet != null && message.hasOwnProperty("snippet"))
        object.snippet = message.snippet;
      if (message.hasAttachment != null && message.hasOwnProperty("hasAttachment"))
        object.hasAttachment = message.hasAttachment;
      if (message.timestamp != null && message.hasOwnProperty("timestamp"))
        object.timestamp = message.timestamp;
      if (message.to && message.to.length) {
        object.to = [];
        for (let j = 0; j < message.to.length; ++j)
          object.to[j] = message.to[j];
      }
      if (message.cc && message.cc.length) {
        object.cc = [];
        for (let j = 0; j < message.cc.length; ++j)
          object.cc[j] = message.cc[j];
      }
      if (message.bcc && message.bcc.length) {
        object.bcc = [];
        for (let j = 0; j < message.bcc.length; ++j)
          object.bcc[j] = message.bcc[j];
      }
      if (message.owner != null && message.hasOwnProperty("owner"))
        object.owner = message.owner;
      if (message.mailbox != null && message.hasOwnProperty("mailbox"))
        object.mailbox = options.bytes === String ? $util.base64.encode(message.mailbox, 0, message.mailbox.length) : options.bytes === Array ? Array.prototype.slice.call(message.mailbox) : message.mailbox;
      return object;
    };
    MessagePreview.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, _minimaljs2.default.util.toJSONOptions);
    };
    MessagePreview.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/preview.MessagePreview";
    };
    return MessagePreview;
  }();
  return preview2;
})();

// src/mailbox/migrations.ts
function getAllMessagePreviewMigrations(sdkConfig) {
  const identityKeys = _chunkQOTIAHF7js.IdentityKeys.create(sdkConfig);
  return _chunkOO5CPMZPjs.combineMigrations.call(void 0, createV2IdentityKey(identityKeys), createV3EncodeIdentityKey());
}
function createV2IdentityKey(identityKeys) {
  return {
    shouldApply: (data) => Promise.resolve(data.version === 1),
    apply: async (data) => {
      const result = await identityKeys.getAddressIdentityKey(_addressing.parseNameServiceAddress.call(void 0, data.messagePreview.owner));
      if (result == null)
        throw new Error(`no identity key found for [${data.messagePreview.owner}], failed message migration`);
      return {
        version: 2,
        messagePreview: preview.MessagePreview.create({
          ...data.messagePreview,
          mailbox: result.identityKey.bytes
        })
      };
    }
  };
}
function createV3EncodeIdentityKey() {
  return {
    shouldApply: (data) => Promise.resolve(data.version === 2),
    apply: async (data) => {
      const { messagePreview } = data;
      const owner = _addressing.parseNameServiceAddress.call(void 0, messagePreview.owner);
      let mailboxIdentityKey = null;
      if (messagePreview.mailbox.length === _ed25519.ED25519PublicKeyLen && _addressing.isMailchainAccountAddress.call(void 0, owner)) {
        mailboxIdentityKey = new (0, _ed25519.ED25519PublicKey)(messagePreview.mailbox);
      } else if (messagePreview.mailbox.length === _public.SECP256K1PublicKeyLength) {
        mailboxIdentityKey = new (0, _public.SECP256K1PublicKey)(messagePreview.mailbox);
      }
      if (mailboxIdentityKey == null)
        throw new Error(`failed message migration, failed mailbox identity key resolution`);
      return {
        version: 3,
        messagePreview: preview.MessagePreview.create({
          ...messagePreview,
          mailbox: _crypto.publicKeyToBytes.call(void 0, mailboxIdentityKey)
        })
      };
    }
  };
}






exports.preview = preview; exports.getAllMessagePreviewMigrations = getAllMessagePreviewMigrations; exports.createV2IdentityKey = createV2IdentityKey; exports.createV3EncodeIdentityKey = createV3EncodeIdentityKey;
