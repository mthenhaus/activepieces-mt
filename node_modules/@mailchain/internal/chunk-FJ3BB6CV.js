"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _chunkBQQXYBRHjs = require('./chunk-BQQXYBRH.js');


var _chunkAR4N7KS5js = require('./chunk-AR4N7KS5.js');


var _chunkGDYJBQYGjs = require('./chunk-GDYJBQYG.js');


var _chunkRH2527U6js = require('./chunk-RH2527U6.js');

// src/messagingKeys/addressNonce.ts








var _addressing = require('@mailchain/addressing');
var _axios = require('axios'); var _axios2 = _interopRequireDefault(_axios);
var _api = require('@mailchain/api');
var AddressNonce = class {
  constructor(messagingKeysApi, resolvers) {
    this.messagingKeysApi = messagingKeysApi;
    this.resolvers = resolvers;
  }
  static create(configuration, axiosInstance = _axios2.default.create()) {
    const mailchainKeyRegistryResolver = _chunkBQQXYBRHjs.MailchainKeyRegContractCallResolver.create(configuration, axiosInstance);
    return new AddressNonce(
      _api.MessagingKeysApiFactory.call(void 0, _api.createAxiosConfiguration.call(void 0, configuration.apiPath)),
      /* @__PURE__ */ new Map([
        [_addressing.NEAR, _chunkAR4N7KS5js.NearContractCallResolver.create(configuration, axiosInstance)],
        [_addressing.ETHEREUM, mailchainKeyRegistryResolver],
        [_addressing.TEZOS, mailchainKeyRegistryResolver],
        [_addressing.SOLANA, mailchainKeyRegistryResolver]
      ])
    );
  }
  /**
   * Get the latest nonce for an address.
   *
   * @param address the protocol get the latest nonce for.
   * @param protocol where to find the address.
   * @returns The latest nonce for the given address.
   */
  async getMessagingKeyLatestNonce(address, protocol) {
    if (protocol === _addressing.MAILCHAIN) {
      return { data: 1 };
    }
    const resolver = this.resolvers.get(protocol);
    if (!resolver) {
      return { error: new (0, _addressing.ProtocolNotSupportedError)(protocol) };
    }
    if (!_addressing.isBlockchainProtocolEnabled.call(void 0, protocol)) {
      return { error: new (0, _addressing.ProtocolNotSupportedError)(protocol) };
    }
    const nonceContractResponse = await this.messagingKeysApi.getProtocolAddressNonce(address, protocol);
    try {
      const nonce = await resolver.latestNonce(nonceContractResponse.data.contractCall);
      return {
        data: nonce
      };
    } catch (error) {
      if (error instanceof _chunkGDYJBQYGjs.MessagingKeyNotFoundInContractError) {
        return {
          data: 0
        };
      }
      return {
        error: new (0, _chunkRH2527U6js.UnexpectedMailchainError)("Failed to get latest nonce.", { cause: error })
      };
    }
  }
};



exports.AddressNonce = AddressNonce;
