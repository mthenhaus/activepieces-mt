// src/transport/serialization/decrypt.ts
import { PrivateKeyDecrypter, deriveHardenedKey } from "@mailchain/crypto";
async function decryptPayload(input, payloadRootKey) {
  const decryptedContentChunks = await decryptChunks(input.EncryptedContentChunks, payloadRootKey);
  const headersEncryptionKey = deriveHardenedKey(payloadRootKey, "headers");
  const decryptedHeaders = await decryptBuffer(input.EncryptedHeaders, headersEncryptionKey.privateKey);
  return {
    headers: decryptedHeaders,
    content: Buffer.concat(decryptedContentChunks)
  };
}
async function decryptChunks(chunks, payloadRootKey) {
  const decryptedChunks = new Array(chunks.length);
  const contentRootKey = deriveHardenedKey(payloadRootKey, "content");
  for (let i = 0; i < chunks.length; i++) {
    const chunkKey = deriveHardenedKey(contentRootKey, i);
    decryptedChunks[i] = await decryptBuffer(chunks[i], chunkKey.privateKey);
  }
  return decryptedChunks;
}
async function decryptBuffer(buffer, key) {
  if (buffer.length === 0) {
    throw new Error("can not decrypt empty data");
  }
  const decrypted = await PrivateKeyDecrypter.fromPrivateKey(key).decrypt(buffer);
  return Buffer.from(decrypted);
}

export {
  decryptPayload,
  decryptChunks,
  decryptBuffer
};
