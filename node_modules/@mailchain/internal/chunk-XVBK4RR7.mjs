import {
  serializeAndEncryptPayload
} from "./chunk-SK3RGOCQ.mjs";

// src/sending/payload/store.ts
import { ED25519ExtendedPrivateKey, ED25519PrivateKey } from "@mailchain/crypto";
import {
  TransportApiFactory,
  getAxiosWithSigner,
  createAxiosConfiguration
} from "@mailchain/api";
var StorePayloadError = class extends Error {
  constructor(cause) {
    super("Payload could not be stored.", { cause });
  }
};
var PayloadStorer = class {
  constructor(transportApi) {
    this.transportApi = transportApi;
  }
  static create(configuration, accountKeySigner) {
    return new PayloadStorer(
      TransportApiFactory(
        createAxiosConfiguration(configuration.apiPath),
        void 0,
        getAxiosWithSigner(accountKeySigner)
      )
    );
  }
  /**
   * Encrypt the payload with ephemeral key and deliver it to the storage nodes.
   * @returns the URL to get the message from the and ephemeral key used for the encryption of it
   */
  async storePayload(payload) {
    try {
      const payloadRootEncryptionKey = ED25519ExtendedPrivateKey.fromPrivateKey(ED25519PrivateKey.generate());
      const serializedContent = await serializeAndEncryptPayload(payload, payloadRootEncryptionKey);
      const { uri: payloadUri } = await this.transportApi.postEncryptedPayload(serializedContent).then((r) => r.data);
      return {
        data: {
          payloadUri,
          payloadRootEncryptionKey
        }
      };
    } catch (error) {
      return {
        error: new StorePayloadError(error)
      };
    }
  }
};

export {
  StorePayloadError,
  PayloadStorer
};
