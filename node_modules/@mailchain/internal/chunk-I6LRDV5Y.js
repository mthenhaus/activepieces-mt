"use strict";Object.defineProperty(exports, "__esModule", {value: true});


var _chunkVPET7X4Njs = require('./chunk-VPET7X4N.js');

// src/transport/serialization/encrypt.ts




var _crypto = require('@mailchain/crypto');
async function encryptPayload(headers, content, payloadRootKey, chunkSize = _chunkVPET7X4Njs.CHUNK_LENGTH_1MB, rand = _crypto.secureRandom) {
  const chunks = _chunkVPET7X4Njs.chunkBuffer.call(void 0, content, chunkSize);
  const encryptedContentChunks = await encryptChunks(chunks, payloadRootKey, rand);
  const headersEncryptionKey = _crypto.deriveHardenedKey.call(void 0, payloadRootKey, "headers");
  const encryptedHeaders = await encryptBuffer(headers, headersEncryptionKey.privateKey, rand);
  return {
    EncryptedHeaders: encryptedHeaders,
    EncryptedContentChunks: encryptedContentChunks
  };
}
async function encryptChunks(chunks, payloadRootKey, rand = _crypto.secureRandom) {
  const encryptedChunks = new Array(chunks.length);
  const contentRootKey = _crypto.deriveHardenedKey.call(void 0, payloadRootKey, "content");
  for (let i = 0; i < chunks.length; i++) {
    const chunkKey = _crypto.deriveHardenedKey.call(void 0, contentRootKey, i);
    encryptedChunks[i] = await encryptBuffer(chunks[i], chunkKey.privateKey, rand);
  }
  return encryptedChunks;
}
async function encryptBuffer(buffer, key, rand = _crypto.secureRandom) {
  const encrypted = await _crypto.PrivateKeyEncrypter.fromPrivateKey(key, rand).encrypt(buffer);
  return Buffer.from(encrypted);
}





exports.encryptPayload = encryptPayload; exports.encryptChunks = encryptChunks; exports.encryptBuffer = encryptBuffer;
