import {
  MailchainKeyRegContractCallResolver
} from "./chunk-VRCX4BTH.mjs";
import {
  MessagingKeyVerifier
} from "./chunk-GFHS4OJJ.mjs";
import {
  NearContractCallResolver
} from "./chunk-VHRK63OY.mjs";
import {
  InvalidContractResponseError,
  MessagingKeyNotFoundInContractError
} from "./chunk-TACI5AZH.mjs";
import {
  MessagingKeyContactError
} from "./chunk-E5ONHO3D.mjs";
import {
  UnexpectedMailchainError
} from "./chunk-QQZCHFKV.mjs";

// src/messagingKeys/messagingKeyContract.ts
import {
  createAxiosConfiguration,
  MessagingKeysApiFactory
} from "@mailchain/api";
import axios from "axios";
import { ETHEREUM, NEAR, TEZOS } from "@mailchain/addressing";
import { convertPublic } from "@mailchain/api/helpers/apiKeyToCryptoKey";
import { MessagingKeyVerificationError } from "@mailchain/signatures";
import { MAILCHAIN, ProtocolNotSupportedError, SOLANA } from "@mailchain/addressing/protocols";
var MessagingKeyContractCall = class {
  constructor(resolvers, messagingKeysApi, messagingKeyVerifier) {
    this.resolvers = resolvers;
    this.messagingKeysApi = messagingKeysApi;
    this.messagingKeyVerifier = messagingKeyVerifier;
  }
  static create(configuration, axiosInstance = axios.create()) {
    const mailchainKeyRegistryResolver = MailchainKeyRegContractCallResolver.create(configuration, axiosInstance);
    return new MessagingKeyContractCall(
      /* @__PURE__ */ new Map([
        [ETHEREUM, mailchainKeyRegistryResolver],
        [MAILCHAIN, mailchainKeyRegistryResolver],
        [NEAR, NearContractCallResolver.create(configuration, axiosInstance)],
        [TEZOS, mailchainKeyRegistryResolver],
        [SOLANA, mailchainKeyRegistryResolver]
      ]),
      MessagingKeysApiFactory(createAxiosConfiguration(configuration.apiPath)),
      MessagingKeyVerifier.create(configuration)
    );
  }
  async resolve(contractCall, identityKey) {
    const protocol = contractCall.protocol;
    const resolver = this.resolvers.get(protocol);
    if (!resolver) {
      return { error: new ProtocolNotSupportedError(protocol) };
    }
    const { data, error } = await resolver.resolve(contractCall);
    if (error instanceof MessagingKeyNotFoundInContractError) {
      return this.getVerifiedVendedPublicMessagingKey(contractCall.address, protocol, identityKey);
    } else if (error instanceof InvalidContractResponseError) {
      return { error: new MessagingKeyContactError(error) };
    } else if (error) {
      return {
        error: new MessagingKeyContactError(error)
      };
    }
    if (!identityKey) {
      return {
        error: new UnexpectedMailchainError("identityKey is required")
      };
    }
    const { messagingKey, proof } = data;
    return {
      data: {
        type: "registered",
        messagingKey,
        identityKey,
        protocol,
        protocolAddress: contractCall.address,
        proof
      }
    };
  }
  async getVerifiedVendedPublicMessagingKey(address, protocol, identityKey) {
    const vendedKeyResponse = await this.messagingKeysApi.getVendedPublicMessagingKey(address, protocol);
    const verified = await this.messagingKeyVerifier.verifyProvidedKeyProof(
      vendedKeyResponse.data.proof,
      convertPublic(vendedKeyResponse.data.messagingKey)
    );
    if (!verified) {
      return { error: new MessagingKeyVerificationError() };
    }
    return {
      data: {
        messagingKey: convertPublic(vendedKeyResponse.data.messagingKey),
        identityKey,
        protocol,
        type: "vended",
        protocolAddress: address
      }
    };
  }
};

export {
  MessagingKeyContractCall
};
