"use strict";Object.defineProperty(exports, "__esModule", {value: true});


var _chunkO267RXGSjs = require('./chunk-O267RXGS.js');


var _chunkESCCOX3Vjs = require('./chunk-ESCCOX3V.js');


var _chunkZKQAO77Pjs = require('./chunk-ZKQAO77P.js');

// src/verifiableCredentials/resolver.ts
var _encoding = require('@mailchain/encoding');
var MailchainDIDMessagingKeyResolver = class {
  constructor(messagingKeys) {
    this.messagingKeys = messagingKeys;
  }
  static create(configuration = _chunkZKQAO77Pjs.defaultConfiguration) {
    return new MailchainDIDMessagingKeyResolver(_chunkESCCOX3Vjs.MessagingKeys.create(configuration));
  }
  async resolve(didUrl, _options) {
    if (!_chunkO267RXGSjs.isMailchainAddressDecentralizedIdentifier.call(void 0, didUrl))
      throw new Error(`Not a Mailchain Address DID: ${didUrl}`);
    const address = _chunkO267RXGSjs.mailchainAddressFromDecentralizedIdentifier.call(void 0, didUrl);
    const { data: resolvedAddress, error: resolveAddressError } = await this.messagingKeys.resolve(address);
    if (resolveAddressError) {
      throw resolveAddressError;
    }
    return createDidDocumentFromResolvedAddress(didUrl, resolvedAddress);
  }
};
function createDidDocumentFromResolvedAddress(didUrl, resolvedAddress) {
  return {
    didDocument: {
      id: didUrl,
      authentication: [
        {
          id: `${didUrl}/messaging-key`,
          controller: didUrl,
          type: "ED25519SignatureVerification",
          publicKeyHex: `${_encoding.encodeHex.call(void 0, resolvedAddress.messagingKey.bytes)}`
        }
      ],
      verificationMethod: []
      // no verification methods
    },
    didDocumentMetadata: {
      canonicalId: didUrl
    },
    didResolutionMetadata: {
      contentType: "application/did+ld+json"
    }
  };
}




exports.MailchainDIDMessagingKeyResolver = MailchainDIDMessagingKeyResolver; exports.createDidDocumentFromResolvedAddress = createDidDocumentFromResolvedAddress;
