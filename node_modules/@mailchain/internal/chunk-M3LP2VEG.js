"use strict";Object.defineProperty(exports, "__esModule", {value: true});

var _chunkQINX4ZX7js = require('./chunk-QINX4ZX7.js');


var _chunkZVDRRVVRjs = require('./chunk-ZVDRRVVR.js');


var _chunkZKQAO77Pjs = require('./chunk-ZKQAO77P.js');


var _chunkTCLRDJ3Gjs = require('./chunk-TCLRDJ3G.js');

// src/verifiableCredentials/verifiableMailchainAddressOwner/factory.ts
var _addressing = require('@mailchain/addressing');
var VerifiableMailchainAddressOwnerCreator = class {
  constructor(signer, mailchainAddressOwnershipIssuer, mailchainAddressDomain) {
    this.signer = signer;
    this.mailchainAddressOwnershipIssuer = mailchainAddressOwnershipIssuer;
    this.mailchainAddressDomain = mailchainAddressDomain;
  }
  static create(signer, configuration = _chunkZKQAO77Pjs.defaultConfiguration) {
    return new VerifiableMailchainAddressOwnerCreator(
      signer,
      _chunkQINX4ZX7js.MailchainAddressOwnershipIssuer.create(configuration),
      configuration.mailchainAddressDomain
    );
  }
  /**
   * Creates a verifiable presentation JWT for a mailchain address owner.
   * @param request - The verifiable presentation request containing the necessary information to create the JWT.
   * @returns A promise that resolves to a MailchainResult containing either the verifiable presentation JWT or an error.
   */
  async createVerifiableMailchainAddressOwner(request) {
    const validationError = validateVerifiablePresentationRequest(request, this.mailchainAddressDomain);
    if (validationError) {
      return {
        error: validationError
      };
    }
    const {
      requestId,
      from,
      to,
      actions,
      resources,
      signedCredentialExpiresAfter,
      signedCredentialExpiresAt,
      nonce
    } = request;
    return this.mailchainAddressOwnershipIssuer.createVerifiableMailchainAddressOwnership({
      address: to,
      requester: from,
      actions,
      resources,
      signer: this.signer,
      options: {
        requestId,
        expiresAt: signedCredentialExpiresAt,
        expiresIn: signedCredentialExpiresAfter,
        nonce
      }
    });
  }
};
function validateVerifiablePresentationRequest(request, mailchainAddressDomain) {
  const {
    from: requestFrom,
    to: requestTo,
    actions,
    requestExpiresAfter,
    signedCredentialExpiresAt,
    signedCredentialExpiresAfter
  } = request;
  if (_chunkZVDRRVVRjs.CredentialPayloadTypes.indexOf(request.type) === -1) {
    return new (0, _chunkTCLRDJ3Gjs.ValidationError)(`invalid type ${request.type}`);
  }
  if (request.version !== "1.0") {
    return new (0, _chunkTCLRDJ3Gjs.ValidationError)(`invalid version ${request.version}`);
  }
  if (request.requestId == null || request.requestId.length === 0) {
    throw new (0, _chunkTCLRDJ3Gjs.ValidationError)("requestId is empty");
  }
  if (requestExpiresAfter && signedCredentialExpiresAt && requestExpiresAfter > signedCredentialExpiresAt) {
    return new (0, _chunkTCLRDJ3Gjs.ValidationError)("requestExpiresAfter must be before signedCredentialExpiresAt");
  }
  if (requestExpiresAfter instanceof Date && /* @__PURE__ */ new Date() > requestExpiresAfter) {
    return new (0, _chunkTCLRDJ3Gjs.ValidationError)("request has expired");
  }
  if (signedCredentialExpiresAt && signedCredentialExpiresAt < /* @__PURE__ */ new Date()) {
    return new (0, _chunkTCLRDJ3Gjs.ValidationError)("signed credential has expired");
  }
  if (signedCredentialExpiresAfter && signedCredentialExpiresAfter < 0) {
    return new (0, _chunkTCLRDJ3Gjs.ValidationError)("signed credential signedCredentialExpiresAfter must be greater than 0");
  }
  if (actions.length === 0) {
    return new (0, _chunkTCLRDJ3Gjs.ValidationError)("actions is empty");
  }
  if (request.resources.length === 0) {
    return new (0, _chunkTCLRDJ3Gjs.ValidationError)("resources is empty");
  }
  const fromAddressError = _addressing.checkAddressForErrors.call(void 0, requestFrom, mailchainAddressDomain);
  if (fromAddressError) {
    return fromAddressError;
  }
  const toAddressError = _addressing.checkAddressForErrors.call(void 0, requestTo, mailchainAddressDomain);
  if (toAddressError) {
    return toAddressError;
  }
  if (request.approvedCallback.url.trim() === "") {
    return new (0, _chunkTCLRDJ3Gjs.ValidationError)("approvedCallback.url is empty");
  }
  return void 0;
}




exports.VerifiableMailchainAddressOwnerCreator = VerifiableMailchainAddressOwnerCreator; exports.validateVerifiablePresentationRequest = validateVerifiablePresentationRequest;
