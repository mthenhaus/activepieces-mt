import {
  protocol
} from "./chunk-4IWBVVDK.mjs";

// src/receiving/deliveryRequests/deliveryRequests.ts
import {
  createAxiosConfiguration,
  getAxiosWithSigner,
  TransportApiFactory
} from "@mailchain/api";
import { privateKeyFromBytes, publicKeyFromBytes, ED25519ExtendedPrivateKey } from "@mailchain/crypto";
import { decodeBase64, decodeHexZeroX, encodeHexZeroX, encodeUtf8 } from "@mailchain/encoding";
import { signMailchainDeliveryConfirmation } from "@mailchain/signatures";
var DeliveryRequests = class {
  constructor(transportApi, messagingKey) {
    this.transportApi = transportApi;
    this.messagingKey = messagingKey;
  }
  static create(configuration, receiverMessagingKeyDecrypter) {
    return new DeliveryRequests(
      TransportApiFactory(
        createAxiosConfiguration(configuration.apiPath),
        void 0,
        getAxiosWithSigner(receiverMessagingKeyDecrypter)
      ),
      receiverMessagingKeyDecrypter
    );
  }
  async confirmDelivery(hash) {
    const signature = await signMailchainDeliveryConfirmation(this.messagingKey, hash);
    await this.transportApi.putDeliveryRequestConfirmation(encodeHexZeroX(hash), {
      signature: encodeHexZeroX(signature)
    });
  }
  async getUndelivered() {
    const processed = this.transportApi.getDeliveryRequests().then(({ data: { deliveryRequests } }) => {
      return Promise.all(
        deliveryRequests.map((dr) => {
          const delivery = protocol.Delivery.decode(decodeBase64(dr.data));
          return this.processDeliveryRequest(this.messagingKey, delivery, decodeHexZeroX(dr.hash));
        })
      );
    });
    return processed;
  }
  async processDeliveryRequest(messagingKey, delivery, deliveryRequestHash) {
    try {
      const { envelope } = delivery;
      if (!envelope) {
        throw new Error("envelope is undefined");
      }
      const { ecdhKeyBundle, encryptedMessageKey, encryptedMessageUri } = envelope;
      if (!ecdhKeyBundle) {
        throw new Error("envelope does not contain ECDH key bundle");
      }
      if (!encryptedMessageKey) {
        throw new Error("envelope does not contain encryptedMessageKey");
      }
      if (!encryptedMessageUri) {
        throw new Error("envelope does not contain encryptedMessageUri");
      }
      if (!ecdhKeyBundle.publicEphemeralKey) {
        throw new Error("ECDH key bundle does not contain publicEphemeralKey");
      }
      const payloadRootEncryptionKeyBytes = await messagingKey.ecdhDecrypt(
        publicKeyFromBytes(ecdhKeyBundle.publicEphemeralKey),
        encryptedMessageKey
      );
      if (payloadRootEncryptionKeyBytes.length === 0) {
        throw new Error("payloadRootEncryptionKey is empty");
      }
      const payloadRootEncryptionKey = ED25519ExtendedPrivateKey.fromPrivateKey(
        privateKeyFromBytes(payloadRootEncryptionKeyBytes)
      );
      const payloadUriBytes = await messagingKey.ecdhDecrypt(
        publicKeyFromBytes(ecdhKeyBundle.publicEphemeralKey),
        encryptedMessageUri
      );
      if (payloadUriBytes.length === 0) {
        throw new Error("payloadUri is empty");
      }
      const payloadUri = encodeUtf8(payloadUriBytes);
      return {
        status: "success",
        payloadRootEncryptionKey,
        payloadUri,
        deliveryRequestHash
      };
    } catch (error) {
      return {
        status: "failure",
        cause: error,
        deliveryRequestHash
      };
    }
  }
};

export {
  DeliveryRequests
};
