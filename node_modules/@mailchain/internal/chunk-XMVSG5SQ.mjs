import {
  isMailchainAddressDecentralizedIdentifier,
  mailchainAddressFromDecentralizedIdentifier
} from "./chunk-MDSHIXSD.mjs";
import {
  MessagingKeys
} from "./chunk-NK6CIHSE.mjs";
import {
  defaultConfiguration
} from "./chunk-TT2KNKAH.mjs";

// src/verifiableCredentials/resolver.ts
import { encodeHex } from "@mailchain/encoding";
var MailchainDIDMessagingKeyResolver = class {
  constructor(messagingKeys) {
    this.messagingKeys = messagingKeys;
  }
  static create(configuration = defaultConfiguration) {
    return new MailchainDIDMessagingKeyResolver(MessagingKeys.create(configuration));
  }
  async resolve(didUrl, _options) {
    if (!isMailchainAddressDecentralizedIdentifier(didUrl))
      throw new Error(`Not a Mailchain Address DID: ${didUrl}`);
    const address = mailchainAddressFromDecentralizedIdentifier(didUrl);
    const { data: resolvedAddress, error: resolveAddressError } = await this.messagingKeys.resolve(address);
    if (resolveAddressError) {
      throw resolveAddressError;
    }
    return createDidDocumentFromResolvedAddress(didUrl, resolvedAddress);
  }
};
function createDidDocumentFromResolvedAddress(didUrl, resolvedAddress) {
  return {
    didDocument: {
      id: didUrl,
      authentication: [
        {
          id: `${didUrl}/messaging-key`,
          controller: didUrl,
          type: "ED25519SignatureVerification",
          publicKeyHex: `${encodeHex(resolvedAddress.messagingKey.bytes)}`
        }
      ],
      verificationMethod: []
      // no verification methods
    },
    didDocumentMetadata: {
      canonicalId: didUrl
    },
    didResolutionMetadata: {
      contentType: "application/did+ld+json"
    }
  };
}

export {
  MailchainDIDMessagingKeyResolver,
  createDidDocumentFromResolvedAddress
};
