"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _chunkA4QB2VPFjs = require('./chunk-A4QB2VPF.js');


var _chunkM6PQ6TNPjs = require('./chunk-M6PQ6TNP.js');


var _chunkWPXT6MG2js = require('./chunk-WPXT6MG2.js');


var _chunkHMHFMIANjs = require('./chunk-HMHFMIAN.js');

// src/receiving/mailer/mailer.ts
var _signatures = require('@mailchain/signatures');
var _axios = require('axios'); var _axios2 = _interopRequireDefault(_axios);
var _encoding = require('@mailchain/encoding');
var MailerContentResolver = class {
  constructor(axiosInstance, sender) {
    this.axiosInstance = axiosInstance;
    this.sender = sender;
  }
  static create(configuration, axiosInstance = _axios2.default.create()) {
    return new MailerContentResolver(axiosInstance, _chunkA4QB2VPFjs.MailerAuthorVerifier.create(configuration));
  }
  async get(payload) {
    if (!_chunkM6PQ6TNPjs.isMailerPayload.call(void 0, payload)) {
      throw new Error("invalid content type");
    }
    const mailerContent = _chunkWPXT6MG2js.parseMailerContentFromJSON.call(void 0, payload.Content.toString());
    if (!_signatures.verifyMailerProof.call(void 0, mailerContent.authorMessagingKey, mailerContent.mailerProof)) {
      throw new Error("invalid mailer proof");
    }
    const response = await this.axiosInstance.get(mailerContent.contentUri, {
      responseType: "arraybuffer"
    });
    const decodedData = _encoding.decodeBase64.call(void 0, response.data);
    if (!mailerContent.authorMessagingKey.verify(
      decodedData,
      mailerContent.mailerProof.params.authorContentSignature
    )) {
      throw new Error("invalid content signature");
    }
    const parsedMailerData = JSON.parse(_encoding.encodeUtf8.call(void 0, decodedData));
    const processedContent = await processContent(mailerContent, parsedMailerData);
    const utf8EncodedContent = _encoding.decodeUtf8.call(void 0, processedContent);
    const mailerPayload = {
      ...payload,
      Headers: { ...payload.Headers, MailerContent: mailerContent },
      Content: Buffer.from(utf8EncodedContent)
    };
    const senderOwnsFromAddress = await this.sender.verifyAuthorOwnsFromAddress(
      payload,
      Buffer.from(utf8EncodedContent)
    );
    if (!senderOwnsFromAddress) {
      throw new Error("sender does not match from address");
    }
    return mailerPayload;
  }
};
async function processContent(mailerContent, mailerData) {
  const { original } = await _chunkHMHFMIANjs.createMimeMessage.call(void 0, 
    {
      blindCarbonCopyRecipients: [],
      carbonCopyRecipients: [],
      date: mailerContent.date,
      from: mailerContent.authorMailAddress,
      id: mailerContent.messageId,
      message: mailerData.html,
      plainTextMessage: mailerData.plainTextMessage,
      recipients: mailerContent.to,
      subject: mailerData.subject,
      replyTo: mailerData.replyTo
    },
    /* @__PURE__ */ new Map()
  );
  return original;
}



exports.MailerContentResolver = MailerContentResolver;
