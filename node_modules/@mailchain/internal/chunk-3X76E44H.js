"use strict";Object.defineProperty(exports, "__esModule", {value: true});

var _chunkJVE2SYBQjs = require('./chunk-JVE2SYBQ.js');

// src/sending/payload/store.ts
var _crypto = require('@mailchain/crypto');




var _api = require('@mailchain/api');
var StorePayloadError = class extends Error {
  constructor(cause) {
    super("Payload could not be stored.", { cause });
  }
};
var PayloadStorer = class {
  constructor(transportApi) {
    this.transportApi = transportApi;
  }
  static create(configuration, accountKeySigner) {
    return new PayloadStorer(
      _api.TransportApiFactory.call(void 0, 
        _api.createAxiosConfiguration.call(void 0, configuration.apiPath),
        void 0,
        _api.getAxiosWithSigner.call(void 0, accountKeySigner)
      )
    );
  }
  /**
   * Encrypt the payload with ephemeral key and deliver it to the storage nodes.
   * @returns the URL to get the message from the and ephemeral key used for the encryption of it
   */
  async storePayload(payload) {
    try {
      const payloadRootEncryptionKey = _crypto.ED25519ExtendedPrivateKey.fromPrivateKey(_crypto.ED25519PrivateKey.generate());
      const serializedContent = await _chunkJVE2SYBQjs.serializeAndEncryptPayload.call(void 0, payload, payloadRootEncryptionKey);
      const { uri: payloadUri } = await this.transportApi.postEncryptedPayload(serializedContent).then((r) => r.data);
      return {
        data: {
          payloadUri,
          payloadRootEncryptionKey
        }
      };
    } catch (error) {
      return {
        error: new StorePayloadError(error)
      };
    }
  }
};




exports.StorePayloadError = StorePayloadError; exports.PayloadStorer = PayloadStorer;
