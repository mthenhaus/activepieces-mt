"use strict";Object.defineProperty(exports, "__esModule", {value: true});// src/transport/serialization/decrypt.ts
var _crypto = require('@mailchain/crypto');
async function decryptPayload(input, payloadRootKey) {
  const decryptedContentChunks = await decryptChunks(input.EncryptedContentChunks, payloadRootKey);
  const headersEncryptionKey = _crypto.deriveHardenedKey.call(void 0, payloadRootKey, "headers");
  const decryptedHeaders = await decryptBuffer(input.EncryptedHeaders, headersEncryptionKey.privateKey);
  return {
    headers: decryptedHeaders,
    content: Buffer.concat(decryptedContentChunks)
  };
}
async function decryptChunks(chunks, payloadRootKey) {
  const decryptedChunks = new Array(chunks.length);
  const contentRootKey = _crypto.deriveHardenedKey.call(void 0, payloadRootKey, "content");
  for (let i = 0; i < chunks.length; i++) {
    const chunkKey = _crypto.deriveHardenedKey.call(void 0, contentRootKey, i);
    decryptedChunks[i] = await decryptBuffer(chunks[i], chunkKey.privateKey);
  }
  return decryptedChunks;
}
async function decryptBuffer(buffer, key) {
  if (buffer.length === 0) {
    throw new Error("can not decrypt empty data");
  }
  const decrypted = await _crypto.PrivateKeyDecrypter.fromPrivateKey(key).decrypt(buffer);
  return Buffer.from(decrypted);
}





exports.decryptPayload = decryptPayload; exports.decryptChunks = decryptChunks; exports.decryptBuffer = decryptBuffer;
