import { ProtocolType, BadlyFormattedAddressError, ProtocolNotSupportedError, IdentityProviderAddressInvalidError } from '@mailchain/addressing';
import { PublicKey } from '@mailchain/crypto';
import { MessagingKeysApiInterface, ContractCall, AddressesApiInterface, IdentityKeysApiInterface } from '@mailchain/api';
import { MessagingKeyVerificationError } from '@mailchain/signatures';
import { Configuration } from './configuration.js';
import { MailchainResult } from './mailchainResult.js';
import { UnexpectedMailchainError } from './errors/unexpected.js';
import { IdentityExpiredError, IdentityNotFoundError, IdentityProviderUnsupportedError, IdentityProviderAddressUnsupportedError, MessagingKeyContactError } from './messagingKeys/errors.js';
import { Proof, MailchainRegistryMessagingKeyProof } from './messagingKeys/proof.js';
import { AxiosInstance } from 'axios';
import { ContractCallMessagingKeyResolver } from './messagingKeys/contractResolvers/resolver.js';
import { MessagingKeyVerifier } from './messagingKeys/verify.js';

type ContractCallResolvedAddress = Omit<RegisteredResolvedAddress, 'mailchainAddress'> | Omit<VendedResolvedAddress, 'mailchainAddress'>;
declare class MessagingKeyContractCall {
    private readonly resolvers;
    private readonly messagingKeysApi;
    private readonly messagingKeyVerifier;
    constructor(resolvers: Map<ProtocolType, ContractCallMessagingKeyResolver>, messagingKeysApi: MessagingKeysApiInterface, messagingKeyVerifier: MessagingKeyVerifier);
    static create(configuration: Configuration, axiosInstance?: AxiosInstance): MessagingKeyContractCall;
    resolve(contractCall: ContractCall, identityKey?: PublicKey): Promise<MailchainResult<ContractCallResolvedAddress, ResolveAddressError>>;
    private getVerifiedVendedPublicMessagingKey;
}

type BaseResolvedAddress = {
    mailchainAddress: string;
    /** Messaging key to be used when communicate with the resolved address. See {@link PublicKey} */
    messagingKey: PublicKey;
    /** Protocol of resolved address. Protocol is determined when resolving the address. */
    protocol: ProtocolType;
    /** Protocol address that has been resolved in the case of name services. */
    protocolAddress: string;
};
type AddressMessagingKeyStatus = 'vended' | 'registered';
type RegisteredResolvedAddress = BaseResolvedAddress & {
    /** Indicates the messaging key has been registered by a user. */
    type: 'registered';
    /** Identity key of resolved address. */
    identityKey: PublicKey;
    proof: Proof;
};
type VendedResolvedAddress = BaseResolvedAddress & {
    /** Indicates the messaging key has been vended by Mailchain. */
    type: 'vended';
    /** Identity key of resolved address. Identity key might be undefined in the case of `vended` messaging key. */
    identityKey?: PublicKey;
};
/**
 * Resolved address response containing a proven messaging key.
 */
type ResolvedAddress = RegisteredResolvedAddress | VendedResolvedAddress;
type ResolveAddressError = UnexpectedMailchainError | BadlyFormattedAddressError | IdentityExpiredError | IdentityNotFoundError | IdentityProviderUnsupportedError | IdentityProviderAddressUnsupportedError | MessagingKeyContactError | MessagingKeyVerificationError | ProtocolNotSupportedError | IdentityProviderAddressInvalidError;
type ResolveAddressResult = MailchainResult<ResolvedAddress, ResolveAddressError>;
type ResolvedManyAddresses = Map<string, ResolvedAddress>;
type ResolvedManyAddressesResult = MailchainResult<ResolvedManyAddresses>;
type ResolveManyAddressesError = ResoleAddressesFailuresError;
declare class ResoleAddressesFailuresError extends Error {
    readonly successes: Array<{
        params: string;
        data: ResolvedAddress;
    }>;
    readonly failures: Array<{
        params: string;
        error: ResolveAddressError;
    }>;
    readonly type = "resolve_addresses_failures";
    readonly docs = "https://docs.mailchain.com/developer/errors/codes#resolve_addresses_failures";
    constructor(successes: Array<{
        params: string;
        data: ResolvedAddress;
    }>, failures: Array<{
        params: string;
        error: ResolveAddressError;
    }>);
}
declare class MessagingKeys {
    private readonly addressApi;
    private readonly identityKeysApi;
    private readonly messagingKeyContractCall;
    private readonly mailchainAddressDomain;
    constructor(addressApi: AddressesApiInterface, identityKeysApi: IdentityKeysApiInterface, messagingKeyContractCall: MessagingKeyContractCall, mailchainAddressDomain: string);
    static create(configuration: Configuration): MessagingKeys;
    /**
     * Resolve the messaging key for the given address.
     *
     * @param address Address to resolve.
     * @param at Date to resolve the address at. When no date is provided, the address resolves using the latest block.
     *
     * @returns A {@link ResolvedAddress resolved address} which may be a registered or vended.
     *
     * @example
     * import { messagingKeys } from '@mailchain/sdk';
     *
     * const resolvedAddress = await messagingKeys.resolve(address);
     * console.log(resolvedAddress);
     *
     */
    resolve(address: string, at?: Date): Promise<ResolveAddressResult>;
    resolveMany(addresses: string[], at?: Date): Promise<MailchainResult<ResolvedManyAddresses, ResolveManyAddressesError>>;
    update(proof: Omit<MailchainRegistryMessagingKeyProof, 'source'>): Promise<void>;
    private getAddressMessagingKey;
    getAddressMessagingKeyStatus(address: string, at?: Date): Promise<MailchainResult<AddressMessagingKeyStatus, IdentityProviderUnsupportedError>>;
}

export { AddressMessagingKeyStatus as A, ContractCallResolvedAddress as C, MessagingKeys as M, ResolvedAddress as R, VendedResolvedAddress as V, ResoleAddressesFailuresError as a, RegisteredResolvedAddress as b, ResolveAddressError as c, ResolveAddressResult as d, ResolvedManyAddresses as e, ResolvedManyAddressesResult as f, ResolveManyAddressesError as g, MessagingKeyContractCall as h };
