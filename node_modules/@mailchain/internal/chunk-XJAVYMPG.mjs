import {
  validateVerifiablePresentationRequest
} from "./chunk-Y7TLODYJ.mjs";
import {
  MailerContentResolver
} from "./chunk-BCEC75ZX.mjs";
import {
  PayloadReceiver
} from "./chunk-WUI425KH.mjs";
import {
  DeliveryRequests
} from "./chunk-LEGM62UV.mjs";
import {
  parseVerifiablePresentationRequest
} from "./chunk-5DOTHQDR.mjs";

// src/receiving/mail/mail.ts
import axios from "axios";
import { encodeUtf8 } from "@mailchain/encoding";
var MailReceiver = class {
  constructor(deliveryRequests, mailerReceiver, payloadReceiver, mailchainAddressDomain) {
    this.deliveryRequests = deliveryRequests;
    this.mailerReceiver = mailerReceiver;
    this.payloadReceiver = payloadReceiver;
    this.mailchainAddressDomain = mailchainAddressDomain;
  }
  static create(configuration, receiverMessagingKeyDecrypter, axiosInstance = axios.create()) {
    return new MailReceiver(
      DeliveryRequests.create(configuration, receiverMessagingKeyDecrypter),
      MailerContentResolver.create(configuration, axiosInstance),
      PayloadReceiver.create(configuration, receiverMessagingKeyDecrypter, axiosInstance),
      configuration.mailchainAddressDomain
    );
  }
  /**
   * Confirm the delivery of a mail has been completed.
   * @param hash of the delivery request.
   */
  async confirmDelivery(deliveryRequestHash) {
    await this.deliveryRequests.confirmDelivery(deliveryRequestHash);
  }
  /**
   * Get all undelivered mail.
   * @returns the mail that has been received.
   */
  async getUndelivered() {
    const undeliveredPayloads = await this.payloadReceiver.getUndelivered();
    return Promise.all(
      undeliveredPayloads.map(async (undeliveredPayload) => {
        switch (undeliveredPayload.status) {
          case "success":
            return this.processReceivedPayload(undeliveredPayload);
          case "error-payload":
          case "error-delivery-request":
            return {
              status: "failure",
              cause: undeliveredPayload.cause
            };
          default:
            return {
              status: "failure",
              cause: new Error("failed processing received payload, unknown status")
            };
        }
      })
    );
  }
  async processReceivedPayload(undeliveredPayload) {
    try {
      return {
        status: "success",
        payload: await this.processReceivedPayloadData(undeliveredPayload.payload),
        deliveryRequestHash: undeliveredPayload.deliveryRequestHash
      };
    } catch (e) {
      return { status: "failure", cause: new Error("failed processing received payload", { cause: e }) };
    }
  }
  /**
   * creates the mail content from the payload.
   * @param payload the decrypted payload received from the network.
   * @returns
   */
  async processReceivedPayloadData(payload) {
    switch (payload.Headers.ContentType) {
      case "message/x.mailchain":
        return payload;
      case "message/x.mailchain-mailer":
        return await this.mailerReceiver.get(payload);
      case "application/vnd.mailchain.verified-credential-request":
        const validationError = validateVerifiablePresentationRequest(
          parseVerifiablePresentationRequest(encodeUtf8(payload.Content)),
          this.mailchainAddressDomain
        );
        if (validationError)
          throw new Error(`Invalid Verifiable Presentation Request`, { cause: validationError });
        return payload;
      default:
        throw new Error(`Unsupported content type: ${payload.Headers.ContentType}`);
    }
  }
};

export {
  MailReceiver
};
