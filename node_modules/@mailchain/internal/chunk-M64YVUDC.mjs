import {
  createPresentationPayload
} from "./chunk-FUM7OXH7.mjs";
import {
  createOwnerOfMessagingKeySubject
} from "./chunk-OHXA3Y74.mjs";
import {
  MailchainMessagingKeyIssuer
} from "./chunk-LY3AYJ4U.mjs";
import {
  createVerifiableCredential
} from "./chunk-UFSDCVPQ.mjs";
import {
  mailchainAddressDecentralizedIdentifier,
  mailchainBlockchainAddressDecentralizedIdentifier
} from "./chunk-MDSHIXSD.mjs";
import {
  MessagingKeys
} from "./chunk-NK6CIHSE.mjs";
import {
  AddressNotRegisteredError
} from "./chunk-E5ONHO3D.mjs";
import {
  defaultConfiguration
} from "./chunk-TT2KNKAH.mjs";

// src/verifiableCredentials/verifiableMailchainAddressOwner/issuer.ts
import { createVerifiablePresentationJwt } from "did-jwt-vc";
import { publicKeyToBytes } from "@mailchain/crypto";
import { encodeHex } from "@mailchain/encoding";
function createIssuerProof(resolvedAddress) {
  switch (resolvedAddress.proof.source) {
    case "MailchainRegistry":
      const { signature, address, messagingKey, identityKey, ...remainingProof } = resolvedAddress.proof;
      return {
        signatureHex: encodeHex(signature),
        addressHex: encodeHex(address),
        messagingKeyHex: encodeHex(publicKeyToBytes(messagingKey)),
        identityKeyHex: encodeHex(publicKeyToBytes(identityKey)),
        ...remainingProof,
        type: "Mailchain-Ed25519Signature2020"
      };
    case "ContractCall":
      return {
        ...resolvedAddress.proof,
        type: "Mailchain-Ed25519Signature2020"
      };
    default:
      throw new Error(`unknown proof source ${resolvedAddress.proof.source}`);
  }
}
function createCredentialPayloadMailchainAddressOwner(resolvedAddress, requester, issuanceDate, actions, resources) {
  return createVerifiableCredential({
    type: "MailchainMessagingKeyCredential",
    credentialSubjects: [createOwnerOfMessagingKeySubject(resolvedAddress.mailchainAddress)],
    issuanceDate,
    issuerId: mailchainBlockchainAddressDecentralizedIdentifier(
      resolvedAddress.protocol,
      resolvedAddress.protocolAddress
    ),
    proof: createIssuerProof(resolvedAddress),
    termsOfUse: [
      {
        type: "HolderPolicy",
        assigner: mailchainAddressDecentralizedIdentifier(resolvedAddress.mailchainAddress),
        effect: "Allow",
        assignee: requester,
        actions,
        resources
      }
    ]
  });
}
var MailchainAddressOwnershipIssuer = class {
  constructor(messagingKeys, mailchainMessagingKeyIssuer) {
    this.messagingKeys = messagingKeys;
    this.mailchainMessagingKeyIssuer = mailchainMessagingKeyIssuer;
  }
  static create(configuration = defaultConfiguration) {
    return new MailchainAddressOwnershipIssuer(
      MessagingKeys.create(configuration),
      new MailchainMessagingKeyIssuer()
    );
  }
  async createVerifiableMailchainAddressOwnership(params) {
    const { address, signer, requester, options, actions, resources } = params;
    const { data: resolvedAddress, error: resolveAddressError } = await this.messagingKeys.resolve(address);
    if (resolveAddressError) {
      return {
        error: resolveAddressError
      };
    }
    if (resolvedAddress.type !== "registered") {
      return {
        error: new AddressNotRegisteredError()
      };
    }
    const { requestId, expiresIn, expiresAt, nonce } = options;
    const issuanceDate = /* @__PURE__ */ new Date();
    const presentationPayload = createPresentationPayload({
      requestId,
      issuanceDate,
      verifiableCredential: createCredentialPayloadMailchainAddressOwner(
        resolvedAddress,
        mailchainAddressDecentralizedIdentifier(requester),
        issuanceDate,
        actions,
        resources
      ),
      holder: mailchainAddressDecentralizedIdentifier(resolvedAddress.mailchainAddress),
      verifier: mailchainAddressDecentralizedIdentifier(requester),
      expirationDate: resolveExpirationDate(issuanceDate, expiresAt, expiresIn)
    });
    const { data: issuer, error: createMailchainMessagingKeyIssuerError } = await this.mailchainMessagingKeyIssuer.createIssuerFromResolvedAddress({
      resolvedAddress,
      signer
    });
    if (createMailchainMessagingKeyIssuerError) {
      return {
        error: createMailchainMessagingKeyIssuerError
      };
    }
    const verifiablePresentation = await createVerifiablePresentationJwt(presentationPayload, issuer, {
      // challenge and domain are used to prevent replay attacks
      challenge: nonce,
      domain: mailchainAddressDecentralizedIdentifier(requester),
      canonicalize: true
    });
    return { data: verifiablePresentation };
  }
};
function resolveExpirationDate(issuanceDate, expiresAt, expiresIn) {
  if (expiresAt == null && expiresIn == null)
    return void 0;
  if (expiresIn == null)
    return expiresAt;
  const expiresInTimestamp = issuanceDate.getTime() + expiresIn * 1e3;
  if (expiresAt == null)
    return new Date(expiresInTimestamp);
  return new Date(Math.min(expiresInTimestamp, expiresAt.getTime()));
}

export {
  MailchainAddressOwnershipIssuer,
  resolveExpirationDate
};
