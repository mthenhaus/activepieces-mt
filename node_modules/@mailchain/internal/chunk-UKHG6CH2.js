"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } } function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }

var _chunkKC7PUVJGjs = require('./chunk-KC7PUVJG.js');


var _chunkEJN47EB6js = require('./chunk-EJN47EB6.js');

// src/formatters/parse.ts
var _addressing = require('@mailchain/addressing');
var _crypto = require('@mailchain/crypto');
var _encoding = require('@mailchain/encoding');
var _messagecomposer = require('@mailchain/message-composer');
function decodeNodeContent(node) {
  const [, rawContent] = node.raw.split("\n\n");
  let decodedContent = null;
  if (node.contentTransferEncoding) {
    switch (node.contentTransferEncoding.value.toLowerCase()) {
      case "base64":
        decodedContent = _encoding.decodeBase64.call(void 0, rawContent);
        break;
      case "7bit":
        try {
          return decodeURIComponent(rawContent);
        } catch (e) {
          return rawContent;
        }
      default:
        throw new Error(`unsupported content transfer encoding [${node.contentTransferEncoding.value}]`);
    }
  }
  if (decodedContent == null) {
    throw new Error("could not extract decodedContent from rawContent");
  }
  switch (_optionalChain([node, 'access', _ => _.contentType, 'optionalAccess', _2 => _2.params, 'optionalAccess', _3 => _3.charset, 'optionalAccess', _4 => _4.toUpperCase, 'call', _5 => _5()])) {
    case "UTF-8":
      return _encoding.encodeUtf8.call(void 0, decodedContent);
    case void 0:
      return decodedContent;
    default:
      throw new Error(`unsupported content charset [${_optionalChain([node, 'access', _6 => _6.contentType, 'optionalAccess', _7 => _7.params, 'optionalAccess', _8 => _8.charset])}]`);
  }
}
function extractContent(nodes) {
  const extracted = { messages: {}, attachments: [] };
  for (const node of nodes) {
    const { contentType, headers } = node;
    if (_optionalChain([contentType, 'optionalAccess', _9 => _9.value]) === "multipart/alternative") {
      const childContent = extractContent(node.childNodes);
      extracted.messages = { ...childContent.messages, ...extracted.messages };
      extracted.attachments = [...extracted.attachments, ...childContent.attachments];
    } else if (_optionalChain([contentType, 'optionalAccess', _10 => _10.value]) === "text/plain" || _optionalChain([contentType, 'optionalAccess', _11 => _11.value]) === "text/html") {
      const content = decodeNodeContent(node);
      if (typeof content !== "string")
        throw new Error("cannot process message content being non-string");
      extracted.messages = { ...extracted.messages, [contentType.value]: content };
    } else if (_optionalChain([headers, 'access', _12 => _12["content-disposition"], 'optionalAccess', _13 => _13[0], 'optionalAccess', _14 => _14.value]) === "attachment") {
      const content = decodeNodeContent(node);
      if (typeof content === "string")
        throw new Error("cannot process attachment content being string");
      extracted.attachments.push(content);
    }
  }
  return extracted;
}
async function parseMimeText(content) {
  const parse = (await Promise.resolve().then(() => _interopRequireWildcard(require("emailjs-mime-parser")))).default;
  const text = content.toString("utf-8");
  const headersMap = _chunkEJN47EB6js.simpleMimeHeaderParser.call(void 0, text);
  const parsedParticipants = await parseParticipants(headersMap);
  const parsedMessage = parse(text);
  const { headers } = parsedMessage;
  const addressIdentityKeys = parseIdentityKeys(_nullishCoalesce(headersMap.get(_chunkKC7PUVJGjs.X_IDENTITY_KEYS), () => ( "")));
  const extractedContent = parsedMessage.childNodes.length > 0 ? extractContent(parsedMessage.childNodes) : extractContent([parsedMessage]);
  const mailData = {
    id: parseMessageId(headers["message-id"][0].initial),
    date: new Date(headers["date"][0].value),
    ...parsedParticipants,
    subject: parseSubjectHeader(_optionalChain([headers, 'access', _15 => _15.subject, 'optionalAccess', _16 => _16[0], 'access', _17 => _17.initial])),
    plainTextMessage: extractedContent.messages["text/plain"],
    message: extractedContent.messages["text/html"]
  };
  return { mailData, addressIdentityKeys };
}
async function parseParticipants(headers) {
  const { parseOneAddress, parseAddressList } = (await Promise.resolve().then(() => _interopRequireWildcard(require("email-addresses")))).default;
  const fromValue = headers.get(_messagecomposer.HEADER_LABELS.From);
  const parsedFrom = parseOneAddress({ input: _nullishCoalesce(fromValue, () => ( "")), rfc6532: true, rejectTLD: true });
  if (parsedFrom == null)
    throw new Error(`message doesn't include valid 'from' header field [${fromValue}]`);
  const from = isParsedMailbox(parsedFrom) ? { name: _nullishCoalesce(parsedFrom.name, () => ( "")), address: parsedFrom.address } : { name: parsedFrom.name, address: parsedFrom.addresses[0].address };
  const replyTooValue = headers.get(_messagecomposer.HEADER_LABELS.ReplyTo);
  const parsedReplyTo = parseOneAddress({ input: _nullishCoalesce(replyTooValue, () => ( "")), rfc6532: true, rejectTLD: true });
  let replyTo = void 0;
  if (parsedReplyTo != null) {
    replyTo = isParsedMailbox(parsedReplyTo) ? { name: _nullishCoalesce(parsedReplyTo.name, () => ( "")), address: parsedReplyTo.address } : { name: parsedReplyTo.name, address: parsedReplyTo.addresses[0].address };
  }
  function parseAddresses(headerLabel) {
    const result = [];
    const headerValue = headers.get(headerLabel);
    if (headerValue != null) {
      const parsedAddresses = _nullishCoalesce(parseAddressList({ input: headerValue, rfc6532: true, rejectTLD: true }), () => ( []));
      for (const address of parsedAddresses) {
        if (isParsedMailbox(address)) {
          result.push({ name: _nullishCoalesce(address.name, () => ( "")), address: address.address });
        } else {
          result.push(
            ...address.addresses.map((a) => ({ name: _nullishCoalesce(a.name, () => ( address.name)), address: a.address }))
          );
        }
      }
    }
    return result;
  }
  const recipients = parseAddresses(_messagecomposer.HEADER_LABELS.To);
  const carbonCopyRecipients = parseAddresses(_messagecomposer.HEADER_LABELS.Cc);
  const blindCarbonCopyRecipients = parseAddresses(_messagecomposer.HEADER_LABELS.Bcc);
  return { from, replyTo, recipients, carbonCopyRecipients, blindCarbonCopyRecipients };
}
function isParsedMailbox(mailboxOrGroup) {
  return mailboxOrGroup.type === "mailbox";
}
function parseMessageId(messageIdHeader) {
  if (messageIdHeader.startsWith("<") && messageIdHeader.endsWith(">")) {
    return messageIdHeader.slice(1, -1);
  }
  return messageIdHeader;
}
function parseSubjectHeader(rawSubject) {
  if (!rawSubject.startsWith("=?"))
    return rawSubject;
  const lines = rawSubject.split("	");
  let encodedContent = "";
  let contentEncoding = null;
  let contentCharset = null;
  for (const line of lines) {
    const [, charset, encoding, encodedText] = line.split("?");
    if (contentEncoding == null) {
      contentEncoding = encoding;
    } else if (contentEncoding !== encoding) {
      throw new Error(`mixed encoding of subject lines, expected [${contentEncoding}], received [${encoding}]`);
    }
    if (contentCharset == null) {
      contentCharset = charset;
    } else if (contentCharset !== charset) {
      throw new Error(`mixed charset of subject lines, expected [${contentCharset}], received [${charset}]`);
    }
    encodedContent += encodedText;
  }
  let decodedContent = null;
  if (contentEncoding === "B") {
    decodedContent = _encoding.decodeBase64.call(void 0, encodedContent);
  }
  let charsetEncodedContent = null;
  if (decodedContent) {
    if (_optionalChain([contentCharset, 'optionalAccess', _18 => _18.toUpperCase, 'call', _19 => _19()]) === "UTF-8") {
      charsetEncodedContent = _encoding.encodeUtf8.call(void 0, decodedContent);
    }
  }
  if (charsetEncodedContent && charsetEncodedContent.indexOf("%") > -1) {
    try {
      return decodeURIComponent(charsetEncodedContent);
    } catch (e) {
    }
  }
  return _nullishCoalesce(charsetEncodedContent, () => ( encodedContent));
}
function parseIdentityKeys(attrStr) {
  const result = /* @__PURE__ */ new Map();
  for (const attrPairStr of attrStr.split(";")) {
    const [attrKey, quotedValue] = attrPairStr.trim().split("=");
    if (attrKey == null || attrKey.length === 0 || quotedValue == null || quotedValue.length === 0)
      continue;
    const value = quotedValue.substring(1, quotedValue.length - 1);
    if (attrKey === "v") {
      if (value !== "1") {
        console.warn(`unsupported ${_chunkKC7PUVJGjs.X_IDENTITY_KEYS} version of [${value}]`);
        return /* @__PURE__ */ new Map();
      }
    } else {
      const [encodedIdentityKey, protocol] = value.split(":");
      if (!_addressing.ALL_PROTOCOLS.includes(protocol)) {
        console.warn(`address [${attrKey}] has unsupported protocol [${protocol}]`);
      }
      try {
        const identityKey = _crypto.publicKeyFromBytes.call(void 0, _encoding.decodeHexZeroX.call(void 0, encodedIdentityKey));
        result.set(attrKey, { ...{ identityKey, protocol } });
      } catch (e) {
        console.warn(
          `failed decoding identity key of address [${attrKey}] for value [${encodedIdentityKey}]`,
          e
        );
      }
    }
  }
  return result;
}



exports.parseMimeText = parseMimeText;
