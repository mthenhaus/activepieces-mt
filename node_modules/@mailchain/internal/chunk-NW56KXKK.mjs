import {
  isConditionIsFromAddress,
  isConditionIsFromIdentity,
  isConditionOperationAnd,
  isConditionOperationNot,
  isConditionOperationOr
} from "./chunk-XFMYRCTF.mjs";
import {
  IdentityKeys
} from "./chunk-7AQ4G6HT.mjs";

// src/mailboxRuleEngine/conditionsHandler.ts
import { isPublicKeyEqual } from "@mailchain/crypto";
import { isSameAddress } from "@mailchain/addressing";
async function conditionsRunner(params, condition, conditionHandlers) {
  for (const conditionHandler of conditionHandlers) {
    const result = await conditionHandler.execute(
      params,
      condition,
      (checkCondition) => conditionsRunner(params, checkCondition, conditionHandlers)
    );
    if (result)
      return true;
  }
  return false;
}
var conditionIsFromAddressHandler = {
  id: "conditionIsFromAddressHandler",
  execute: async (params, condition) => {
    if (!isConditionIsFromAddress(condition))
      return false;
    return isSameAddress(params.message.from, condition.value);
  }
};
function createConditionIsFromIdentityHandler(identityKeys) {
  return {
    id: "conditionIsFromIdentityHandler",
    execute: async (params, condition) => {
      if (!isConditionIsFromIdentity(condition))
        return false;
      const fromIdentityKey = await identityKeys.resolve(params.message.from);
      if (fromIdentityKey == null)
        return false;
      return isPublicKeyEqual(fromIdentityKey.identityKey, condition.value);
    }
  };
}
var conditionOperationOrHandler = {
  id: "conditionOperationOrHandler",
  execute: async (_params, condition, checkCondition) => {
    if (!isConditionOperationOr(condition))
      return false;
    for (const orCondition of condition.value) {
      if (await checkCondition(orCondition))
        return true;
    }
    return false;
  }
};
var conditionOperationAndHandler = {
  id: "conditionOperationAndHandler",
  execute: async (_params, condition, checkCondition) => {
    if (!isConditionOperationAnd(condition))
      return false;
    for (const andCondition of condition.value) {
      if (!await checkCondition(andCondition))
        return false;
    }
    return true;
  }
};
var conditionOperationNotHandler = {
  id: "conditionOperationNotHandler",
  execute: async (_params, condition, checkCondition) => {
    if (!isConditionOperationNot(condition))
      return false;
    return !await checkCondition(condition.value);
  }
};
function defaultConditionHandlers(sdkConfig) {
  return [
    conditionIsFromAddressHandler,
    createConditionIsFromIdentityHandler(IdentityKeys.create(sdkConfig)),
    conditionOperationOrHandler,
    conditionOperationAndHandler,
    conditionOperationNotHandler
  ];
}

export {
  conditionsRunner,
  conditionIsFromAddressHandler,
  createConditionIsFromIdentityHandler,
  conditionOperationOrHandler,
  conditionOperationAndHandler,
  conditionOperationNotHandler,
  defaultConditionHandlers
};
