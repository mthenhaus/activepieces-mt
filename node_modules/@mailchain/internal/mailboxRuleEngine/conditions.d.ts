import { PublicKey } from '@mailchain/crypto';
import { MailboxRuleCondition } from './rule.js';

/**
 * Condition that checks if the message is from the given address.
 */
type ConditionIsFromAddress = MailboxRuleCondition<string> & {
    type: 'IsFromAddress';
};
/**
 * Type guard for `ConditionIsFrom`
 */
declare function isConditionIsFromAddress(condition: MailboxRuleCondition<unknown>): condition is ConditionIsFromAddress;
/**
 * Create a `ConditionIsFrom` condition.
 */
declare function conditionIsFromAddress(params: ConditionIsFromAddress['value']): ConditionIsFromAddress;
/**
 * Condition that checks if the message is from the given identity.
 */
type ConditionIsFromIdentity = MailboxRuleCondition<PublicKey> & {
    type: 'IsFromIdentity';
};
/**
 * Type guard for `ConditionIsFromIdentity``
 */
declare function isConditionIsFromIdentity(condition: MailboxRuleCondition<unknown>): condition is ConditionIsFromIdentity;
/**
 * Create a `ConditionIsFromIdentity` condition.
 */
declare function conditionIsFromIdentity(params: ConditionIsFromIdentity['value']): ConditionIsFromIdentity;
/**
 * Operation condition that checks if any of the conditions in the list applies. Useful for making composition of conditions.
 */
type ConditionOperationOr = MailboxRuleCondition<MailboxRuleCondition<unknown>[]> & {
    type: 'OperationOr';
};
/**
 * Create a `ConditionOperationOr` condition.
 */
declare function conditionOperationOr(conditions: MailboxRuleCondition<unknown>[]): ConditionOperationOr;
/**
 * Type guard for `ConditionOperationOr`
 */
declare function isConditionOperationOr(condition: MailboxRuleCondition<unknown>): condition is ConditionOperationOr;
/**
 * Operation condition that checks if all of the conditions in the list applies. Useful for making composition of conditions.
 */
type ConditionOperationAnd = MailboxRuleCondition<MailboxRuleCondition<unknown>[]> & {
    type: 'OperationAnd';
};
/**
 * Create a `ConditionOperationAnd` condition.
 */
declare function conditionOperationAnd(conditions: MailboxRuleCondition<unknown>[]): ConditionOperationAnd;
/**
 * Type guard for `ConditionOperationAnd`
 */
declare function isConditionOperationAnd(condition: MailboxRuleCondition<unknown>): condition is ConditionOperationAnd;
/**
 * Operation condition that checks if the condition does not apply. Basically, negating the wrapped condition.
 */
type ConditionOperationNot = MailboxRuleCondition<MailboxRuleCondition<unknown>> & {
    type: 'OperationNot';
};
/**
 * Create a `ConditionOperationNot` condition.
 */
declare function conditionOperationNot(condition: MailboxRuleCondition<unknown>): ConditionOperationNot;
/**
 * Type guard for `ConditionOperationNot`
 */
declare function isConditionOperationNot(condition: MailboxRuleCondition<unknown>): condition is ConditionOperationNot;

export { ConditionIsFromAddress, ConditionIsFromIdentity, ConditionOperationAnd, ConditionOperationNot, ConditionOperationOr, conditionIsFromAddress, conditionIsFromIdentity, conditionOperationAnd, conditionOperationNot, conditionOperationOr, isConditionIsFromAddress, isConditionIsFromIdentity, isConditionOperationAnd, isConditionOperationNot, isConditionOperationOr };
