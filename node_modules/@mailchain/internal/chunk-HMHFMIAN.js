"use strict";Object.defineProperty(exports, "__esModule", {value: true});

var _chunkKC7PUVJGjs = require('./chunk-KC7PUVJG.js');

// src/formatters/generate.ts
var _crypto = require('@mailchain/crypto');
var _encoding = require('@mailchain/encoding');
var _messagecomposer = require('@mailchain/message-composer');
var createMimeMessage = async (mailData, resolvedAddresses) => {
  const msg = _messagecomposer.createMessageComposer.call(void 0, ).id(mailData.id).date(mailData.date).subject(mailData.subject).from(mailData.from).recipients("To", ...mailData.recipients).recipients("Cc", ...mailData.carbonCopyRecipients).recipients("Bcc", ...mailData.blindCarbonCopyRecipients).message("html", Buffer.from(mailData.message)).message("plain", Buffer.from(mailData.plainTextMessage));
  const visibleIdentityKeyAddresses = [mailData.from, ...mailData.recipients, ...mailData.carbonCopyRecipients];
  if (mailData.replyTo) {
    msg.replyTo(mailData.replyTo);
    visibleIdentityKeyAddresses.push(mailData.replyTo);
  }
  const msgWithIdentityAttributes = addAllIdentityKeyAttr(
    msg,
    visibleIdentityKeyAddresses,
    mailData.blindCarbonCopyRecipients,
    resolvedAddresses
  );
  const builtMsg = await msgWithIdentityAttributes.build();
  return {
    original: builtMsg.forSender,
    visibleRecipients: builtMsg.forVisibleRecipients,
    blindRecipients: builtMsg.forBlindedRecipients.map(([recipient, content]) => ({
      recipient: { name: recipient.name, address: recipient.address },
      content
    }))
  };
};
function addAllIdentityKeyAttr(msg, visibleIdentityKeyAddresses, blindCarbonCopyRecipients, resolvedAddresses) {
  const visibleIdentityKeyAttrs = [];
  for (const { address } of visibleIdentityKeyAddresses) {
    putIdentityKeyAttr(address, resolvedAddresses, visibleIdentityKeyAttrs);
  }
  if (visibleIdentityKeyAttrs.length > 0) {
    msg.customHeader(_chunkKC7PUVJGjs.X_IDENTITY_KEYS, "", ["v", "1"], ...visibleIdentityKeyAttrs);
  }
  const allBlindIdentityKeyAttrs = [];
  for (const { address } of blindCarbonCopyRecipients) {
    const bccIdentityKeyAttrs = [...visibleIdentityKeyAttrs];
    const putAttr = putIdentityKeyAttr(address, resolvedAddresses, bccIdentityKeyAttrs);
    if (putAttr) {
      allBlindIdentityKeyAttrs.push(putAttr);
      msg.overrideBccHeader(address, _chunkKC7PUVJGjs.X_IDENTITY_KEYS, "", ["v", "1"], ...bccIdentityKeyAttrs);
    }
  }
  if (allBlindIdentityKeyAttrs.length > 0) {
    msg.overrideSenderHeader(
      _chunkKC7PUVJGjs.X_IDENTITY_KEYS,
      "",
      ["v", "1"],
      ...visibleIdentityKeyAttrs,
      ...allBlindIdentityKeyAttrs
    );
  }
  return msg;
}
function putIdentityKeyAttr(address, resolvedAddresses, attrs) {
  const lookupResult = resolvedAddresses.get(address);
  if (!lookupResult)
    return void 0;
  if (lookupResult.identityKey == null)
    return void 0;
  const { identityKey, protocol } = lookupResult;
  const attrValue = `${_encoding.encodeHexZeroX.call(void 0, _crypto.publicKeyToBytes.call(void 0, identityKey))}:${protocol}`;
  const attr = [address, attrValue];
  attrs.push(attr);
  return attr;
}



exports.createMimeMessage = createMimeMessage;
