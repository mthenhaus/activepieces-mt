"use strict";Object.defineProperty(exports, "__esModule", {value: true});

var _chunk5ZVSPRLFjs = require('./chunk-5ZVSPRLF.js');


var _chunkQCFABMXLjs = require('./chunk-QCFABMXL.js');


var _chunkJBCB7BBHjs = require('./chunk-JBCB7BBH.js');


var _chunkZKQAO77Pjs = require('./chunk-ZKQAO77P.js');

// src/sending/mail/sender.ts
var MailSender = class {
  constructor(senderMessagingKey, mailPreparer, payloadDistributor) {
    this.senderMessagingKey = senderMessagingKey;
    this.mailPreparer = mailPreparer;
    this.payloadDistributor = payloadDistributor;
  }
  static fromSenderMessagingKey(senderMessagingKey, configuration = _chunkZKQAO77Pjs.defaultConfiguration) {
    return new MailSender(
      senderMessagingKey,
      _chunkJBCB7BBHjs.MailPreparer.create(configuration),
      _chunk5ZVSPRLFjs.PayloadDistributor.create(configuration, senderMessagingKey)
    );
  }
  /**
   * Send a mail to any blockchain or Mailchain address using the address Messaging Key.
   *
   * @param params {@link SendMailParams} - The parameters for sending a mail.
   * @returns
   */
  async sendMail(params) {
    const { data: preparedMail, error: prepareMailError } = await this.mailPreparer.prepareMail({
      message: _chunkQCFABMXLjs.toMailData.call(void 0, params),
      payloadPluginHeaders: params.payloadPluginHeaders,
      senderMessagingKey: this.senderMessagingKey
    });
    if (prepareMailError) {
      return { error: prepareMailError };
    }
    const { data: distributedMail, error: distributedMailError } = await this.payloadDistributor.distributePayload({
      distributions: preparedMail.distributions,
      resolvedAddresses: preparedMail.resolvedAddresses
    });
    if (distributedMailError) {
      return { error: distributedMailError };
    }
    return {
      data: {
        sentMailDeliveryRequests: distributedMail
      }
    };
  }
};



exports.MailSender = MailSender;
