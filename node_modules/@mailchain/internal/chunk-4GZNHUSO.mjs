import {
  MailchainKeyRegContractCallResolver
} from "./chunk-VRCX4BTH.mjs";
import {
  NearContractCallResolver
} from "./chunk-VHRK63OY.mjs";
import {
  MessagingKeyNotFoundInContractError
} from "./chunk-TACI5AZH.mjs";
import {
  UnexpectedMailchainError
} from "./chunk-QQZCHFKV.mjs";

// src/messagingKeys/addressNonce.ts
import {
  ETHEREUM,
  MAILCHAIN,
  NEAR,
  ProtocolNotSupportedError,
  SOLANA,
  TEZOS,
  isBlockchainProtocolEnabled
} from "@mailchain/addressing";
import axios from "axios";
import { MessagingKeysApiFactory, createAxiosConfiguration } from "@mailchain/api";
var AddressNonce = class {
  constructor(messagingKeysApi, resolvers) {
    this.messagingKeysApi = messagingKeysApi;
    this.resolvers = resolvers;
  }
  static create(configuration, axiosInstance = axios.create()) {
    const mailchainKeyRegistryResolver = MailchainKeyRegContractCallResolver.create(configuration, axiosInstance);
    return new AddressNonce(
      MessagingKeysApiFactory(createAxiosConfiguration(configuration.apiPath)),
      /* @__PURE__ */ new Map([
        [NEAR, NearContractCallResolver.create(configuration, axiosInstance)],
        [ETHEREUM, mailchainKeyRegistryResolver],
        [TEZOS, mailchainKeyRegistryResolver],
        [SOLANA, mailchainKeyRegistryResolver]
      ])
    );
  }
  /**
   * Get the latest nonce for an address.
   *
   * @param address the protocol get the latest nonce for.
   * @param protocol where to find the address.
   * @returns The latest nonce for the given address.
   */
  async getMessagingKeyLatestNonce(address, protocol) {
    if (protocol === MAILCHAIN) {
      return { data: 1 };
    }
    const resolver = this.resolvers.get(protocol);
    if (!resolver) {
      return { error: new ProtocolNotSupportedError(protocol) };
    }
    if (!isBlockchainProtocolEnabled(protocol)) {
      return { error: new ProtocolNotSupportedError(protocol) };
    }
    const nonceContractResponse = await this.messagingKeysApi.getProtocolAddressNonce(address, protocol);
    try {
      const nonce = await resolver.latestNonce(nonceContractResponse.data.contractCall);
      return {
        data: nonce
      };
    } catch (error) {
      if (error instanceof MessagingKeyNotFoundInContractError) {
        return {
          data: 0
        };
      }
      return {
        error: new UnexpectedMailchainError("Failed to get latest nonce.", { cause: error })
      };
    }
  }
};

export {
  AddressNonce
};
