import {
  MessagingKeys
} from "./chunk-NK6CIHSE.mjs";
import {
  AddressNonce
} from "./chunk-4GZNHUSO.mjs";
import {
  AddressNotRegisteredError
} from "./chunk-E5ONHO3D.mjs";

// src/messagingKeys/privateMessagingKeys.ts
import { isPublicKeyEqual } from "@mailchain/crypto";
import { ProvidedMessagingKeyIncorrectError } from "@mailchain/signatures";
var PrivateMessagingKeys = class {
  constructor(messagingKeys, addressNonce) {
    this.messagingKeys = messagingKeys;
    this.addressNonce = addressNonce;
  }
  static create(config) {
    return new PrivateMessagingKeys(MessagingKeys.create(config), AddressNonce.create(config));
  }
  async getExportablePrivateMessagingKey(address, keyRing) {
    const { data: resolvedAddress, error: resolveAddressError } = await this.messagingKeys.resolve(address);
    if (resolveAddressError != null) {
      return { error: resolveAddressError };
    }
    const { data: getMessagingKeyLatestNonce, error: getMessagingKeyLatestNonceError } = await this.addressNonce.getMessagingKeyLatestNonce(
      resolvedAddress.protocolAddress,
      resolvedAddress.protocol
    );
    if (getMessagingKeyLatestNonceError != null) {
      return { error: getMessagingKeyLatestNonceError };
    }
    if (resolvedAddress.type === "vended") {
      return { error: new AddressNotRegisteredError() };
    }
    const privateMessagingKey = keyRing.addressExportableMessagingKey(
      resolvedAddress.protocolAddress,
      resolvedAddress.protocol,
      getMessagingKeyLatestNonce
    );
    if (!isPublicKeyEqual(privateMessagingKey.publicKey, resolvedAddress.messagingKey)) {
      return { error: new ProvidedMessagingKeyIncorrectError("address") };
    }
    return { data: privateMessagingKey };
  }
};

export {
  PrivateMessagingKeys
};
