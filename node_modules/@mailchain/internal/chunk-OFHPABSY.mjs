import {
  createDelivery
} from "./chunk-GTU4ER3H.mjs";
import {
  protocol
} from "./chunk-4IWBVVDK.mjs";
import {
  partitionMailchainResults
} from "./chunk-TVSW4CHH.mjs";

// src/sending/deliveryRequests/deliveryRequests.ts
import { publicKeyToBytes } from "@mailchain/crypto";
import { encodeBase64, encodeHexZeroX } from "@mailchain/encoding";
import {
  TransportApiFactory,
  getAxiosWithSigner,
  createAxiosConfiguration
} from "@mailchain/api";
var SomeDeliveryRequestsFailedError = class extends Error {
  constructor(successes, failures) {
    super(
      `Not all delivery requests were successfully sent. Check the failed delivery requests to retry failed requests.`
    );
    this.successes = successes;
    this.failures = failures;
  }
};
var SendDeliveryRequestTransportError = class extends Error {
  constructor(cause, params) {
    super("failed sending delivery request", { cause });
    this.params = params;
  }
};
var DeliveryRequests = class {
  constructor(transportApi) {
    this.transportApi = transportApi;
  }
  static create(configuration, sender) {
    return new DeliveryRequests(
      TransportApiFactory(createAxiosConfiguration(configuration.apiPath), void 0, getAxiosWithSigner(sender))
    );
  }
  /**
   * Send the same payload delivery request to multiple recipients
   */
  async sendManyDeliveryRequests(params) {
    const { recipients, payloadUri, payloadRootEncryptionKey } = params;
    const results = await Promise.all(
      recipients.map(async (recipientMessageKey) => {
        const sendDeliveryRequestParams = {
          recipientMessageKey,
          payloadUri,
          payloadRootEncryptionKey
        };
        const result = await this.sendDeliveryRequest(sendDeliveryRequestParams);
        return { result, params: sendDeliveryRequestParams };
      })
    );
    const { successes: sent, failures: failed } = partitionMailchainResults(results);
    if (failed.length > 0) {
      return {
        error: new SomeDeliveryRequestsFailedError(sent, failed)
      };
    }
    return {
      data: sent.map((s) => s.data)
    };
  }
  /**
   * Create delivery request for the recipient of the message providing the key used to encrypt the payload.
   *
   * @param recipientMessageKey the key of the message
   * @param messageUri the URL to get the message from
   * @param payloadRootEncryptionKey the root ephemeral key used to encrypt the Payload
   */
  async sendDeliveryRequest(params) {
    const { recipientMessageKey, payloadRootEncryptionKey, payloadUri } = params;
    const deliveryCreated = await createDelivery(recipientMessageKey, payloadRootEncryptionKey, payloadUri);
    try {
      const { deliveryRequestID: deliveryRequestId } = await this.transportApi.postDeliveryRequest({
        encryptedDeliveryRequest: encodeBase64(protocol.Delivery.encode(deliveryCreated).finish()),
        recipientMessagingKey: encodeHexZeroX(publicKeyToBytes(recipientMessageKey))
      }).then((response) => response.data);
      return { data: { deliveryRequestId, recipientMessageKey } };
    } catch (e) {
      return {
        error: new SendDeliveryRequestTransportError(e, params)
      };
    }
  }
};

export {
  SomeDeliveryRequestsFailedError,
  SendDeliveryRequestTransportError,
  DeliveryRequests
};
