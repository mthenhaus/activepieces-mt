import {
  CHUNK_LENGTH_1MB,
  chunkBuffer
} from "./chunk-OD5QTNTX.mjs";

// src/transport/serialization/encrypt.ts
import {
  secureRandom,
  deriveHardenedKey,
  PrivateKeyEncrypter
} from "@mailchain/crypto";
async function encryptPayload(headers, content, payloadRootKey, chunkSize = CHUNK_LENGTH_1MB, rand = secureRandom) {
  const chunks = chunkBuffer(content, chunkSize);
  const encryptedContentChunks = await encryptChunks(chunks, payloadRootKey, rand);
  const headersEncryptionKey = deriveHardenedKey(payloadRootKey, "headers");
  const encryptedHeaders = await encryptBuffer(headers, headersEncryptionKey.privateKey, rand);
  return {
    EncryptedHeaders: encryptedHeaders,
    EncryptedContentChunks: encryptedContentChunks
  };
}
async function encryptChunks(chunks, payloadRootKey, rand = secureRandom) {
  const encryptedChunks = new Array(chunks.length);
  const contentRootKey = deriveHardenedKey(payloadRootKey, "content");
  for (let i = 0; i < chunks.length; i++) {
    const chunkKey = deriveHardenedKey(contentRootKey, i);
    encryptedChunks[i] = await encryptBuffer(chunks[i], chunkKey.privateKey, rand);
  }
  return encryptedChunks;
}
async function encryptBuffer(buffer, key, rand = secureRandom) {
  const encrypted = await PrivateKeyEncrypter.fromPrivateKey(key, rand).encrypt(buffer);
  return Buffer.from(encrypted);
}

export {
  encryptPayload,
  encryptChunks,
  encryptBuffer
};
