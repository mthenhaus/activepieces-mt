"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _chunkBQQXYBRHjs = require('./chunk-BQQXYBRH.js');


var _chunk7K4JOLRRjs = require('./chunk-7K4JOLRR.js');


var _chunkAR4N7KS5js = require('./chunk-AR4N7KS5.js');



var _chunkGDYJBQYGjs = require('./chunk-GDYJBQYG.js');


var _chunkPCGAQDYDjs = require('./chunk-PCGAQDYD.js');


var _chunkRH2527U6js = require('./chunk-RH2527U6.js');

// src/messagingKeys/messagingKeyContract.ts



var _api = require('@mailchain/api');
var _axios = require('axios'); var _axios2 = _interopRequireDefault(_axios);
var _addressing = require('@mailchain/addressing');
var _apiKeyToCryptoKey = require('@mailchain/api/helpers/apiKeyToCryptoKey');
var _signatures = require('@mailchain/signatures');
var _protocols = require('@mailchain/addressing/protocols');
var MessagingKeyContractCall = class {
  constructor(resolvers, messagingKeysApi, messagingKeyVerifier) {
    this.resolvers = resolvers;
    this.messagingKeysApi = messagingKeysApi;
    this.messagingKeyVerifier = messagingKeyVerifier;
  }
  static create(configuration, axiosInstance = _axios2.default.create()) {
    const mailchainKeyRegistryResolver = _chunkBQQXYBRHjs.MailchainKeyRegContractCallResolver.create(configuration, axiosInstance);
    return new MessagingKeyContractCall(
      /* @__PURE__ */ new Map([
        [_addressing.ETHEREUM, mailchainKeyRegistryResolver],
        [_protocols.MAILCHAIN, mailchainKeyRegistryResolver],
        [_addressing.NEAR, _chunkAR4N7KS5js.NearContractCallResolver.create(configuration, axiosInstance)],
        [_addressing.TEZOS, mailchainKeyRegistryResolver],
        [_protocols.SOLANA, mailchainKeyRegistryResolver]
      ]),
      _api.MessagingKeysApiFactory.call(void 0, _api.createAxiosConfiguration.call(void 0, configuration.apiPath)),
      _chunk7K4JOLRRjs.MessagingKeyVerifier.create(configuration)
    );
  }
  async resolve(contractCall, identityKey) {
    const protocol = contractCall.protocol;
    const resolver = this.resolvers.get(protocol);
    if (!resolver) {
      return { error: new (0, _protocols.ProtocolNotSupportedError)(protocol) };
    }
    const { data, error } = await resolver.resolve(contractCall);
    if (error instanceof _chunkGDYJBQYGjs.MessagingKeyNotFoundInContractError) {
      return this.getVerifiedVendedPublicMessagingKey(contractCall.address, protocol, identityKey);
    } else if (error instanceof _chunkGDYJBQYGjs.InvalidContractResponseError) {
      return { error: new (0, _chunkPCGAQDYDjs.MessagingKeyContactError)(error) };
    } else if (error) {
      return {
        error: new (0, _chunkPCGAQDYDjs.MessagingKeyContactError)(error)
      };
    }
    if (!identityKey) {
      return {
        error: new (0, _chunkRH2527U6js.UnexpectedMailchainError)("identityKey is required")
      };
    }
    const { messagingKey, proof } = data;
    return {
      data: {
        type: "registered",
        messagingKey,
        identityKey,
        protocol,
        protocolAddress: contractCall.address,
        proof
      }
    };
  }
  async getVerifiedVendedPublicMessagingKey(address, protocol, identityKey) {
    const vendedKeyResponse = await this.messagingKeysApi.getVendedPublicMessagingKey(address, protocol);
    const verified = await this.messagingKeyVerifier.verifyProvidedKeyProof(
      vendedKeyResponse.data.proof,
      _apiKeyToCryptoKey.convertPublic.call(void 0, vendedKeyResponse.data.messagingKey)
    );
    if (!verified) {
      return { error: new (0, _signatures.MessagingKeyVerificationError)() };
    }
    return {
      data: {
        messagingKey: _apiKeyToCryptoKey.convertPublic.call(void 0, vendedKeyResponse.data.messagingKey),
        identityKey,
        protocol,
        type: "vended",
        protocolAddress: address
      }
    };
  }
};



exports.MessagingKeyContractCall = MessagingKeyContractCall;
