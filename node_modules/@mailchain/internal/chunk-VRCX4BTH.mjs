import {
  messagingKeyProofFromApi
} from "./chunk-3U3NVNQQ.mjs";
import {
  MessagingKeyVerifier
} from "./chunk-GFHS4OJJ.mjs";
import {
  MessagingKeyNotFoundInContractError
} from "./chunk-TACI5AZH.mjs";
import {
  UnexpectedMailchainError
} from "./chunk-QQZCHFKV.mjs";

// src/messagingKeys/contractResolvers/mailchain.ts
import axios from "axios";
import { convertPublic } from "@mailchain/api/helpers/apiKeyToCryptoKey";
import { MessagingKeyVerificationError } from "@mailchain/signatures";
var MailchainKeyRegContractCallResolver = class {
  constructor(messagingKeyVerifier, rpcEndpoint, axiosInstance) {
    this.messagingKeyVerifier = messagingKeyVerifier;
    this.rpcEndpoint = rpcEndpoint;
    this.axiosInstance = axiosInstance;
  }
  static create(configuration, axiosInstance = axios.create()) {
    return new this(MessagingKeyVerifier.create(configuration), configuration.apiPath, axiosInstance);
  }
  async resolve(contract) {
    if (contract.path === "/identity-keys/0/messaging-key") {
      return { error: new MessagingKeyNotFoundInContractError() };
    }
    const { data: rpcResponse, error: getMessagingKeyContractError } = await this.callGetMessagingKeyContract(
      contract
    );
    if (getMessagingKeyContractError) {
      return { error: getMessagingKeyContractError };
    }
    const messagingKey = convertPublic(rpcResponse.messagingKey);
    const verified = await this.messagingKeyVerifier.verifyRegisteredKeyProof(rpcResponse.proof, messagingKey);
    if (!verified) {
      return { error: new MessagingKeyVerificationError() };
    }
    return {
      data: {
        messagingKey,
        protocol: contract.protocol,
        proof: messagingKeyProofFromApi(rpcResponse)
      }
    };
  }
  async latestNonce(contract) {
    if (contract.path === "/identity-keys/0/nonce") {
      throw new MessagingKeyNotFoundInContractError();
    }
    try {
      const { data } = await this.axiosInstance.request({
        method: contract.method,
        url: this.rpcEndpoint + contract.path
      });
      const { nonce } = data;
      return nonce;
    } catch (error) {
      if (axios.isAxiosError(error) && error.response && error.response.status === 404) {
        throw new MessagingKeyNotFoundInContractError();
      }
      throw error;
    }
  }
  async callGetMessagingKeyContract(contract) {
    try {
      const response = await this.axiosInstance.request({
        method: contract.method,
        url: this.rpcEndpoint + contract.path
      });
      return { data: response.data };
    } catch (error) {
      if (axios.isAxiosError(error) && error.response && error.response.status === 404) {
        return {
          error: new MessagingKeyNotFoundInContractError()
        };
      }
      return {
        error: new UnexpectedMailchainError("failed to call messaging key contract", { cause: error })
      };
    }
  }
};

export {
  MailchainKeyRegContractCallResolver
};
