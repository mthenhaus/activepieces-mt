"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _chunkDIK6R3YNjs = require('./chunk-DIK6R3YN.js');


var _chunk7K4JOLRRjs = require('./chunk-7K4JOLRR.js');


var _chunkGDYJBQYGjs = require('./chunk-GDYJBQYG.js');


var _chunkRH2527U6js = require('./chunk-RH2527U6.js');

// src/messagingKeys/contractResolvers/mailchain.ts
var _axios = require('axios'); var _axios2 = _interopRequireDefault(_axios);
var _apiKeyToCryptoKey = require('@mailchain/api/helpers/apiKeyToCryptoKey');
var _signatures = require('@mailchain/signatures');
var MailchainKeyRegContractCallResolver = class {
  constructor(messagingKeyVerifier, rpcEndpoint, axiosInstance) {
    this.messagingKeyVerifier = messagingKeyVerifier;
    this.rpcEndpoint = rpcEndpoint;
    this.axiosInstance = axiosInstance;
  }
  static create(configuration, axiosInstance = _axios2.default.create()) {
    return new this(_chunk7K4JOLRRjs.MessagingKeyVerifier.create(configuration), configuration.apiPath, axiosInstance);
  }
  async resolve(contract) {
    if (contract.path === "/identity-keys/0/messaging-key") {
      return { error: new (0, _chunkGDYJBQYGjs.MessagingKeyNotFoundInContractError)() };
    }
    const { data: rpcResponse, error: getMessagingKeyContractError } = await this.callGetMessagingKeyContract(
      contract
    );
    if (getMessagingKeyContractError) {
      return { error: getMessagingKeyContractError };
    }
    const messagingKey = _apiKeyToCryptoKey.convertPublic.call(void 0, rpcResponse.messagingKey);
    const verified = await this.messagingKeyVerifier.verifyRegisteredKeyProof(rpcResponse.proof, messagingKey);
    if (!verified) {
      return { error: new (0, _signatures.MessagingKeyVerificationError)() };
    }
    return {
      data: {
        messagingKey,
        protocol: contract.protocol,
        proof: _chunkDIK6R3YNjs.messagingKeyProofFromApi.call(void 0, rpcResponse)
      }
    };
  }
  async latestNonce(contract) {
    if (contract.path === "/identity-keys/0/nonce") {
      throw new (0, _chunkGDYJBQYGjs.MessagingKeyNotFoundInContractError)();
    }
    try {
      const { data } = await this.axiosInstance.request({
        method: contract.method,
        url: this.rpcEndpoint + contract.path
      });
      const { nonce } = data;
      return nonce;
    } catch (error) {
      if (_axios2.default.isAxiosError(error) && error.response && error.response.status === 404) {
        throw new (0, _chunkGDYJBQYGjs.MessagingKeyNotFoundInContractError)();
      }
      throw error;
    }
  }
  async callGetMessagingKeyContract(contract) {
    try {
      const response = await this.axiosInstance.request({
        method: contract.method,
        url: this.rpcEndpoint + contract.path
      });
      return { data: response.data };
    } catch (error) {
      if (_axios2.default.isAxiosError(error) && error.response && error.response.status === 404) {
        return {
          error: new (0, _chunkGDYJBQYGjs.MessagingKeyNotFoundInContractError)()
        };
      }
      return {
        error: new (0, _chunkRH2527U6js.UnexpectedMailchainError)("failed to call messaging key contract", { cause: error })
      };
    }
  }
};



exports.MailchainKeyRegContractCallResolver = MailchainKeyRegContractCallResolver;
