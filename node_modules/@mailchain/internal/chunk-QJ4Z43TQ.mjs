import {
  X_IDENTITY_KEYS
} from "./chunk-TM5VJXLZ.mjs";

// src/formatters/generate.ts
import { publicKeyToBytes } from "@mailchain/crypto";
import { encodeHexZeroX } from "@mailchain/encoding";
import { createMessageComposer } from "@mailchain/message-composer";
var createMimeMessage = async (mailData, resolvedAddresses) => {
  const msg = createMessageComposer().id(mailData.id).date(mailData.date).subject(mailData.subject).from(mailData.from).recipients("To", ...mailData.recipients).recipients("Cc", ...mailData.carbonCopyRecipients).recipients("Bcc", ...mailData.blindCarbonCopyRecipients).message("html", Buffer.from(mailData.message)).message("plain", Buffer.from(mailData.plainTextMessage));
  const visibleIdentityKeyAddresses = [mailData.from, ...mailData.recipients, ...mailData.carbonCopyRecipients];
  if (mailData.replyTo) {
    msg.replyTo(mailData.replyTo);
    visibleIdentityKeyAddresses.push(mailData.replyTo);
  }
  const msgWithIdentityAttributes = addAllIdentityKeyAttr(
    msg,
    visibleIdentityKeyAddresses,
    mailData.blindCarbonCopyRecipients,
    resolvedAddresses
  );
  const builtMsg = await msgWithIdentityAttributes.build();
  return {
    original: builtMsg.forSender,
    visibleRecipients: builtMsg.forVisibleRecipients,
    blindRecipients: builtMsg.forBlindedRecipients.map(([recipient, content]) => ({
      recipient: { name: recipient.name, address: recipient.address },
      content
    }))
  };
};
function addAllIdentityKeyAttr(msg, visibleIdentityKeyAddresses, blindCarbonCopyRecipients, resolvedAddresses) {
  const visibleIdentityKeyAttrs = [];
  for (const { address } of visibleIdentityKeyAddresses) {
    putIdentityKeyAttr(address, resolvedAddresses, visibleIdentityKeyAttrs);
  }
  if (visibleIdentityKeyAttrs.length > 0) {
    msg.customHeader(X_IDENTITY_KEYS, "", ["v", "1"], ...visibleIdentityKeyAttrs);
  }
  const allBlindIdentityKeyAttrs = [];
  for (const { address } of blindCarbonCopyRecipients) {
    const bccIdentityKeyAttrs = [...visibleIdentityKeyAttrs];
    const putAttr = putIdentityKeyAttr(address, resolvedAddresses, bccIdentityKeyAttrs);
    if (putAttr) {
      allBlindIdentityKeyAttrs.push(putAttr);
      msg.overrideBccHeader(address, X_IDENTITY_KEYS, "", ["v", "1"], ...bccIdentityKeyAttrs);
    }
  }
  if (allBlindIdentityKeyAttrs.length > 0) {
    msg.overrideSenderHeader(
      X_IDENTITY_KEYS,
      "",
      ["v", "1"],
      ...visibleIdentityKeyAttrs,
      ...allBlindIdentityKeyAttrs
    );
  }
  return msg;
}
function putIdentityKeyAttr(address, resolvedAddresses, attrs) {
  const lookupResult = resolvedAddresses.get(address);
  if (!lookupResult)
    return void 0;
  if (lookupResult.identityKey == null)
    return void 0;
  const { identityKey, protocol } = lookupResult;
  const attrValue = `${encodeHexZeroX(publicKeyToBytes(identityKey))}:${protocol}`;
  const attr = [address, attrValue];
  attrs.push(attr);
  return attr;
}

export {
  createMimeMessage
};
