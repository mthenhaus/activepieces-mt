"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }// src/messagingKeys/verify.ts
var _encoding = require('@mailchain/encoding');





var _api = require('@mailchain/api');
var _keyreg = require('@mailchain/signatures/keyreg');





var _signatures = require('@mailchain/signatures');
var MessagingKeyVerifier = class {
  constructor(messagingKeysApi) {
    this.messagingKeysApi = messagingKeysApi;
  }
  static create(configuration) {
    return new MessagingKeyVerifier(_api.MessagingKeysApiFactory.call(void 0, _api.createAxiosConfiguration.call(void 0, configuration.apiPath)));
  }
  async verifyRegisteredKeyProof(registeredKeyProof, messagingKey) {
    if (!registeredKeyProof)
      throw new (0, _signatures.MessagingKeyVerificationError)();
    if (registeredKeyProof.signature == null)
      throw new (0, _signatures.MessagingKeyVerificationError)();
    const params = {
      AddressEncoding: registeredKeyProof.address.encoding,
      PublicKeyEncoding: registeredKeyProof.messagingKeyEncoding,
      Locale: registeredKeyProof.locale,
      Variant: registeredKeyProof.variant
    };
    const message = _keyreg.createProofMessage.call(void 0, 
      params,
      _api.getAddressFromApiResponse.call(void 0, registeredKeyProof.address),
      messagingKey,
      registeredKeyProof.nonce
    );
    const identityKey = _api.ApiKeyConvert.public(registeredKeyProof.identityKey);
    const isVerified = await _signatures.verify.call(void 0, 
      registeredKeyProof.signingMethod,
      identityKey,
      message,
      _encoding.decodeHexZeroX.call(void 0, registeredKeyProof.signature)
    );
    return {
      identityKey,
      result: isVerified
    };
  }
  async verifyProvidedKeyProof(providedKeyProof, messagingKey) {
    const mailchainPublicKeyResponse = await this.messagingKeysApi.getMailchainPublicKey();
    if (!_optionalChain([mailchainPublicKeyResponse, 'access', _ => _.data, 'access', _2 => _2.key, 'optionalAccess', _3 => _3.value]))
      throw new (0, _signatures.PublicKeyNotFoundError)();
    const mailchainPublicKey = _api.ApiKeyConvert.public(mailchainPublicKeyResponse.data.key);
    if (!providedKeyProof.signature)
      throw new (0, _signatures.MessagingKeyVerificationError)();
    return await _signatures.verifyMailchainProvidedMessagingKey.call(void 0, 
      mailchainPublicKey,
      messagingKey,
      _encoding.decodeHexZeroX.call(void 0, _optionalChain([providedKeyProof, 'optionalAccess', _4 => _4.signature])),
      providedKeyProof.address,
      providedKeyProof.protocol
    );
  }
};



exports.MessagingKeyVerifier = MessagingKeyVerifier;
