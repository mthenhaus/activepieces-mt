import {
  MailchainDIDMessagingKeyResolver
} from "./chunk-XMVSG5SQ.mjs";
import {
  mailchainAddressDecentralizedIdentifier
} from "./chunk-MDSHIXSD.mjs";
import {
  MessagingKeys
} from "./chunk-NK6CIHSE.mjs";
import {
  defaultConfiguration
} from "./chunk-TT2KNKAH.mjs";
import {
  ValidationError
} from "./chunk-6FVMZQ5S.mjs";

// src/verifiableCredentials/verifiableMailchainAddressOwner/verifier.ts
import { verifyPresentation } from "did-jwt-vc";
var VerificationError = class extends Error {
  constructor(cause) {
    super("presentation failed to verify", { cause });
  }
};
var MailchainAddressOwnershipVerifier = class {
  constructor(mailchainDidResolver, messagingKeys) {
    this.mailchainDidResolver = mailchainDidResolver;
    this.messagingKeys = messagingKeys;
  }
  static create(configuration = defaultConfiguration) {
    return new MailchainAddressOwnershipVerifier(
      MailchainDIDMessagingKeyResolver.create(configuration),
      MessagingKeys.create(configuration)
    );
  }
  async verifyMailchainAddressOwnership(params) {
    const { presentation, verifier, nonce, address, actions, resources } = params;
    const result = await verifyPresentation(presentation, this.mailchainDidResolver, {
      challenge: nonce,
      proofPurpose: "authentication",
      audience: mailchainAddressDecentralizedIdentifier(verifier)
    }).catch((e) => {
      return {
        verified: false,
        error: e
      };
    });
    if (!result.verified) {
      return { error: new VerificationError(result.error) };
    }
    const { verifiablePresentation } = result;
    if (verifiablePresentation.holder != mailchainAddressDecentralizedIdentifier(address)) {
      return {
        error: new ValidationError("verified presentation holder address does not match")
      };
    }
    if (!verifiablePresentation.verifiableCredential || verifiablePresentation.verifiableCredential.length === 0) {
      return {
        error: new ValidationError("verifiable credential not found")
      };
    }
    const mailchainMessagingKeyCredentials = verifiablePresentation.verifiableCredential.filter(
      (vc) => vc.type.some((x) => x === "MailchainMessagingKeyCredential") && vc.type.some((x) => x === "VerifiableCredential")
    );
    if (mailchainMessagingKeyCredentials.length === 0) {
      return {
        error: new ValidationError("missing MailchainMessagingKeyCredential")
      };
    }
    if (mailchainMessagingKeyCredentials.length !== 1) {
      return {
        error: new ValidationError("more than one MailchainMessagingKeyCredential found")
      };
    }
    const mailchainMessagingKeyCredential = mailchainMessagingKeyCredentials[0];
    const credentialSubjects = Object.keys(mailchainMessagingKeyCredential.credentialSubject).map(
      (key) => mailchainMessagingKeyCredential.credentialSubject[key]
    );
    if (credentialSubjects.length === 0) {
      return {
        error: new ValidationError("no credentialSubject found")
      };
    }
    if (!credentialSubjects.filter((subject) => Object.keys(subject).some((x) => x === "ownerOf")).some((subject) => {
      const { ownerOf } = subject;
      return ownerOf.type === "MailchainMessagingKey" && ownerOf.address === address;
    })) {
      return {
        error: new ValidationError("MailchainMessagingKey owner does not match supplied address")
      };
    }
    if (!mailchainMessagingKeyCredential.termsOfUse) {
      return {
        error: new ValidationError("termsOfUse not found")
      };
    }
    const verifyTermsOfUseError = verifyTermsOfUse(
      mailchainMessagingKeyCredential.termsOfUse,
      actions,
      resources,
      mailchainAddressDecentralizedIdentifier(address),
      mailchainAddressDecentralizedIdentifier(verifier)
    );
    if (verifyTermsOfUseError) {
      return { error: verifyTermsOfUseError };
    }
    const { data: resolvedAddress, error: resolverAddressError } = await this.messagingKeys.resolve(address);
    if (resolverAddressError) {
      return { error: resolverAddressError };
    }
    return { data: { ...result, resolvedAddress } };
  }
};
function verifyTermsOfUse(termsOfUse, requiredActions, requiredResources, requiredAssigner, requiredAssignee) {
  if (termsOfUse.length !== 1) {
    return new ValidationError("credential must contain exactly 1 termOfUse");
  }
  const term = termsOfUse[0];
  const { actions, resources, assignee, assigner } = term;
  if (!actions.includes("*") && !requiredActions.every((x) => actions.includes(x))) {
    return new ValidationError("not all required actions are met");
  }
  if (!resources.includes("*") && !requiredResources.every((x) => resources.includes(x))) {
    return new ValidationError("not all required resources are met");
  }
  if (assignee !== requiredAssignee) {
    return new ValidationError("termOfUse assignee incorrect");
  }
  if (assigner !== requiredAssigner) {
    return new ValidationError("termOfUse assigner incorrect");
  }
  return;
}

export {
  VerificationError,
  MailchainAddressOwnershipVerifier
};
