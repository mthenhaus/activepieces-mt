"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _chunk5ZVSPRLFjs = require('./chunk-5ZVSPRLF.js');


var _chunkMTKPWAB7js = require('./chunk-MTKPWAB7.js');


var _chunk5FSOOI2Gjs = require('./chunk-5FSOOI2G.js');


var _chunkESCCOX3Vjs = require('./chunk-ESCCOX3V.js');


var _chunkZKQAO77Pjs = require('./chunk-ZKQAO77P.js');


var _chunkRH2527U6js = require('./chunk-RH2527U6.js');

// src/sending/verifiablePresentationRequest/sender.ts
var _canonicalize = require('canonicalize'); var _canonicalize2 = _interopRequireDefault(_canonicalize);
var _signatures = require('@mailchain/signatures');
var _encoding = require('@mailchain/encoding');
var VerifiablePresentationRequestSender = class {
  constructor(senderMessagingKey, messagingKeys, payloadDistributor, senderVerifier) {
    this.senderMessagingKey = senderMessagingKey;
    this.messagingKeys = messagingKeys;
    this.payloadDistributor = payloadDistributor;
    this.senderVerifier = senderVerifier;
  }
  static fromSenderMessagingKey(senderMessagingKey, configuration = _chunkZKQAO77Pjs.defaultConfiguration) {
    return new VerifiablePresentationRequestSender(
      senderMessagingKey,
      _chunkESCCOX3Vjs.MessagingKeys.create(configuration),
      _chunk5ZVSPRLFjs.PayloadDistributor.create(configuration, senderMessagingKey),
      _chunk5FSOOI2Gjs.SenderVerifier.create(configuration)
    );
  }
  async sendVerifiablePresentationRequest(params) {
    const canonicalized = _canonicalize2.default.call(void 0, params);
    if (!canonicalized) {
      return {
        error: new (0, _chunkRH2527U6js.UnexpectedMailchainError)("unable to create payload to send")
      };
    }
    const { to, from } = params;
    const isSenderMatching = await this.senderVerifier.verifySenderOwnsFromAddress(
      from,
      this.senderMessagingKey.publicKey
    );
    if (!isSenderMatching) {
      return { error: new (0, _signatures.ProvidedMessagingKeyIncorrectError)("sender") };
    }
    const { data: resolvedAddresses, error: resolveAddressError } = await this.messagingKeys.resolveMany([
      from,
      to
    ]);
    if (resolveAddressError) {
      return { error: resolveAddressError };
    }
    const distribution = {
      recipients: [to],
      payload: await _chunkMTKPWAB7js.createPayload.call(void 0, 
        this.senderMessagingKey,
        _encoding.decodeUtf8.call(void 0, canonicalized),
        "application/vnd.mailchain.verified-credential-request"
      )
    };
    const { data: distributedMail, error: distributedMailError } = await this.payloadDistributor.distributePayload({
      distributions: [distribution],
      resolvedAddresses
    });
    if (distributedMailError) {
      return { error: distributedMailError };
    }
    return {
      data: {
        sentDeliveryRequests: distributedMail
      }
    };
  }
};



exports.VerifiablePresentationRequestSender = VerifiablePresentationRequestSender;
