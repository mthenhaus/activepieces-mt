import {
  combineMigrations
} from "./chunk-AYRU4OE4.mjs";
import {
  IdentityKeys
} from "./chunk-7AQ4G6HT.mjs";

// src/mailbox/migrations.ts
import { publicKeyToBytes } from "@mailchain/crypto";
import { ED25519PublicKey, ED25519PublicKeyLen } from "@mailchain/crypto/ed25519";
import { SECP256K1PublicKey, SECP256K1PublicKeyLength } from "@mailchain/crypto/secp256k1/public";
import { isMailchainAccountAddress, parseNameServiceAddress } from "@mailchain/addressing";

// src/protobuf/inbox/inbox.js
import $protobuf from "protobufjs/minimal.js";
var $Reader = $protobuf.Reader;
var $Writer = $protobuf.Writer;
var $util = $protobuf.util;
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
var preview = $root.preview = (() => {
  const preview2 = {};
  preview2.MessagePreview = function() {
    function MessagePreview(properties) {
      this.to = [];
      this.cc = [];
      this.bcc = [];
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    MessagePreview.prototype.from = "";
    MessagePreview.prototype.subject = "";
    MessagePreview.prototype.snippet = "";
    MessagePreview.prototype.hasAttachment = false;
    MessagePreview.prototype.timestamp = 0;
    MessagePreview.prototype.to = $util.emptyArray;
    MessagePreview.prototype.cc = $util.emptyArray;
    MessagePreview.prototype.bcc = $util.emptyArray;
    MessagePreview.prototype.owner = "";
    MessagePreview.prototype.mailbox = $util.newBuffer([]);
    MessagePreview.create = function create(properties) {
      return new MessagePreview(properties);
    };
    MessagePreview.encode = function encode(message, writer) {
      if (!writer)
        writer = $Writer.create();
      if (message.from != null && Object.hasOwnProperty.call(message, "from"))
        writer.uint32(
          /* id 1, wireType 2 =*/
          10
        ).string(message.from);
      if (message.subject != null && Object.hasOwnProperty.call(message, "subject"))
        writer.uint32(
          /* id 2, wireType 2 =*/
          18
        ).string(message.subject);
      if (message.snippet != null && Object.hasOwnProperty.call(message, "snippet"))
        writer.uint32(
          /* id 3, wireType 2 =*/
          26
        ).string(message.snippet);
      if (message.hasAttachment != null && Object.hasOwnProperty.call(message, "hasAttachment"))
        writer.uint32(
          /* id 4, wireType 0 =*/
          32
        ).bool(message.hasAttachment);
      if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
        writer.uint32(
          /* id 5, wireType 0 =*/
          40
        ).int32(message.timestamp);
      if (message.to != null && message.to.length)
        for (let i = 0; i < message.to.length; ++i)
          writer.uint32(
            /* id 6, wireType 2 =*/
            50
          ).string(message.to[i]);
      if (message.cc != null && message.cc.length)
        for (let i = 0; i < message.cc.length; ++i)
          writer.uint32(
            /* id 7, wireType 2 =*/
            58
          ).string(message.cc[i]);
      if (message.bcc != null && message.bcc.length)
        for (let i = 0; i < message.bcc.length; ++i)
          writer.uint32(
            /* id 8, wireType 2 =*/
            66
          ).string(message.bcc[i]);
      if (message.owner != null && Object.hasOwnProperty.call(message, "owner"))
        writer.uint32(
          /* id 9, wireType 2 =*/
          74
        ).string(message.owner);
      if (message.mailbox != null && Object.hasOwnProperty.call(message, "mailbox"))
        writer.uint32(
          /* id 10, wireType 2 =*/
          82
        ).bytes(message.mailbox);
      return writer;
    };
    MessagePreview.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };
    MessagePreview.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader))
        reader = $Reader.create(reader);
      let end = length === void 0 ? reader.len : reader.pos + length, message = new $root.preview.MessagePreview();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            message.from = reader.string();
            break;
          }
          case 2: {
            message.subject = reader.string();
            break;
          }
          case 3: {
            message.snippet = reader.string();
            break;
          }
          case 4: {
            message.hasAttachment = reader.bool();
            break;
          }
          case 5: {
            message.timestamp = reader.int32();
            break;
          }
          case 6: {
            if (!(message.to && message.to.length))
              message.to = [];
            message.to.push(reader.string());
            break;
          }
          case 7: {
            if (!(message.cc && message.cc.length))
              message.cc = [];
            message.cc.push(reader.string());
            break;
          }
          case 8: {
            if (!(message.bcc && message.bcc.length))
              message.bcc = [];
            message.bcc.push(reader.string());
            break;
          }
          case 9: {
            message.owner = reader.string();
            break;
          }
          case 10: {
            message.mailbox = reader.bytes();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    MessagePreview.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader))
        reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };
    MessagePreview.verify = function verify(message) {
      if (typeof message !== "object" || message === null)
        return "object expected";
      if (message.from != null && message.hasOwnProperty("from")) {
        if (!$util.isString(message.from))
          return "from: string expected";
      }
      if (message.subject != null && message.hasOwnProperty("subject")) {
        if (!$util.isString(message.subject))
          return "subject: string expected";
      }
      if (message.snippet != null && message.hasOwnProperty("snippet")) {
        if (!$util.isString(message.snippet))
          return "snippet: string expected";
      }
      if (message.hasAttachment != null && message.hasOwnProperty("hasAttachment")) {
        if (typeof message.hasAttachment !== "boolean")
          return "hasAttachment: boolean expected";
      }
      if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
        if (!$util.isInteger(message.timestamp))
          return "timestamp: integer expected";
      }
      if (message.to != null && message.hasOwnProperty("to")) {
        if (!Array.isArray(message.to))
          return "to: array expected";
        for (let i = 0; i < message.to.length; ++i)
          if (!$util.isString(message.to[i]))
            return "to: string[] expected";
      }
      if (message.cc != null && message.hasOwnProperty("cc")) {
        if (!Array.isArray(message.cc))
          return "cc: array expected";
        for (let i = 0; i < message.cc.length; ++i)
          if (!$util.isString(message.cc[i]))
            return "cc: string[] expected";
      }
      if (message.bcc != null && message.hasOwnProperty("bcc")) {
        if (!Array.isArray(message.bcc))
          return "bcc: array expected";
        for (let i = 0; i < message.bcc.length; ++i)
          if (!$util.isString(message.bcc[i]))
            return "bcc: string[] expected";
      }
      if (message.owner != null && message.hasOwnProperty("owner")) {
        if (!$util.isString(message.owner))
          return "owner: string expected";
      }
      if (message.mailbox != null && message.hasOwnProperty("mailbox")) {
        if (!(message.mailbox && typeof message.mailbox.length === "number" || $util.isString(message.mailbox)))
          return "mailbox: buffer expected";
      }
      return null;
    };
    MessagePreview.fromObject = function fromObject(object) {
      if (object instanceof $root.preview.MessagePreview)
        return object;
      let message = new $root.preview.MessagePreview();
      if (object.from != null)
        message.from = String(object.from);
      if (object.subject != null)
        message.subject = String(object.subject);
      if (object.snippet != null)
        message.snippet = String(object.snippet);
      if (object.hasAttachment != null)
        message.hasAttachment = Boolean(object.hasAttachment);
      if (object.timestamp != null)
        message.timestamp = object.timestamp | 0;
      if (object.to) {
        if (!Array.isArray(object.to))
          throw TypeError(".preview.MessagePreview.to: array expected");
        message.to = [];
        for (let i = 0; i < object.to.length; ++i)
          message.to[i] = String(object.to[i]);
      }
      if (object.cc) {
        if (!Array.isArray(object.cc))
          throw TypeError(".preview.MessagePreview.cc: array expected");
        message.cc = [];
        for (let i = 0; i < object.cc.length; ++i)
          message.cc[i] = String(object.cc[i]);
      }
      if (object.bcc) {
        if (!Array.isArray(object.bcc))
          throw TypeError(".preview.MessagePreview.bcc: array expected");
        message.bcc = [];
        for (let i = 0; i < object.bcc.length; ++i)
          message.bcc[i] = String(object.bcc[i]);
      }
      if (object.owner != null)
        message.owner = String(object.owner);
      if (object.mailbox != null) {
        if (typeof object.mailbox === "string")
          $util.base64.decode(object.mailbox, message.mailbox = $util.newBuffer($util.base64.length(object.mailbox)), 0);
        else if (object.mailbox.length >= 0)
          message.mailbox = object.mailbox;
      }
      return message;
    };
    MessagePreview.toObject = function toObject(message, options) {
      if (!options)
        options = {};
      let object = {};
      if (options.arrays || options.defaults) {
        object.to = [];
        object.cc = [];
        object.bcc = [];
      }
      if (options.defaults) {
        object.from = "";
        object.subject = "";
        object.snippet = "";
        object.hasAttachment = false;
        object.timestamp = 0;
        object.owner = "";
        if (options.bytes === String)
          object.mailbox = "";
        else {
          object.mailbox = [];
          if (options.bytes !== Array)
            object.mailbox = $util.newBuffer(object.mailbox);
        }
      }
      if (message.from != null && message.hasOwnProperty("from"))
        object.from = message.from;
      if (message.subject != null && message.hasOwnProperty("subject"))
        object.subject = message.subject;
      if (message.snippet != null && message.hasOwnProperty("snippet"))
        object.snippet = message.snippet;
      if (message.hasAttachment != null && message.hasOwnProperty("hasAttachment"))
        object.hasAttachment = message.hasAttachment;
      if (message.timestamp != null && message.hasOwnProperty("timestamp"))
        object.timestamp = message.timestamp;
      if (message.to && message.to.length) {
        object.to = [];
        for (let j = 0; j < message.to.length; ++j)
          object.to[j] = message.to[j];
      }
      if (message.cc && message.cc.length) {
        object.cc = [];
        for (let j = 0; j < message.cc.length; ++j)
          object.cc[j] = message.cc[j];
      }
      if (message.bcc && message.bcc.length) {
        object.bcc = [];
        for (let j = 0; j < message.bcc.length; ++j)
          object.bcc[j] = message.bcc[j];
      }
      if (message.owner != null && message.hasOwnProperty("owner"))
        object.owner = message.owner;
      if (message.mailbox != null && message.hasOwnProperty("mailbox"))
        object.mailbox = options.bytes === String ? $util.base64.encode(message.mailbox, 0, message.mailbox.length) : options.bytes === Array ? Array.prototype.slice.call(message.mailbox) : message.mailbox;
      return object;
    };
    MessagePreview.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    MessagePreview.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/preview.MessagePreview";
    };
    return MessagePreview;
  }();
  return preview2;
})();

// src/mailbox/migrations.ts
function getAllMessagePreviewMigrations(sdkConfig) {
  const identityKeys = IdentityKeys.create(sdkConfig);
  return combineMigrations(createV2IdentityKey(identityKeys), createV3EncodeIdentityKey());
}
function createV2IdentityKey(identityKeys) {
  return {
    shouldApply: (data) => Promise.resolve(data.version === 1),
    apply: async (data) => {
      const result = await identityKeys.getAddressIdentityKey(parseNameServiceAddress(data.messagePreview.owner));
      if (result == null)
        throw new Error(`no identity key found for [${data.messagePreview.owner}], failed message migration`);
      return {
        version: 2,
        messagePreview: preview.MessagePreview.create({
          ...data.messagePreview,
          mailbox: result.identityKey.bytes
        })
      };
    }
  };
}
function createV3EncodeIdentityKey() {
  return {
    shouldApply: (data) => Promise.resolve(data.version === 2),
    apply: async (data) => {
      const { messagePreview } = data;
      const owner = parseNameServiceAddress(messagePreview.owner);
      let mailboxIdentityKey = null;
      if (messagePreview.mailbox.length === ED25519PublicKeyLen && isMailchainAccountAddress(owner)) {
        mailboxIdentityKey = new ED25519PublicKey(messagePreview.mailbox);
      } else if (messagePreview.mailbox.length === SECP256K1PublicKeyLength) {
        mailboxIdentityKey = new SECP256K1PublicKey(messagePreview.mailbox);
      }
      if (mailboxIdentityKey == null)
        throw new Error(`failed message migration, failed mailbox identity key resolution`);
      return {
        version: 3,
        messagePreview: preview.MessagePreview.create({
          ...messagePreview,
          mailbox: publicKeyToBytes(mailboxIdentityKey)
        })
      };
    }
  };
}

export {
  preview,
  getAllMessagePreviewMigrations,
  createV2IdentityKey,
  createV3EncodeIdentityKey
};
