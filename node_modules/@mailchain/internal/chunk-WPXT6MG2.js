"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }// src/transport/mailer/content.ts
var _crypto = require('@mailchain/crypto');
var _encoding = require('@mailchain/encoding');
var _canonicalize = require('canonicalize'); var _canonicalize2 = _interopRequireDefault(_canonicalize);
function createContentBuffer(content) {
  const canonicalized = _canonicalize2.default.call(void 0, {
    authorMessagingKey: _encoding.encodeHex.call(void 0, _crypto.publicKeyToBytes.call(void 0, content.authorMessagingKey)),
    contentUri: content.contentUri,
    date: Math.round(content.date.getTime()),
    authorMailAddress: content.authorMailAddress.address,
    mailerProof: {
      params: {
        authorContentSignature: _encoding.encodeHex.call(void 0, content.mailerProof.params.authorContentSignature),
        expires: Math.round(content.mailerProof.params.expires.getTime()),
        mailerMessagingKey: _encoding.encodeHex.call(void 0, _crypto.publicKeyToBytes.call(void 0, content.mailerProof.params.mailerMessagingKey))
      },
      signature: _encoding.encodeHex.call(void 0, content.mailerProof.signature),
      version: content.mailerProof.version
    },
    messageId: content.messageId,
    to: content.to.map((recipient) => recipient.address),
    version: content.version
  });
  if (!canonicalized) {
    throw new Error("content could not be canonicalized");
  }
  return canonicalized;
}
function parseMailerContentFromJSON(content) {
  const rawMailerContent = JSON.parse(content);
  if (!rawMailerContent.mailerProof) {
    throw new Error("mailerProof is required");
  }
  if (!rawMailerContent.mailerProof.params) {
    throw new Error("mailerProof.params is required");
  }
  if (rawMailerContent.mailerProof.params.authorContentSignature === "") {
    throw new Error("authorContentSignature is required");
  }
  const authorContentSignature = _encoding.decodeHex.call(void 0, rawMailerContent.mailerProof.params.authorContentSignature);
  if (rawMailerContent.authorMessagingKey === "") {
    throw new Error("authorMessagingKey is required");
  }
  const authorMessagingKey = _crypto.publicKeyFromBytes.call(void 0, _encoding.decodeHex.call(void 0, rawMailerContent.authorMessagingKey));
  return {
    authorMessagingKey,
    contentUri: rawMailerContent.contentUri,
    date: new Date(rawMailerContent.date),
    authorMailAddress: { address: rawMailerContent.authorMailAddress, name: "" },
    to: rawMailerContent.to.map((address) => ({ address, name: "" })),
    mailerProof: {
      params: {
        expires: new Date(rawMailerContent.mailerProof.params.expires),
        mailerMessagingKey: _crypto.publicKeyFromBytes.call(void 0, 
          _encoding.decodeHex.call(void 0, rawMailerContent.mailerProof.params.mailerMessagingKey)
        ),
        authorContentSignature
      },
      signature: _encoding.decodeHex.call(void 0, rawMailerContent.mailerProof.signature),
      version: rawMailerContent.version
    },
    messageId: rawMailerContent.messageId,
    version: rawMailerContent.version
  };
}




exports.createContentBuffer = createContentBuffer; exports.parseMailerContentFromJSON = parseMailerContentFromJSON;
