import { InboxApiInterface } from '@mailchain/api';
import { InboxKey, KeyRing } from '@mailchain/keyring';
import { Configuration } from './configuration.js';
import { ParseMimeTextResult } from './formatters/parse.js';
import { MessagePreview, Message, MessagesOverview, SystemMessageLabel, UserMessageLabel } from './mailbox/types.js';
import { MailboxRuleCondition, MailboxRuleAction, MailboxRule } from './mailboxRuleEngine/rule.js';
import { IdentityKeys } from './identityKeys/identityKeys.js';
import { Payload } from './transport/payload/payload.js';
import { MailData } from './transport/mail/types.js';
import { UserMailbox } from './user/types.js';
import { AddressesHasher } from './mailbox/addressHasher.js';
import { MessageCrypto } from './mailbox/messageCrypto.js';
import { MessageIdCreator } from './mailbox/messageId.js';
import { MessageMailboxOwnerMatcher } from './mailbox/messageMailboxOwnerMatcher.js';
import { MessagePreviewMigrationRule } from './mailbox/migrations.js';
import { UserMailboxHasher } from './mailbox/userMailboxHasher.js';

type ConditionHandler = {
    /** ID of the condition handler. Used to identify the handler and make sure no duplicate handlers are being run. */
    id: string;
    /**
     * Try to execute the condition. Return true if the condition applies to the message.
     *
     * @param params The message to apply rules to
     * @param condition The condition to check
     * @param checkCondition function to run the condition runner on a condition. Useful for nested conditions (ex: OR operator).
     */
    execute: (params: RuleApplyParams, condition: MailboxRuleCondition<unknown>, checkCondition: (condition: MailboxRuleCondition<unknown>) => Promise<boolean>) => Promise<boolean>;
};
/**
 * Check if the condition applies to the message.
 *
 * @param params The message to apply rules to
 * @param condition The condition to check
 * @param conditionHandlers The list of condition handlers to use to check the condition.
 * @returns true if the condition applies to the message
 */
declare function conditionsRunner(params: RuleApplyParams, condition: MailboxRuleCondition<unknown>, conditionHandlers: ConditionHandler[]): Promise<boolean>;
/**
 * Handler for condition `ConditionIsFrom` that checks if the message is from the given address.
 */
declare const conditionIsFromAddressHandler: ConditionHandler;
/**
 * Create a handler for condition `ConditionIsFrom` that checks if the message is from the given identity.
 */
declare function createConditionIsFromIdentityHandler(identityKeys: IdentityKeys): ConditionHandler;
/**
 * Handler for condition `ConditionOperationOr` that checks if any of the conditions in the list applies.
 */
declare const conditionOperationOrHandler: ConditionHandler;
/**
 * Handler for condition `ConditionOperationAnd` that checks if all of the conditions in the list applies.
 */
declare const conditionOperationAndHandler: ConditionHandler;
/**
 * Handler for condition `ConditionOperationNot` that checks if the condition does not apply.
 */
declare const conditionOperationNotHandler: ConditionHandler;
declare function defaultConditionHandlers(sdkConfig: Configuration): ConditionHandler[];

type ActionHandler = {
    /** ID of the action handler. Used to identify the handler and make sure no duplicate handlers are being run. */
    id: string;
    /**
     * Try to execute the action. Regardless if the action handler applies to the action or not, it returns the params (potentially changed).
     */
    execute: (params: RuleApplyParams, action: MailboxRuleAction<unknown>) => Promise<RuleApplyParams>;
};
/**
 * Apply actions to a message.
 * Actions are applied in order.
 *
 * @param params The message to apply actions to
 * @param action The action to apply
 * @param actionHandlers The action handlers responsible for applying the actions
 * @returns The message with actions applied
 */
declare function actionsRunner(params: RuleApplyParams, actions: MailboxRuleAction<unknown>[], actionHandlers: ActionHandler[]): Promise<RuleApplyParams>;
/**
 * Create an action handler that adds a system label.
 *
 * @param mailboxOperations Mailbox operations to use when applying the action
 * @returns The action handler
 */
declare function createAddSystemLabelActionHandler(mailboxOperations: MailboxOperations): ActionHandler;
/**
 * Create an action handler that removes a system label.
 *
 * @param mailboxOperations Mailbox operations to use when applying the action
 * @returns The action handler
 */
declare function createRemoveSystemLabelActionHandler(mailboxOperations: MailboxOperations): ActionHandler;
declare function defaultActionHandlers(mailboxOperations: MailboxOperations): ActionHandler[];

type RuleApplyParams = {
    message: MessagePreview;
};
type RulesSource = () => Promise<MailboxRule<unknown, unknown>[]>;
/**
 * Rule engine that applies rules to messages.
 */
declare class MailboxRuleEngine {
    private readonly rulesSource;
    private readonly _conditionHandlers;
    private readonly _actionHandlers;
    constructor(rulesSource: RulesSource);
    static create(rulesSource: RulesSource): MailboxRuleEngine;
    /**
     * Add a condition handler to the rule engine. Existing handlers with the same id will be replaced by the new handler.
     */
    addConditionHandler(...handlers: ConditionHandler[]): void;
    /**
     * Add an action handler to the rule engine. Existing handlers with the same id will be replaced by the new handler.
     */
    addActionHandler(...handlers: ActionHandler[]): void;
    /**
     * Apply rules to a message.
     * Rules are applied in order.
     * If a rule applies, the message is modified and the next rule is applied.
     * If no rules apply, the message is returned unmodified.
     *
     * @param params The message to apply rules to
     * @returns The message with rules applied
     */
    apply(params: RuleApplyParams): Promise<RuleApplyParams>;
    /**
     * Apply a single mailbox rule to a message. If the rule applies, the message is modified.
     *
     * @param params The message to apply rules to
     * @param rule The rule to apply
     * @returns The message with rule applied
     */
    private mailboxRuleHandler;
}

type GetMessagesViewParams = {
    offset: number;
    limit: number;
    userMailboxes: UserMailbox[] | 'all';
};
type SaveSentMessageParam = {
    /** The {@link UserMailbox} that is sending this message */
    userMailbox: UserMailbox;
    payload: Payload;
    content: MailData;
};
type SaveReceivedMessageParam = {
    /** The {@link UserMailbox} that is receiving this message */
    userMailbox: UserMailbox;
    receivedTransportPayload: Payload;
};
interface MailboxOperations {
    /** Get {@link MessagePreview} for a single message. */
    getMessage(messageId: string): Promise<MessagePreview>;
    /** Get messages from the Inbox folder (with INBOX label) */
    getInboxMessages(params?: GetMessagesViewParams): Promise<MessagePreview[]>;
    /** Get messages from the Starred folder (with STARRED label) */
    getStarredMessages(params?: GetMessagesViewParams): Promise<MessagePreview[]>;
    /** Get messages from the Trash folder (with TRASH label) */
    getTrashMessages(params?: GetMessagesViewParams): Promise<MessagePreview[]>;
    /** Get messages from the Unread folder (without READ label) */
    getUnreadMessages(params?: GetMessagesViewParams): Promise<MessagePreview[]>;
    /** Get messages from the Send folder (with SEND label) */
    getSentMessages(params?: GetMessagesViewParams): Promise<MessagePreview[]>;
    /** Get messages from the Outbox folder */
    getOutboxMessages(params?: GetMessagesViewParams): Promise<MessagePreview[]>;
    /** Get messages from the Archived folder (with ARCHIVED label) */
    getArchivedMessages(params?: GetMessagesViewParams): Promise<MessagePreview[]>;
    /** Get messages from the Spam folder (with SPAM label). Warn: This feature is still in development, is is not stable for usage. */
    getSpamMessages_unstable(params?: GetMessagesViewParams): Promise<MessagePreview[]>;
    /**  Get overview of mailboxes*/
    /** Get the full contents of the single message for the provided ID (same as the {@link MessagePreview.id}) */
    getFullMessage(messageId: string): Promise<Message>;
    getMessagesOverview(mailboxes: UserMailbox[]): Promise<MessagesOverview>;
    /**
     * Save the send message
     *
     * Note: initially the message is put into Outbox folder and needs to me marked as send via {@link MailboxOperations.markOutboxMessageAsSent}
     */
    saveSentMessage(message: SaveSentMessageParam): Promise<MessagePreview>;
    /** Save the received message. */
    saveReceivedMessage(message: SaveReceivedMessageParam): Promise<[MessagePreview, ...MessagePreview[]]>;
    markOutboxMessageAsSent(messageId: string): Promise<void>;
    modifyArchiveMessage(messageId: string, archived: boolean): Promise<void>;
    modifyIsReadMessage(messageId: string, isRead: boolean): Promise<void>;
    modifyTrashMessage(messageId: string, trash: boolean): Promise<void>;
    modifyStarredMessage(messageId: string, isStarred: boolean): Promise<void>;
    modifySystemLabel(messageId: string, systemLabel: SystemMessageLabel, include: boolean): Promise<void>;
    /**  Warn: This feature is still in development, is is not stable for usage. */
    modifySpamMessage_unstable(messageId: string, isSpam: boolean): Promise<void>;
    modifyUserLabel(messageId: string, userLabel: UserMessageLabel, include: boolean): Promise<void>;
}
declare class MailchainMailboxOperations implements MailboxOperations {
    private readonly inboxApi;
    /** Cryptography service for encrypting the message preview content when the message is being saved. It is decrypting the same content when the message preview is being read. */
    private readonly messagePreviewCrypto;
    /** Cryptography service for encrypting the full message content when the message is being saved. It is decrypting the same content when the message is being read. */
    private readonly messageCrypto;
    /** Service for matching the user mailboxes to the message recipients. The case could be that single message send to a single identity belongs to multiple mailbox aliases. */
    private readonly messageMailboxOwnerMatcher;
    /** Hasher for the addresses of the participants in a given message. Used for hashing each of the participants so at later stage the user is able to use the hashed address to search for messages without reveling the real address that is being searched for. */
    private readonly addressHasher;
    /** Create the message ID for when send and received messages are saved. It is used to create a unique ID for a given message parameters. Using same parameters will yield the same message ID. */
    private readonly messageIdCreator;
    /** Hasher for the user mailbox for when send and received messages are saved. It obfuscates the real user mailbox (identity key) in order to increase user privacy. */
    private readonly userMailboxHasher;
    /** Random time offset that will be added to the message timestamps in order to obfuscate the time when the message was sent/received in order to increase user privacy. */
    private readonly messageDateOffset;
    private readonly migration;
    /** The {@link MailboxRuleEngine} is used to apply rules to received messages (ex. message filtering) when they are saved. If `null`, no rules will be applied and this step is skipped. */
    private readonly ruleEngine;
    constructor(inboxApi: InboxApiInterface, 
    /** Cryptography service for encrypting the message preview content when the message is being saved. It is decrypting the same content when the message preview is being read. */
    messagePreviewCrypto: InboxKey, 
    /** Cryptography service for encrypting the full message content when the message is being saved. It is decrypting the same content when the message is being read. */
    messageCrypto: MessageCrypto, 
    /** Service for matching the user mailboxes to the message recipients. The case could be that single message send to a single identity belongs to multiple mailbox aliases. */
    messageMailboxOwnerMatcher: MessageMailboxOwnerMatcher, 
    /** Hasher for the addresses of the participants in a given message. Used for hashing each of the participants so at later stage the user is able to use the hashed address to search for messages without reveling the real address that is being searched for. */
    addressHasher: AddressesHasher, 
    /** Create the message ID for when send and received messages are saved. It is used to create a unique ID for a given message parameters. Using same parameters will yield the same message ID. */
    messageIdCreator: MessageIdCreator, 
    /** Hasher for the user mailbox for when send and received messages are saved. It obfuscates the real user mailbox (identity key) in order to increase user privacy. */
    userMailboxHasher: UserMailboxHasher, 
    /** Random time offset that will be added to the message timestamps in order to obfuscate the time when the message was sent/received in order to increase user privacy. */
    messageDateOffset: number, migration: MessagePreviewMigrationRule, 
    /** The {@link MailboxRuleEngine} is used to apply rules to received messages (ex. message filtering) when they are saved. If `null`, no rules will be applied and this step is skipped. */
    ruleEngine: MailboxRuleEngine | null);
    static create(sdkConfig: Configuration, keyRing: KeyRing, mailboxRuleEngine: MailboxRuleEngine | null): MailboxOperations;
    getMessage(messageId: string): Promise<MessagePreview>;
    getInboxMessages(params?: GetMessagesViewParams): Promise<MessagePreview[]>;
    getStarredMessages(params?: GetMessagesViewParams): Promise<MessagePreview[]>;
    getTrashMessages(params?: GetMessagesViewParams): Promise<MessagePreview[]>;
    getUnreadMessages(params?: GetMessagesViewParams): Promise<MessagePreview[]>;
    getSentMessages(params?: GetMessagesViewParams): Promise<MessagePreview[]>;
    getOutboxMessages(params?: GetMessagesViewParams): Promise<MessagePreview[]>;
    getArchivedMessages(params?: GetMessagesViewParams): Promise<MessagePreview[]>;
    getSpamMessages_unstable(params?: GetMessagesViewParams): Promise<MessagePreview[]>;
    private getMessagesInView;
    private handleMessagePreviews;
    private handleMessagePreview;
    getFullMessage(messageId: string): Promise<Message>;
    getMessagesOverview(mailboxes: UserMailbox[]): Promise<MessagesOverview>;
    saveSentMessage(params: SaveSentMessageParam): Promise<MessagePreview>;
    extractPayloadInfo(payload: Payload): Promise<ParseMimeTextResult>;
    saveReceivedMessage({ userMailbox, receivedTransportPayload, }: SaveReceivedMessageParam): Promise<[MessagePreview, ...MessagePreview[]]>;
    private saveMessage;
    markOutboxMessageAsSent(messageId: string): Promise<void>;
    modifyArchiveMessage(messageId: string, archived: boolean): Promise<void>;
    modifyIsReadMessage(messageId: string, isRead: boolean): Promise<void>;
    modifyTrashMessage(messageId: string, trash: boolean): Promise<void>;
    modifyStarredMessage(messageId: string, isStarred: boolean): Promise<void>;
    modifySpamMessage_unstable(messageId: string, isSpam: boolean): Promise<void>;
    modifySystemLabel(messageId: string, systemLabel: SystemMessageLabel, include: boolean): Promise<void>;
    modifyUserLabel(messageId: string, userLabel: UserMessageLabel, include: boolean): Promise<void>;
}

export { ActionHandler as A, ConditionHandler as C, GetMessagesViewParams as G, MailboxRuleEngine as M, RuleApplyParams as R, RulesSource as a, MailboxOperations as b, conditionsRunner as c, conditionIsFromAddressHandler as d, createConditionIsFromIdentityHandler as e, conditionOperationOrHandler as f, conditionOperationAndHandler as g, conditionOperationNotHandler as h, defaultConditionHandlers as i, actionsRunner as j, createAddSystemLabelActionHandler as k, createRemoveSystemLabelActionHandler as l, defaultActionHandlers as m, MailchainMailboxOperations as n };
