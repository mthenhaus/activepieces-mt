// src/protobuf/protocol/protocol.js
import $protobuf from "protobufjs/minimal.js";
var $Reader = $protobuf.Reader;
var $Writer = $protobuf.Writer;
var $util = $protobuf.util;
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
var protocol = $root.protocol = (() => {
  const protocol2 = {};
  protocol2.ECDHKeyBundle = function() {
    function ECDHKeyBundle(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    ECDHKeyBundle.prototype.publicEphemeralKey = $util.newBuffer([]);
    ECDHKeyBundle.prototype.publicMessagingKey = $util.newBuffer([]);
    ECDHKeyBundle.create = function create(properties) {
      return new ECDHKeyBundle(properties);
    };
    ECDHKeyBundle.encode = function encode(message, writer) {
      if (!writer)
        writer = $Writer.create();
      if (message.publicEphemeralKey != null && Object.hasOwnProperty.call(message, "publicEphemeralKey"))
        writer.uint32(
          /* id 1, wireType 2 =*/
          10
        ).bytes(message.publicEphemeralKey);
      if (message.publicMessagingKey != null && Object.hasOwnProperty.call(message, "publicMessagingKey"))
        writer.uint32(
          /* id 2, wireType 2 =*/
          18
        ).bytes(message.publicMessagingKey);
      return writer;
    };
    ECDHKeyBundle.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };
    ECDHKeyBundle.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader))
        reader = $Reader.create(reader);
      let end = length === void 0 ? reader.len : reader.pos + length, message = new $root.protocol.ECDHKeyBundle();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            message.publicEphemeralKey = reader.bytes();
            break;
          }
          case 2: {
            message.publicMessagingKey = reader.bytes();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    ECDHKeyBundle.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader))
        reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };
    ECDHKeyBundle.verify = function verify(message) {
      if (typeof message !== "object" || message === null)
        return "object expected";
      if (message.publicEphemeralKey != null && message.hasOwnProperty("publicEphemeralKey")) {
        if (!(message.publicEphemeralKey && typeof message.publicEphemeralKey.length === "number" || $util.isString(message.publicEphemeralKey)))
          return "publicEphemeralKey: buffer expected";
      }
      if (message.publicMessagingKey != null && message.hasOwnProperty("publicMessagingKey")) {
        if (!(message.publicMessagingKey && typeof message.publicMessagingKey.length === "number" || $util.isString(message.publicMessagingKey)))
          return "publicMessagingKey: buffer expected";
      }
      return null;
    };
    ECDHKeyBundle.fromObject = function fromObject(object) {
      if (object instanceof $root.protocol.ECDHKeyBundle)
        return object;
      let message = new $root.protocol.ECDHKeyBundle();
      if (object.publicEphemeralKey != null) {
        if (typeof object.publicEphemeralKey === "string")
          $util.base64.decode(object.publicEphemeralKey, message.publicEphemeralKey = $util.newBuffer($util.base64.length(object.publicEphemeralKey)), 0);
        else if (object.publicEphemeralKey.length >= 0)
          message.publicEphemeralKey = object.publicEphemeralKey;
      }
      if (object.publicMessagingKey != null) {
        if (typeof object.publicMessagingKey === "string")
          $util.base64.decode(object.publicMessagingKey, message.publicMessagingKey = $util.newBuffer($util.base64.length(object.publicMessagingKey)), 0);
        else if (object.publicMessagingKey.length >= 0)
          message.publicMessagingKey = object.publicMessagingKey;
      }
      return message;
    };
    ECDHKeyBundle.toObject = function toObject(message, options) {
      if (!options)
        options = {};
      let object = {};
      if (options.defaults) {
        if (options.bytes === String)
          object.publicEphemeralKey = "";
        else {
          object.publicEphemeralKey = [];
          if (options.bytes !== Array)
            object.publicEphemeralKey = $util.newBuffer(object.publicEphemeralKey);
        }
        if (options.bytes === String)
          object.publicMessagingKey = "";
        else {
          object.publicMessagingKey = [];
          if (options.bytes !== Array)
            object.publicMessagingKey = $util.newBuffer(object.publicMessagingKey);
        }
      }
      if (message.publicEphemeralKey != null && message.hasOwnProperty("publicEphemeralKey"))
        object.publicEphemeralKey = options.bytes === String ? $util.base64.encode(message.publicEphemeralKey, 0, message.publicEphemeralKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicEphemeralKey) : message.publicEphemeralKey;
      if (message.publicMessagingKey != null && message.hasOwnProperty("publicMessagingKey"))
        object.publicMessagingKey = options.bytes === String ? $util.base64.encode(message.publicMessagingKey, 0, message.publicMessagingKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicMessagingKey) : message.publicMessagingKey;
      return object;
    };
    ECDHKeyBundle.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    ECDHKeyBundle.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/protocol.ECDHKeyBundle";
    };
    return ECDHKeyBundle;
  }();
  protocol2.X3DHKeyBundle = function() {
    function X3DHKeyBundle(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    X3DHKeyBundle.prototype.keyExchangeMethod = 0;
    X3DHKeyBundle.prototype.publicMessagingKey = $util.newBuffer([]);
    X3DHKeyBundle.create = function create(properties) {
      return new X3DHKeyBundle(properties);
    };
    X3DHKeyBundle.encode = function encode(message, writer) {
      if (!writer)
        writer = $Writer.create();
      if (message.keyExchangeMethod != null && Object.hasOwnProperty.call(message, "keyExchangeMethod"))
        writer.uint32(
          /* id 1, wireType 0 =*/
          8
        ).int32(message.keyExchangeMethod);
      if (message.publicMessagingKey != null && Object.hasOwnProperty.call(message, "publicMessagingKey"))
        writer.uint32(
          /* id 2, wireType 2 =*/
          18
        ).bytes(message.publicMessagingKey);
      return writer;
    };
    X3DHKeyBundle.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };
    X3DHKeyBundle.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader))
        reader = $Reader.create(reader);
      let end = length === void 0 ? reader.len : reader.pos + length, message = new $root.protocol.X3DHKeyBundle();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            message.keyExchangeMethod = reader.int32();
            break;
          }
          case 2: {
            message.publicMessagingKey = reader.bytes();
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    X3DHKeyBundle.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader))
        reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };
    X3DHKeyBundle.verify = function verify(message) {
      if (typeof message !== "object" || message === null)
        return "object expected";
      if (message.keyExchangeMethod != null && message.hasOwnProperty("keyExchangeMethod"))
        switch (message.keyExchangeMethod) {
          default:
            return "keyExchangeMethod: enum value expected";
          case 0:
          case 1:
          case 2:
            break;
        }
      if (message.publicMessagingKey != null && message.hasOwnProperty("publicMessagingKey")) {
        if (!(message.publicMessagingKey && typeof message.publicMessagingKey.length === "number" || $util.isString(message.publicMessagingKey)))
          return "publicMessagingKey: buffer expected";
      }
      return null;
    };
    X3DHKeyBundle.fromObject = function fromObject(object) {
      if (object instanceof $root.protocol.X3DHKeyBundle)
        return object;
      let message = new $root.protocol.X3DHKeyBundle();
      switch (object.keyExchangeMethod) {
        default:
          if (typeof object.keyExchangeMethod === "number") {
            message.keyExchangeMethod = object.keyExchangeMethod;
            break;
          }
          break;
        case "Unknown":
        case 0:
          message.keyExchangeMethod = 0;
          break;
        case "ECDH":
        case 1:
          message.keyExchangeMethod = 1;
          break;
        case "X3DH":
        case 2:
          message.keyExchangeMethod = 2;
          break;
      }
      if (object.publicMessagingKey != null) {
        if (typeof object.publicMessagingKey === "string")
          $util.base64.decode(object.publicMessagingKey, message.publicMessagingKey = $util.newBuffer($util.base64.length(object.publicMessagingKey)), 0);
        else if (object.publicMessagingKey.length >= 0)
          message.publicMessagingKey = object.publicMessagingKey;
      }
      return message;
    };
    X3DHKeyBundle.toObject = function toObject(message, options) {
      if (!options)
        options = {};
      let object = {};
      if (options.defaults) {
        object.keyExchangeMethod = options.enums === String ? "Unknown" : 0;
        if (options.bytes === String)
          object.publicMessagingKey = "";
        else {
          object.publicMessagingKey = [];
          if (options.bytes !== Array)
            object.publicMessagingKey = $util.newBuffer(object.publicMessagingKey);
        }
      }
      if (message.keyExchangeMethod != null && message.hasOwnProperty("keyExchangeMethod"))
        object.keyExchangeMethod = options.enums === String ? $root.protocol.KeyExchangeMethod[message.keyExchangeMethod] === void 0 ? message.keyExchangeMethod : $root.protocol.KeyExchangeMethod[message.keyExchangeMethod] : message.keyExchangeMethod;
      if (message.publicMessagingKey != null && message.hasOwnProperty("publicMessagingKey"))
        object.publicMessagingKey = options.bytes === String ? $util.base64.encode(message.publicMessagingKey, 0, message.publicMessagingKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicMessagingKey) : message.publicMessagingKey;
      return object;
    };
    X3DHKeyBundle.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    X3DHKeyBundle.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/protocol.X3DHKeyBundle";
    };
    return X3DHKeyBundle;
  }();
  protocol2.KeyExchangeMethod = function() {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "Unknown"] = 0;
    values[valuesById[1] = "ECDH"] = 1;
    values[valuesById[2] = "X3DH"] = 2;
    return values;
  }();
  protocol2.Envelope = function() {
    function Envelope(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    Envelope.prototype.encryptedMessageKey = $util.newBuffer([]);
    Envelope.prototype.encryptedMessageUri = $util.newBuffer([]);
    Envelope.prototype.keyExchangeMethod = 0;
    Envelope.prototype.ecdhKeyBundle = null;
    Envelope.create = function create(properties) {
      return new Envelope(properties);
    };
    Envelope.encode = function encode(message, writer) {
      if (!writer)
        writer = $Writer.create();
      if (message.encryptedMessageKey != null && Object.hasOwnProperty.call(message, "encryptedMessageKey"))
        writer.uint32(
          /* id 1, wireType 2 =*/
          10
        ).bytes(message.encryptedMessageKey);
      if (message.encryptedMessageUri != null && Object.hasOwnProperty.call(message, "encryptedMessageUri"))
        writer.uint32(
          /* id 2, wireType 2 =*/
          18
        ).bytes(message.encryptedMessageUri);
      if (message.keyExchangeMethod != null && Object.hasOwnProperty.call(message, "keyExchangeMethod"))
        writer.uint32(
          /* id 3, wireType 0 =*/
          24
        ).int32(message.keyExchangeMethod);
      if (message.ecdhKeyBundle != null && Object.hasOwnProperty.call(message, "ecdhKeyBundle"))
        $root.protocol.ECDHKeyBundle.encode(message.ecdhKeyBundle, writer.uint32(
          /* id 4, wireType 2 =*/
          34
        ).fork()).ldelim();
      return writer;
    };
    Envelope.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };
    Envelope.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader))
        reader = $Reader.create(reader);
      let end = length === void 0 ? reader.len : reader.pos + length, message = new $root.protocol.Envelope();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            message.encryptedMessageKey = reader.bytes();
            break;
          }
          case 2: {
            message.encryptedMessageUri = reader.bytes();
            break;
          }
          case 3: {
            message.keyExchangeMethod = reader.int32();
            break;
          }
          case 4: {
            message.ecdhKeyBundle = $root.protocol.ECDHKeyBundle.decode(reader, reader.uint32());
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    Envelope.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader))
        reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };
    Envelope.verify = function verify(message) {
      if (typeof message !== "object" || message === null)
        return "object expected";
      if (message.encryptedMessageKey != null && message.hasOwnProperty("encryptedMessageKey")) {
        if (!(message.encryptedMessageKey && typeof message.encryptedMessageKey.length === "number" || $util.isString(message.encryptedMessageKey)))
          return "encryptedMessageKey: buffer expected";
      }
      if (message.encryptedMessageUri != null && message.hasOwnProperty("encryptedMessageUri")) {
        if (!(message.encryptedMessageUri && typeof message.encryptedMessageUri.length === "number" || $util.isString(message.encryptedMessageUri)))
          return "encryptedMessageUri: buffer expected";
      }
      if (message.keyExchangeMethod != null && message.hasOwnProperty("keyExchangeMethod"))
        switch (message.keyExchangeMethod) {
          default:
            return "keyExchangeMethod: enum value expected";
          case 0:
          case 1:
          case 2:
            break;
        }
      if (message.ecdhKeyBundle != null && message.hasOwnProperty("ecdhKeyBundle")) {
        let error = $root.protocol.ECDHKeyBundle.verify(message.ecdhKeyBundle);
        if (error)
          return "ecdhKeyBundle." + error;
      }
      return null;
    };
    Envelope.fromObject = function fromObject(object) {
      if (object instanceof $root.protocol.Envelope)
        return object;
      let message = new $root.protocol.Envelope();
      if (object.encryptedMessageKey != null) {
        if (typeof object.encryptedMessageKey === "string")
          $util.base64.decode(object.encryptedMessageKey, message.encryptedMessageKey = $util.newBuffer($util.base64.length(object.encryptedMessageKey)), 0);
        else if (object.encryptedMessageKey.length >= 0)
          message.encryptedMessageKey = object.encryptedMessageKey;
      }
      if (object.encryptedMessageUri != null) {
        if (typeof object.encryptedMessageUri === "string")
          $util.base64.decode(object.encryptedMessageUri, message.encryptedMessageUri = $util.newBuffer($util.base64.length(object.encryptedMessageUri)), 0);
        else if (object.encryptedMessageUri.length >= 0)
          message.encryptedMessageUri = object.encryptedMessageUri;
      }
      switch (object.keyExchangeMethod) {
        default:
          if (typeof object.keyExchangeMethod === "number") {
            message.keyExchangeMethod = object.keyExchangeMethod;
            break;
          }
          break;
        case "Unknown":
        case 0:
          message.keyExchangeMethod = 0;
          break;
        case "ECDH":
        case 1:
          message.keyExchangeMethod = 1;
          break;
        case "X3DH":
        case 2:
          message.keyExchangeMethod = 2;
          break;
      }
      if (object.ecdhKeyBundle != null) {
        if (typeof object.ecdhKeyBundle !== "object")
          throw TypeError(".protocol.Envelope.ecdhKeyBundle: object expected");
        message.ecdhKeyBundle = $root.protocol.ECDHKeyBundle.fromObject(object.ecdhKeyBundle);
      }
      return message;
    };
    Envelope.toObject = function toObject(message, options) {
      if (!options)
        options = {};
      let object = {};
      if (options.defaults) {
        if (options.bytes === String)
          object.encryptedMessageKey = "";
        else {
          object.encryptedMessageKey = [];
          if (options.bytes !== Array)
            object.encryptedMessageKey = $util.newBuffer(object.encryptedMessageKey);
        }
        if (options.bytes === String)
          object.encryptedMessageUri = "";
        else {
          object.encryptedMessageUri = [];
          if (options.bytes !== Array)
            object.encryptedMessageUri = $util.newBuffer(object.encryptedMessageUri);
        }
        object.keyExchangeMethod = options.enums === String ? "Unknown" : 0;
        object.ecdhKeyBundle = null;
      }
      if (message.encryptedMessageKey != null && message.hasOwnProperty("encryptedMessageKey"))
        object.encryptedMessageKey = options.bytes === String ? $util.base64.encode(message.encryptedMessageKey, 0, message.encryptedMessageKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedMessageKey) : message.encryptedMessageKey;
      if (message.encryptedMessageUri != null && message.hasOwnProperty("encryptedMessageUri"))
        object.encryptedMessageUri = options.bytes === String ? $util.base64.encode(message.encryptedMessageUri, 0, message.encryptedMessageUri.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryptedMessageUri) : message.encryptedMessageUri;
      if (message.keyExchangeMethod != null && message.hasOwnProperty("keyExchangeMethod"))
        object.keyExchangeMethod = options.enums === String ? $root.protocol.KeyExchangeMethod[message.keyExchangeMethod] === void 0 ? message.keyExchangeMethod : $root.protocol.KeyExchangeMethod[message.keyExchangeMethod] : message.keyExchangeMethod;
      if (message.ecdhKeyBundle != null && message.hasOwnProperty("ecdhKeyBundle"))
        object.ecdhKeyBundle = $root.protocol.ECDHKeyBundle.toObject(message.ecdhKeyBundle, options);
      return object;
    };
    Envelope.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    Envelope.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/protocol.Envelope";
    };
    return Envelope;
  }();
  protocol2.Delivery = function() {
    function Delivery(properties) {
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    Delivery.prototype.envelope = null;
    Delivery.create = function create(properties) {
      return new Delivery(properties);
    };
    Delivery.encode = function encode(message, writer) {
      if (!writer)
        writer = $Writer.create();
      if (message.envelope != null && Object.hasOwnProperty.call(message, "envelope"))
        $root.protocol.Envelope.encode(message.envelope, writer.uint32(
          /* id 1, wireType 2 =*/
          10
        ).fork()).ldelim();
      return writer;
    };
    Delivery.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };
    Delivery.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader))
        reader = $Reader.create(reader);
      let end = length === void 0 ? reader.len : reader.pos + length, message = new $root.protocol.Delivery();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            message.envelope = $root.protocol.Envelope.decode(reader, reader.uint32());
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    Delivery.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader))
        reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };
    Delivery.verify = function verify(message) {
      if (typeof message !== "object" || message === null)
        return "object expected";
      if (message.envelope != null && message.hasOwnProperty("envelope")) {
        let error = $root.protocol.Envelope.verify(message.envelope);
        if (error)
          return "envelope." + error;
      }
      return null;
    };
    Delivery.fromObject = function fromObject(object) {
      if (object instanceof $root.protocol.Delivery)
        return object;
      let message = new $root.protocol.Delivery();
      if (object.envelope != null) {
        if (typeof object.envelope !== "object")
          throw TypeError(".protocol.Delivery.envelope: object expected");
        message.envelope = $root.protocol.Envelope.fromObject(object.envelope);
      }
      return message;
    };
    Delivery.toObject = function toObject(message, options) {
      if (!options)
        options = {};
      let object = {};
      if (options.defaults)
        object.envelope = null;
      if (message.envelope != null && message.hasOwnProperty("envelope"))
        object.envelope = $root.protocol.Envelope.toObject(message.envelope, options);
      return object;
    };
    Delivery.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    Delivery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/protocol.Delivery";
    };
    return Delivery;
  }();
  return protocol2;
})();

export {
  protocol
};
