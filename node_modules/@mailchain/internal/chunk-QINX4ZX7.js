"use strict";Object.defineProperty(exports, "__esModule", {value: true});

var _chunk4ZKLXRHJjs = require('./chunk-4ZKLXRHJ.js');


var _chunkE47TCHWZjs = require('./chunk-E47TCHWZ.js');


var _chunkYQZCGLMZjs = require('./chunk-YQZCGLMZ.js');


var _chunkZVDRRVVRjs = require('./chunk-ZVDRRVVR.js');



var _chunkO267RXGSjs = require('./chunk-O267RXGS.js');


var _chunkESCCOX3Vjs = require('./chunk-ESCCOX3V.js');


var _chunkPCGAQDYDjs = require('./chunk-PCGAQDYD.js');


var _chunkZKQAO77Pjs = require('./chunk-ZKQAO77P.js');

// src/verifiableCredentials/verifiableMailchainAddressOwner/issuer.ts
var _didjwtvc = require('did-jwt-vc');
var _crypto = require('@mailchain/crypto');
var _encoding = require('@mailchain/encoding');
function createIssuerProof(resolvedAddress) {
  switch (resolvedAddress.proof.source) {
    case "MailchainRegistry":
      const { signature, address, messagingKey, identityKey, ...remainingProof } = resolvedAddress.proof;
      return {
        signatureHex: _encoding.encodeHex.call(void 0, signature),
        addressHex: _encoding.encodeHex.call(void 0, address),
        messagingKeyHex: _encoding.encodeHex.call(void 0, _crypto.publicKeyToBytes.call(void 0, messagingKey)),
        identityKeyHex: _encoding.encodeHex.call(void 0, _crypto.publicKeyToBytes.call(void 0, identityKey)),
        ...remainingProof,
        type: "Mailchain-Ed25519Signature2020"
      };
    case "ContractCall":
      return {
        ...resolvedAddress.proof,
        type: "Mailchain-Ed25519Signature2020"
      };
    default:
      throw new Error(`unknown proof source ${resolvedAddress.proof.source}`);
  }
}
function createCredentialPayloadMailchainAddressOwner(resolvedAddress, requester, issuanceDate, actions, resources) {
  return _chunkZVDRRVVRjs.createVerifiableCredential.call(void 0, {
    type: "MailchainMessagingKeyCredential",
    credentialSubjects: [_chunkE47TCHWZjs.createOwnerOfMessagingKeySubject.call(void 0, resolvedAddress.mailchainAddress)],
    issuanceDate,
    issuerId: _chunkO267RXGSjs.mailchainBlockchainAddressDecentralizedIdentifier.call(void 0, 
      resolvedAddress.protocol,
      resolvedAddress.protocolAddress
    ),
    proof: createIssuerProof(resolvedAddress),
    termsOfUse: [
      {
        type: "HolderPolicy",
        assigner: _chunkO267RXGSjs.mailchainAddressDecentralizedIdentifier.call(void 0, resolvedAddress.mailchainAddress),
        effect: "Allow",
        assignee: requester,
        actions,
        resources
      }
    ]
  });
}
var MailchainAddressOwnershipIssuer = class {
  constructor(messagingKeys, mailchainMessagingKeyIssuer) {
    this.messagingKeys = messagingKeys;
    this.mailchainMessagingKeyIssuer = mailchainMessagingKeyIssuer;
  }
  static create(configuration = _chunkZKQAO77Pjs.defaultConfiguration) {
    return new MailchainAddressOwnershipIssuer(
      _chunkESCCOX3Vjs.MessagingKeys.create(configuration),
      new (0, _chunkYQZCGLMZjs.MailchainMessagingKeyIssuer)()
    );
  }
  async createVerifiableMailchainAddressOwnership(params) {
    const { address, signer, requester, options, actions, resources } = params;
    const { data: resolvedAddress, error: resolveAddressError } = await this.messagingKeys.resolve(address);
    if (resolveAddressError) {
      return {
        error: resolveAddressError
      };
    }
    if (resolvedAddress.type !== "registered") {
      return {
        error: new (0, _chunkPCGAQDYDjs.AddressNotRegisteredError)()
      };
    }
    const { requestId, expiresIn, expiresAt, nonce } = options;
    const issuanceDate = /* @__PURE__ */ new Date();
    const presentationPayload = _chunk4ZKLXRHJjs.createPresentationPayload.call(void 0, {
      requestId,
      issuanceDate,
      verifiableCredential: createCredentialPayloadMailchainAddressOwner(
        resolvedAddress,
        _chunkO267RXGSjs.mailchainAddressDecentralizedIdentifier.call(void 0, requester),
        issuanceDate,
        actions,
        resources
      ),
      holder: _chunkO267RXGSjs.mailchainAddressDecentralizedIdentifier.call(void 0, resolvedAddress.mailchainAddress),
      verifier: _chunkO267RXGSjs.mailchainAddressDecentralizedIdentifier.call(void 0, requester),
      expirationDate: resolveExpirationDate(issuanceDate, expiresAt, expiresIn)
    });
    const { data: issuer, error: createMailchainMessagingKeyIssuerError } = await this.mailchainMessagingKeyIssuer.createIssuerFromResolvedAddress({
      resolvedAddress,
      signer
    });
    if (createMailchainMessagingKeyIssuerError) {
      return {
        error: createMailchainMessagingKeyIssuerError
      };
    }
    const verifiablePresentation = await _didjwtvc.createVerifiablePresentationJwt.call(void 0, presentationPayload, issuer, {
      // challenge and domain are used to prevent replay attacks
      challenge: nonce,
      domain: _chunkO267RXGSjs.mailchainAddressDecentralizedIdentifier.call(void 0, requester),
      canonicalize: true
    });
    return { data: verifiablePresentation };
  }
};
function resolveExpirationDate(issuanceDate, expiresAt, expiresIn) {
  if (expiresAt == null && expiresIn == null)
    return void 0;
  if (expiresIn == null)
    return expiresAt;
  const expiresInTimestamp = issuanceDate.getTime() + expiresIn * 1e3;
  if (expiresAt == null)
    return new Date(expiresInTimestamp);
  return new Date(Math.min(expiresInTimestamp, expiresAt.getTime()));
}




exports.MailchainAddressOwnershipIssuer = MailchainAddressOwnershipIssuer; exports.resolveExpirationDate = resolveExpirationDate;
