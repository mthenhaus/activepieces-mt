"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _chunkHYGV43B5js = require('./chunk-HYGV43B5.js');


var _chunkR63BUJ2Xjs = require('./chunk-R63BUJ2X.js');


var _chunkAZWVETE6js = require('./chunk-AZWVETE6.js');


var _chunkIXZMJHSYjs = require('./chunk-IXZMJHSY.js');


var _chunkRQT6CC6Tjs = require('./chunk-RQT6CC6T.js');

// src/receiving/payload/payload.ts
var _encoding = require('@mailchain/encoding');
var _axios = require('axios'); var _axios2 = _interopRequireDefault(_axios);
var PayloadReceiver = class {
  constructor(deliveryRequests, payloadOriginVerifier, axiosInstance) {
    this.deliveryRequests = deliveryRequests;
    this.payloadOriginVerifier = payloadOriginVerifier;
    this.axiosInstance = axiosInstance;
  }
  static create(configuration, receiverMessagingKeyDecrypter, axiosInstance = _axios2.default.create()) {
    return new PayloadReceiver(
      _chunkR63BUJ2Xjs.DeliveryRequests.create(configuration, receiverMessagingKeyDecrypter),
      _chunkHYGV43B5js.PayloadOriginVerifier.create(),
      axiosInstance
    );
  }
  async getUndelivered() {
    const deliveryRequests = await this.deliveryRequests.getUndelivered();
    return Promise.all(
      deliveryRequests.map(async (result) => {
        switch (result.status) {
          case "success":
            const payloadResponse = await this.get(result.payloadRootEncryptionKey, result.payloadUri);
            return processReceivedPayload(payloadResponse, result.deliveryRequestHash);
          case "failure":
            return {
              cause: result.cause,
              deliveryRequestHash: result.deliveryRequestHash,
              status: "error-delivery-request"
            };
        }
      })
    );
  }
  async get(payloadRootEncryptionKey, payloadUri) {
    try {
      const encryptedMessageBodyResponse = await this.axiosInstance.get(payloadUri, {
        responseType: "arraybuffer"
      });
      const encryptedMessageBody = Buffer.from(_encoding.decodeBase64.call(void 0, encryptedMessageBodyResponse.data));
      const encryptedPayload = _chunkIXZMJHSYjs.deserialize.call(void 0, encryptedMessageBody);
      const { headers, content } = await _chunkRQT6CC6Tjs.decryptPayload.call(void 0, encryptedPayload, payloadRootEncryptionKey);
      const payload = {
        Headers: new (0, _chunkAZWVETE6js.SerializablePayloadHeadersImpl)().deserialize(headers),
        Content: content
      };
      await this.payloadOriginVerifier.verifyPayloadOrigin(payload);
      return {
        status: "success",
        payload
      };
    } catch (error) {
      return {
        status: "failure",
        cause: error
      };
    }
  }
};
function processReceivedPayload(payloadResponse, deliveryRequestHash) {
  switch (payloadResponse.status) {
    case "success":
      return {
        status: "success",
        payload: payloadResponse.payload,
        deliveryRequestHash
      };
    case "failure":
      return {
        status: "error-payload",
        cause: payloadResponse.cause,
        deliveryRequestHash
      };
    default:
      return {
        status: "error-payload",
        cause: new Error("Unknown payload response status"),
        deliveryRequestHash
      };
  }
}



exports.PayloadReceiver = PayloadReceiver;
