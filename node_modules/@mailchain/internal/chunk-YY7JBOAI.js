"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _chunkQOTIAHF7js = require('./chunk-QOTIAHF7.js');



var _chunkUSEAGTGTjs = require('./chunk-USEAGTGT.js');

// src/mailbox/messageMailboxOwnerMatcher.ts
var _addressing = require('@mailchain/addressing');
var _crypto = require('@mailchain/crypto');
var _uniqByjs = require('lodash/uniqBy.js'); var _uniqByjs2 = _interopRequireDefault(_uniqByjs);
var MessageMailboxOwnerMatcher = class {
  constructor(addressIdentityKeyResolvers) {
    this.addressIdentityKeyResolvers = addressIdentityKeyResolvers;
  }
  /** Create {@link MessageMailboxOwnerMatcher} with {@link createMailchainApiAddressIdentityKeyResolver} as default resolver.  */
  static create(config) {
    const identityKeys = _chunkQOTIAHF7js.IdentityKeys.create(config);
    return new MessageMailboxOwnerMatcher([
      ["mailchain-api", _chunkUSEAGTGTjs.createMailchainApiAddressIdentityKeyResolver.call(void 0, identityKeys)]
    ]);
  }
  /**
   * Build new {@link MessageMailboxOwnerMatcher} with an additional identity key resolver {@link createMessageHeaderIdentityKeyResolver}.
   *
   * Note: this doesn't modify the original {@link MessageMailboxOwnerMatcher}.
   */
  withMessageIdentityKeys(addressIdentityKeys) {
    const resolver = _chunkUSEAGTGTjs.createMessageHeaderIdentityKeyResolver.call(void 0, addressIdentityKeys);
    return new MessageMailboxOwnerMatcher([["message-header", resolver], ...this.addressIdentityKeyResolvers]);
  }
  /** Find the matching {@link Alias} from the provided `mailData` that match to the `userMailbox`. */
  async findMatches(mailData, userMailbox) {
    const allRecipients = _uniqByjs2.default.call(void 0, 
      [...mailData.recipients, ...mailData.carbonCopyRecipients, ...mailData.blindCarbonCopyRecipients],
      (r) => r.address
    );
    const matches = [];
    for (const recipient of allRecipients) {
      const address = _addressing.parseNameServiceAddress.call(void 0, recipient.address);
      for (const [matchBy, resolver] of this.addressIdentityKeyResolvers) {
        const result = await resolver(address);
        if (result != null && _crypto.isPublicKeyEqual.call(void 0, result.identityKey, userMailbox.identityKey)) {
          matches.push({ address: _addressing.parseNameServiceAddress.call(void 0, recipient.address), matchBy });
          break;
        }
      }
    }
    if (matches.length === 0) {
      return [{ address: userMailbox.aliases[0].address, matchBy: "fallback" }];
    }
    return matches;
  }
};



exports.MessageMailboxOwnerMatcher = MessageMailboxOwnerMatcher;
