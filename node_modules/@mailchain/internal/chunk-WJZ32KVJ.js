"use strict";Object.defineProperty(exports, "__esModule", {value: true});

var _chunkSPRQAWKFjs = require('./chunk-SPRQAWKF.js');


var _chunkO267RXGSjs = require('./chunk-O267RXGS.js');


var _chunkESCCOX3Vjs = require('./chunk-ESCCOX3V.js');


var _chunkZKQAO77Pjs = require('./chunk-ZKQAO77P.js');


var _chunkTCLRDJ3Gjs = require('./chunk-TCLRDJ3G.js');

// src/verifiableCredentials/verifiableMailchainAddressOwner/verifier.ts
var _didjwtvc = require('did-jwt-vc');
var VerificationError = class extends Error {
  constructor(cause) {
    super("presentation failed to verify", { cause });
  }
};
var MailchainAddressOwnershipVerifier = class {
  constructor(mailchainDidResolver, messagingKeys) {
    this.mailchainDidResolver = mailchainDidResolver;
    this.messagingKeys = messagingKeys;
  }
  static create(configuration = _chunkZKQAO77Pjs.defaultConfiguration) {
    return new MailchainAddressOwnershipVerifier(
      _chunkSPRQAWKFjs.MailchainDIDMessagingKeyResolver.create(configuration),
      _chunkESCCOX3Vjs.MessagingKeys.create(configuration)
    );
  }
  async verifyMailchainAddressOwnership(params) {
    const { presentation, verifier, nonce, address, actions, resources } = params;
    const result = await _didjwtvc.verifyPresentation.call(void 0, presentation, this.mailchainDidResolver, {
      challenge: nonce,
      proofPurpose: "authentication",
      audience: _chunkO267RXGSjs.mailchainAddressDecentralizedIdentifier.call(void 0, verifier)
    }).catch((e) => {
      return {
        verified: false,
        error: e
      };
    });
    if (!result.verified) {
      return { error: new VerificationError(result.error) };
    }
    const { verifiablePresentation } = result;
    if (verifiablePresentation.holder != _chunkO267RXGSjs.mailchainAddressDecentralizedIdentifier.call(void 0, address)) {
      return {
        error: new (0, _chunkTCLRDJ3Gjs.ValidationError)("verified presentation holder address does not match")
      };
    }
    if (!verifiablePresentation.verifiableCredential || verifiablePresentation.verifiableCredential.length === 0) {
      return {
        error: new (0, _chunkTCLRDJ3Gjs.ValidationError)("verifiable credential not found")
      };
    }
    const mailchainMessagingKeyCredentials = verifiablePresentation.verifiableCredential.filter(
      (vc) => vc.type.some((x) => x === "MailchainMessagingKeyCredential") && vc.type.some((x) => x === "VerifiableCredential")
    );
    if (mailchainMessagingKeyCredentials.length === 0) {
      return {
        error: new (0, _chunkTCLRDJ3Gjs.ValidationError)("missing MailchainMessagingKeyCredential")
      };
    }
    if (mailchainMessagingKeyCredentials.length !== 1) {
      return {
        error: new (0, _chunkTCLRDJ3Gjs.ValidationError)("more than one MailchainMessagingKeyCredential found")
      };
    }
    const mailchainMessagingKeyCredential = mailchainMessagingKeyCredentials[0];
    const credentialSubjects = Object.keys(mailchainMessagingKeyCredential.credentialSubject).map(
      (key) => mailchainMessagingKeyCredential.credentialSubject[key]
    );
    if (credentialSubjects.length === 0) {
      return {
        error: new (0, _chunkTCLRDJ3Gjs.ValidationError)("no credentialSubject found")
      };
    }
    if (!credentialSubjects.filter((subject) => Object.keys(subject).some((x) => x === "ownerOf")).some((subject) => {
      const { ownerOf } = subject;
      return ownerOf.type === "MailchainMessagingKey" && ownerOf.address === address;
    })) {
      return {
        error: new (0, _chunkTCLRDJ3Gjs.ValidationError)("MailchainMessagingKey owner does not match supplied address")
      };
    }
    if (!mailchainMessagingKeyCredential.termsOfUse) {
      return {
        error: new (0, _chunkTCLRDJ3Gjs.ValidationError)("termsOfUse not found")
      };
    }
    const verifyTermsOfUseError = verifyTermsOfUse(
      mailchainMessagingKeyCredential.termsOfUse,
      actions,
      resources,
      _chunkO267RXGSjs.mailchainAddressDecentralizedIdentifier.call(void 0, address),
      _chunkO267RXGSjs.mailchainAddressDecentralizedIdentifier.call(void 0, verifier)
    );
    if (verifyTermsOfUseError) {
      return { error: verifyTermsOfUseError };
    }
    const { data: resolvedAddress, error: resolverAddressError } = await this.messagingKeys.resolve(address);
    if (resolverAddressError) {
      return { error: resolverAddressError };
    }
    return { data: { ...result, resolvedAddress } };
  }
};
function verifyTermsOfUse(termsOfUse, requiredActions, requiredResources, requiredAssigner, requiredAssignee) {
  if (termsOfUse.length !== 1) {
    return new (0, _chunkTCLRDJ3Gjs.ValidationError)("credential must contain exactly 1 termOfUse");
  }
  const term = termsOfUse[0];
  const { actions, resources, assignee, assigner } = term;
  if (!actions.includes("*") && !requiredActions.every((x) => actions.includes(x))) {
    return new (0, _chunkTCLRDJ3Gjs.ValidationError)("not all required actions are met");
  }
  if (!resources.includes("*") && !requiredResources.every((x) => resources.includes(x))) {
    return new (0, _chunkTCLRDJ3Gjs.ValidationError)("not all required resources are met");
  }
  if (assignee !== requiredAssignee) {
    return new (0, _chunkTCLRDJ3Gjs.ValidationError)("termOfUse assignee incorrect");
  }
  if (assigner !== requiredAssigner) {
    return new (0, _chunkTCLRDJ3Gjs.ValidationError)("termOfUse assigner incorrect");
  }
  return;
}




exports.VerificationError = VerificationError; exports.MailchainAddressOwnershipVerifier = MailchainAddressOwnershipVerifier;
