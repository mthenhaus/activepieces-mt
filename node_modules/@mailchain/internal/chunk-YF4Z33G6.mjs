import {
  createV2IdentityKey,
  createV3LabelMigration,
  createV4AliasesMigration,
  createV5NsMigration,
  createV6FixNsAliasFormatMigration,
  user
} from "./chunk-APAWMH6P.mjs";
import {
  consolidateMailbox
} from "./chunk-NTRXA2SW.mjs";
import {
  createMailboxAlias
} from "./chunk-GOSDHILO.mjs";
import {
  Nameservices
} from "./chunk-ANDULYWI.mjs";
import {
  combineMigrations
} from "./chunk-AYRU4OE4.mjs";
import {
  IdentityKeys
} from "./chunk-7AQ4G6HT.mjs";

// src/user/userProfile.ts
import { decodeBase64, decodeUtf8, encodeBase64, encodeUtf8 } from "@mailchain/encoding";
import {
  createWalletAddress,
  decodeAddressByProtocol,
  encodeAddressByProtocol,
  formatAddress,
  MAILCHAIN,
  parseNameServiceAddress
} from "@mailchain/addressing";
import {
  publicKeyFromBytes,
  publicKeyToBytes
} from "@mailchain/crypto";
import { isAxiosError } from "axios";
import {
  PutUserSettingRequestBodyGroupEnum,
  UserApiFactory,
  createAxiosConfiguration,
  getAxiosWithSigner
} from "@mailchain/api";
var UserNotFoundError = class extends Error {
  constructor() {
    super(`user not found for provided key`);
  }
};
var GENERIC_SETTINGS_GROUP = PutUserSettingRequestBodyGroupEnum.Generic;
var CURRENT_MAILBOX_VERSION = 6;
var MailchainUserProfile = class {
  constructor(mailchainAddressDomain, userApi, accountIdentityKey, mailboxCrypto, settingsCrypto, migration) {
    this.mailchainAddressDomain = mailchainAddressDomain;
    this.userApi = userApi;
    this.accountIdentityKey = accountIdentityKey;
    this.mailboxCrypto = mailboxCrypto;
    this.settingsCrypto = settingsCrypto;
    this.migration = migration;
  }
  static create(config, accountIdentityKey, mailboxCrypto, settingsCrypto) {
    const axiosConfig = createAxiosConfiguration(config.apiPath);
    const identityKeys = IdentityKeys.create(config);
    const userApi = UserApiFactory(axiosConfig, void 0, getAxiosWithSigner(accountIdentityKey));
    const nameservice = Nameservices.create(config);
    const migrations = combineMigrations(
      createV2IdentityKey(identityKeys, config.mailchainAddressDomain),
      createV3LabelMigration(config.mailchainAddressDomain),
      createV4AliasesMigration(config.mailchainAddressDomain),
      createV5NsMigration(nameservice),
      createV6FixNsAliasFormatMigration(config.mailchainAddressDomain)
    );
    return new MailchainUserProfile(
      config.mailchainAddressDomain,
      userApi,
      () => Promise.resolve(accountIdentityKey.publicKey),
      mailboxCrypto,
      settingsCrypto,
      migrations
    );
  }
  async getUsername() {
    return this.userApi.getUsername().then((response) => {
      const { data } = response;
      return {
        address: data.address,
        username: data.username
      };
    }).catch((e) => {
      if (e.response?.status === 404) {
        throw new UserNotFoundError();
      }
      throw e;
    });
  }
  async setSetting(key, value, opts) {
    const valueToStore = opts?.secure ? encodeBase64(await this.settingsCrypto.encrypt(decodeUtf8(value))) : value;
    await this.userApi.putUserSetting(key, {
      value: valueToStore,
      kind: opts?.secure ? "encrypted" : "string",
      group: opts?.group
    });
  }
  async getSetting(key) {
    try {
      const { data } = await this.userApi.getUserSetting(key);
      return this.handleSettingsItem(data);
    } catch (e) {
      if (isAxiosError(e) && (e.response?.status === 404 || e.response?.status === 422)) {
        return void 0;
      }
      throw e;
    }
  }
  async getSettings(group) {
    try {
      const { data } = await this.userApi.getUserSettings(group);
      const result = /* @__PURE__ */ new Map();
      for (const setting of data.settings) {
        result.set(setting.name, await this.handleSettingsItem(setting));
      }
      return result;
    } catch (e) {
      if (isAxiosError(e) && e.response?.status === 422) {
        return /* @__PURE__ */ new Map();
      }
      throw e;
    }
  }
  async handleSettingsItem(item) {
    if (item.kind === "encrypted" && item.value) {
      return {
        ...item,
        value: encodeUtf8(await this.settingsCrypto.decrypt(decodeBase64(item.value)))
      };
    }
    return item;
  }
  async deleteSetting(key) {
    await this.userApi.deleteUserSetting(key);
  }
  async mailboxes() {
    const { mailboxes: apiMailboxes } = await this.userApi.getUserMailboxes().then((r) => r.data);
    const resultMailboxes = [];
    for (const apiMailbox of apiMailboxes) {
      try {
        const decryptedMailbox = await this.mailboxCrypto.decrypt(
          decodeBase64(apiMailbox.encryptedMailboxInformation)
        );
        const originalMailboxData = {
          version: apiMailbox.version,
          protoMailbox: user.Mailbox.decode(decryptedMailbox)
        };
        const mailboxData = await this.migration.shouldApply(originalMailboxData) ? await this.migration.apply(originalMailboxData) : originalMailboxData;
        if (apiMailbox.version !== mailboxData.version) {
          console.debug(
            `${apiMailbox.mailboxId} migrated from v${apiMailbox.version} to v${mailboxData.version}`
          );
          this.internalUpdateMailbox(
            apiMailbox.mailboxId,
            mailboxData.protoMailbox,
            mailboxData.version
          ).then(
            () => console.debug(`successfully stored migrated mailbox ${apiMailbox.mailboxId}`),
            (e) => console.warn(`failed storing migrated mailbox ${apiMailbox.mailboxId}`, e)
          );
        }
        const { protoMailbox } = mailboxData;
        const protocol = protoMailbox.protocol;
        const encodedAddress = encodeAddressByProtocol(protoMailbox.address, protocol).encoded;
        const fallbackAlias = createMailboxAlias(
          createWalletAddress(encodedAddress, protocol, this.mailchainAddressDomain)
        );
        const mailboxAliases = protoMailbox.aliases.map(user.Mailbox.Alias.create).map((protoAlias) => {
          return createMailboxAlias(parseNameServiceAddress(protoAlias.address), {
            allowSending: !protoAlias.blockSending,
            allowReceiving: !protoAlias.blockReceiving
          });
        });
        resultMailboxes.push({
          type: "wallet",
          id: apiMailbox.mailboxId,
          identityKey: publicKeyFromBytes(protoMailbox.identityKey),
          label: protoMailbox.label ?? null,
          aliases: mailboxAliases.length > 0 ? mailboxAliases : [fallbackAlias],
          messagingKeyParams: {
            address: protoMailbox.address,
            protocol,
            network: protoMailbox.network,
            nonce: protoMailbox.nonce
          }
        });
      } catch (e) {
        console.error(`failed processing mailbox ${apiMailbox.mailboxId}`, e);
      }
    }
    return [await this.accountMailbox(), ...resultMailboxes];
  }
  async accountMailbox() {
    const { username, address } = await this.getUsername();
    const addressAlias = createMailboxAlias(createWalletAddress(username, MAILCHAIN, this.mailchainAddressDomain));
    return {
      type: "account",
      id: address,
      identityKey: await this.accountIdentityKey(),
      label: null,
      aliases: [addressAlias],
      messagingKeyParams: {
        address: decodeAddressByProtocol(username, MAILCHAIN).decoded,
        protocol: MAILCHAIN,
        network: this.mailchainAddressDomain,
        nonce: 1
      }
    };
  }
  async addMailbox(mailbox) {
    const consolidatedMailbox = consolidateMailbox(mailbox);
    const protoMailbox = createProtoUserMailbox(consolidatedMailbox);
    const encrypted = await this.mailboxCrypto.encrypt(user.Mailbox.encode(protoMailbox).finish());
    const { mailboxId } = await this.userApi.postUserMailbox({ encryptedMailboxInformation: encodeBase64(encrypted), version: CURRENT_MAILBOX_VERSION }).then((res) => res.data);
    return { ...consolidatedMailbox, type: "wallet", id: mailboxId };
  }
  async updateMailbox(mailboxId, mailbox) {
    const consolidatedMailbox = consolidateMailbox(mailbox);
    const protoMailbox = createProtoUserMailbox(consolidatedMailbox);
    await this.internalUpdateMailbox(mailboxId, protoMailbox, CURRENT_MAILBOX_VERSION);
    return { id: mailboxId, type: "wallet", ...consolidatedMailbox };
  }
  async removeMailbox(mailboxId) {
    await this.userApi.deleteUserMailbox(mailboxId);
    return;
  }
  async internalUpdateMailbox(addressId, protoMailbox, version) {
    const encrypted = await this.mailboxCrypto.encrypt(user.Mailbox.encode(protoMailbox).finish());
    await this.userApi.putUserMailbox(addressId, { encryptedMailboxInformation: encodeBase64(encrypted), version });
    return protoMailbox;
  }
};
function createProtoUserMailbox(mailbox) {
  return user.Mailbox.create({
    identityKey: publicKeyToBytes(mailbox.identityKey),
    address: mailbox.messagingKeyParams.address,
    protocol: mailbox.messagingKeyParams.protocol,
    network: mailbox.messagingKeyParams.network,
    nonce: mailbox.messagingKeyParams.nonce,
    label: mailbox.label,
    aliases: mailbox.aliases.map(createProtoAlias)
  });
}
function createProtoAlias(alias) {
  return user.Mailbox.Alias.create({
    address: formatAddress(alias.address, "mail"),
    blockSending: !alias.allowSending,
    blockReceiving: !alias.allowReceiving
  });
}

export {
  UserNotFoundError,
  GENERIC_SETTINGS_GROUP,
  MailchainUserProfile
};
