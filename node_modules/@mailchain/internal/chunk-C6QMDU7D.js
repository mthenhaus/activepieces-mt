"use strict";Object.defineProperty(exports, "__esModule", {value: true});// src/transport/serialization/headers.ts
var _crypto = require('@mailchain/crypto');
var _encoding = require('@mailchain/encoding');
function parseHeaderElements(input, requiredKeys) {
  const invalidAttributes = [];
  const attributes = /* @__PURE__ */ new Map();
  input.split(";").forEach((item) => {
    const parts = item.split("=", 2);
    if (parts.length !== 2) {
      invalidAttributes.push(item);
    }
    attributes.set(parts[0].trim(), parts[1].trim());
  });
  requiredKeys.forEach((item) => {
    if (!attributes.get(item)) {
      throw new Error(`missing header attribute '${item}'`);
    }
  });
  return attributes;
}
function parseSignatureHeader(input) {
  const attributes = parseHeaderElements(input, ["data"]);
  const sig = _encoding.decodeBase64.call(void 0, attributes.get("data").toString());
  if (sig.length === 0) {
    throw new Error("could not decode signature");
  }
  return sig;
}
function createSignatureHeader(signature, signer) {
  const values = [];
  values.push(`data=${_encoding.encodeBase64.call(void 0, signature)}`);
  values.push(`alg=${_crypto.kindFromPublicKey.call(void 0, signer)}`);
  return values.join("; ").trimEnd();
}
function parseOriginHeader(input) {
  const attributes = parseHeaderElements(input, ["data", "alg"]);
  const bytes = _encoding.decodeBase64.call(void 0, attributes.get("data").toString());
  return _crypto.publicKeyFromKind.call(void 0, attributes.get("alg").toString(), bytes);
}
function createOriginHeader(signer) {
  const values = [];
  values.push(`data=${_encoding.encodeBase64.call(void 0, signer.bytes)}`);
  values.push(`alg=${_crypto.kindFromPublicKey.call(void 0, signer)}`);
  return values.join("; ").trimEnd();
}
function headersMapFromBuffers(buffer, requiredHeaders) {
  const { headers, invalidHeaders } = buffer.toString("utf8").split("\r\n").reduce(
    (result, line) => {
      if (line.indexOf(":") === -1) {
        result.invalidHeaders.push(line);
      }
      result.headers.set(line.slice(0, line.indexOf(":")).trim(), line.slice(line.indexOf(":") + 1).trim());
      return result;
    },
    { headers: /* @__PURE__ */ new Map(), invalidHeaders: [] }
  );
  const missingHeaders = requiredHeaders.filter((x) => !headers.has(x));
  if (missingHeaders.length > 0) {
    throw new Error(`missing header(s) ${missingHeaders}`);
  }
  return { headers, invalidHeaders };
}








exports.parseHeaderElements = parseHeaderElements; exports.parseSignatureHeader = parseSignatureHeader; exports.createSignatureHeader = createSignatureHeader; exports.parseOriginHeader = parseOriginHeader; exports.createOriginHeader = createOriginHeader; exports.headersMapFromBuffers = headersMapFromBuffers;
