"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }

var _chunkAAWSJVN2js = require('./chunk-AAWSJVN2.js');


var _chunkMPOR65BQjs = require('./chunk-MPOR65BQ.js');


var _chunkJNAHDQLZjs = require('./chunk-JNAHDQLZ.js');


var _chunkYY7JBOAIjs = require('./chunk-YY7JBOAI.js');



var _chunkYQEYV6WAjs = require('./chunk-YQEYV6WA.js');


var _chunk5RKRQTM4js = require('./chunk-5RKRQTM4.js');


var _chunkQOTIAHF7js = require('./chunk-QOTIAHF7.js');




var _chunk7575INAUjs = require('./chunk-7575INAU.js');


var _chunkUSEAGTGTjs = require('./chunk-USEAGTGT.js');


var _chunkHNHEEGO6js = require('./chunk-HNHEEGO6.js');


var _chunkUKHG6CH2js = require('./chunk-UKHG6CH2.js');

// src/mailbox/mailboxOperations.ts
var _addressing = require('@mailchain/addressing');





var _api = require('@mailchain/api');
var _crypto = require('@mailchain/crypto');
var _encoding = require('@mailchain/encoding');
var _striptags = require('striptags'); var _striptags2 = _interopRequireDefault(_striptags);
var _sha3 = require('@noble/hashes/sha3');
var MailchainMailboxOperations = class {
  constructor(inboxApi, messagePreviewCrypto, messageCrypto, messageMailboxOwnerMatcher, addressHasher, messageIdCreator, userMailboxHasher, messageDateOffset, migration, ruleEngine) {
    this.inboxApi = inboxApi;
    this.messagePreviewCrypto = messagePreviewCrypto;
    this.messageCrypto = messageCrypto;
    this.messageMailboxOwnerMatcher = messageMailboxOwnerMatcher;
    this.addressHasher = addressHasher;
    this.messageIdCreator = messageIdCreator;
    this.userMailboxHasher = userMailboxHasher;
    this.messageDateOffset = messageDateOffset;
    this.migration = migration;
    this.ruleEngine = ruleEngine;
  }
  static create(sdkConfig, keyRing, mailboxRuleEngine) {
    const axiosConfig = _api.createAxiosConfiguration.call(void 0, sdkConfig.apiPath);
    const axiosClient = _api.getAxiosWithSigner.call(void 0, keyRing.accountMessagingKey());
    const inboxApi = _api.InboxApiFactory.call(void 0, axiosConfig, void 0, axiosClient);
    const messagePreviewCrypto = keyRing.inboxKey();
    const messageMessageCrypto = _chunkHNHEEGO6js.createMailchainMessageCrypto.call(void 0, keyRing);
    const messageMailboxOwnerMatcher = _chunkYY7JBOAIjs.MessageMailboxOwnerMatcher.create(sdkConfig);
    const addressHasher = _chunk7575INAUjs.mailchainAddressHasher.call(void 0, 
      _chunkUSEAGTGTjs.createMailchainApiAddressIdentityKeyResolver.call(void 0, _chunkQOTIAHF7js.IdentityKeys.create(sdkConfig)),
      keyRing
    );
    const messageHasher = _chunkJNAHDQLZjs.createMailchainMessageIdCreator.call(void 0, keyRing);
    const userMailboxHasher = _chunk5RKRQTM4js.createMailchainUserMailboxHasher.call(void 0, keyRing);
    const mailboxOperations = new MailchainMailboxOperations(
      inboxApi,
      messagePreviewCrypto,
      messageMessageCrypto,
      messageMailboxOwnerMatcher,
      addressHasher,
      messageHasher,
      userMailboxHasher,
      keyRing.inboxMessageDateOffset(),
      _chunkYQEYV6WAjs.getAllMessagePreviewMigrations.call(void 0, sdkConfig),
      mailboxRuleEngine
    );
    return mailboxOperations;
  }
  async getMessage(messageId) {
    const message = await this.inboxApi.getMessage(messageId).then((res) => res.data.message);
    return this.handleMessagePreview(message);
  }
  async getInboxMessages(params) {
    return this.getMessagesInView(this.inboxApi.getMessagesInInboxView, params);
  }
  async getStarredMessages(params) {
    return this.getMessagesInView(this.inboxApi.getMessagesInStarredView, params);
  }
  async getTrashMessages(params) {
    return this.getMessagesInView(this.inboxApi.getMessagesInTrashView, params);
  }
  async getUnreadMessages(params) {
    return this.getMessagesInView(this.inboxApi.getMessagesInUnreadView, params);
  }
  async getSentMessages(params) {
    return this.getMessagesInView(this.inboxApi.getMessagesInSentView, params);
  }
  async getOutboxMessages(params) {
    return this.getMessagesInView(this.inboxApi.getMessagesInOutboxView, params);
  }
  async getArchivedMessages(params) {
    return this.getMessagesInView(this.inboxApi.getMessagesInArchivedView, params);
  }
  async getSpamMessages_unstable(params) {
    return this.getMessagesInView(this.inboxApi.getMessagesInSpamView, params);
  }
  async getMessagesInView(viewMethod, params) {
    const hashedMailbox = Array.isArray(_optionalChain([params, 'optionalAccess', _ => _.userMailboxes])) ? (await Promise.all(params.userMailboxes.map((m) => this.userMailboxHasher(m)))).map(_encoding.encodeHex) : void 0;
    const labels = void 0, from = void 0, to = void 0;
    const {
      data: { messages }
    } = await viewMethod(labels, from, to, _optionalChain([params, 'optionalAccess', _2 => _2.offset]), _optionalChain([params, 'optionalAccess', _3 => _3.limit]), hashedMailbox);
    return this.handleMessagePreviews(messages);
  }
  async handleMessagePreviews(messages) {
    const messagePreviews = [];
    for (const message of messages) {
      try {
        messagePreviews.push(await this.handleMessagePreview(message));
      } catch (error) {
        console.error(
          `failed to read message preview: version=${message.version};messageId=${message.messageId}`,
          error
        );
      }
    }
    return messagePreviews;
  }
  async handleMessagePreview(apiMessage) {
    const encryptedPreviewData = _encoding.decodeBase64.call(void 0, apiMessage.encryptedPreview);
    const originalPreviewData = {
      version: apiMessage.version,
      messagePreview: _chunkYQEYV6WAjs.preview.MessagePreview.decode(
        await this.messagePreviewCrypto.decrypt(encryptedPreviewData)
      )
    };
    const message = await this.migration.shouldApply(originalPreviewData) ? await this.migration.apply(originalPreviewData) : originalPreviewData;
    if (apiMessage.version !== message.version) {
      console.debug(`${apiMessage.messageId} migrated from v${apiMessage.version} to v${message.version}`);
    }
    const { messagePreview } = message;
    return {
      kind: apiMessage.kind,
      mailbox: _crypto.publicKeyFromBytes.call(void 0, messagePreview.mailbox),
      messageId: apiMessage.messageId,
      owner: messagePreview.owner,
      to: messagePreview.to,
      bcc: messagePreview.bcc,
      cc: messagePreview.cc,
      from: messagePreview.from,
      subject: messagePreview.subject,
      snippet: messagePreview.snippet,
      hasAttachment: messagePreview.hasAttachment,
      timestamp: new Date(messagePreview.timestamp * 1e3),
      isRead: !apiMessage.systemLabels.includes("unread"),
      systemLabels: apiMessage.systemLabels
    };
  }
  async getFullMessage(messageId) {
    const encryptedMessage = await this.inboxApi.getEncryptedMessageBody(messageId, { responseType: "arraybuffer" }).then((res) => res.data);
    const messageData = await this.messageCrypto.decrypt(new Uint8Array(encryptedMessage));
    switch (messageData.Headers.ContentType) {
      case "application/vnd.mailchain.verified-credential-request":
        return { body: _encoding.encodeUtf8.call(void 0, messageData.Content), payloadHeaders: messageData.Headers };
      case "message/x.mailchain":
      case "message/x.mailchain-mailer":
        const { mailData } = await this.extractPayloadInfo(messageData);
        return {
          replyTo: mailData.replyTo ? mailData.replyTo.address : void 0,
          body: mailData.message,
          payloadHeaders: messageData.Headers
        };
      default:
        throw new Error(`Unsupported content type of full message: ${messageData.Headers.ContentType}`);
    }
  }
  async getMessagesOverview(mailboxes) {
    const hashedMailboxes = new Map(
      await Promise.all(
        mailboxes.map(
          (mailbox) => this.userMailboxHasher(mailbox).then(
            (mailboxHash) => [_encoding.encodeHex.call(void 0, mailboxHash), mailbox]
          )
        )
      )
    );
    const folders = /* @__PURE__ */ new Map();
    const messagesOverview = { total: 0, unread: 0, folders };
    const { data: apiMessagesOverview } = await this.inboxApi.getMailboxOverview([...hashedMailboxes.keys()]);
    apiMessagesOverview.mailboxes.forEach((apiMailboxOverview) => {
      const mailbox = hashedMailboxes.get(apiMailboxOverview.mailbox);
      if (mailbox == null) {
        console.warn(
          `getMailboxOverview returned mailbox (${apiMailboxOverview.mailbox}) that was not requested mailboxes`
        );
        return;
      }
      apiMailboxOverview.labels.forEach((apiLabelOverview) => {
        const folderOverview = _nullishCoalesce(folders.get(apiLabelOverview.label), () => ( {
          total: 0,
          unread: 0,
          mailboxes: /* @__PURE__ */ new Map()
        }));
        folderOverview.total += apiLabelOverview.total;
        folderOverview.unread += apiLabelOverview.unread;
        if (!["starred"].includes(apiLabelOverview.label)) {
          messagesOverview.total += apiLabelOverview.total;
          messagesOverview.unread += apiLabelOverview.unread;
        }
        folderOverview.mailboxes.set(_chunkAAWSJVN2js.encodeMailbox.call(void 0, mailbox), {
          total: apiLabelOverview.total,
          unread: apiLabelOverview.unread
        });
        folders.set(apiLabelOverview.label, folderOverview);
      });
    });
    return messagesOverview;
  }
  async saveSentMessage(params) {
    const messageId = await this.messageIdCreator({ type: "sent", mailData: params.content });
    const owner = _addressing.parseNameServiceAddress.call(void 0, params.content.from.address);
    return this.saveMessage(messageId, params.payload, params.content, params.userMailbox, owner, "outbox");
  }
  async extractPayloadInfo(payload) {
    switch (payload.Headers.ContentType) {
      case "message/x.mailchain":
      case "message/x.mailchain-mailer":
        return _chunkUKHG6CH2js.parseMimeText.call(void 0, payload.Content);
      case "application/vnd.mailchain.verified-credential-request":
        const jsonStr = _encoding.encodeUtf8.call(void 0, payload.Content);
        const messageId = _encoding.encodeHex.call(void 0, 
          _sha3.sha3_256.call(void 0, 
            Uint8Array.from([
              ...payload.Content,
              ..._encoding.decodeHex.call(void 0, payload.Headers.Created.getTime().toString())
            ])
          )
        );
        const vcRequest = _chunkMPOR65BQjs.parseVerifiablePresentationRequest.call(void 0, jsonStr);
        const vcMailData = {
          id: messageId,
          subject: "Verifiable Presentation Request",
          from: {
            address: vcRequest.from,
            name: vcRequest.from
          },
          date: payload.Headers.Created,
          recipients: [
            {
              address: vcRequest.to,
              name: vcRequest.to
            }
          ],
          carbonCopyRecipients: [],
          blindCarbonCopyRecipients: [],
          message: jsonStr,
          plainTextMessage: `Request for ${vcRequest.resources.join(
            ", "
          )} to perform ${vcRequest.actions.join(", ")}).`
        };
        return {
          mailData: vcMailData,
          addressIdentityKeys: /* @__PURE__ */ new Map()
        };
      default:
        throw new Error(`Unsupported content type: ${payload.Headers.ContentType}`);
    }
  }
  async saveReceivedMessage({
    userMailbox,
    receivedTransportPayload
  }) {
    const payload = receivedTransportPayload;
    const { mailData, addressIdentityKeys } = await this.extractPayloadInfo(payload);
    const owners = await this.messageMailboxOwnerMatcher.withMessageIdentityKeys(addressIdentityKeys).findMatches(mailData, userMailbox);
    if (owners.length === 0)
      throw new Error("no owners found for message");
    const savedMessages = [];
    for (const { address: owner } of owners) {
      const messageId = await this.messageIdCreator({
        type: "received",
        mailData,
        owner: _addressing.formatAddress.call(void 0, owner, "mail"),
        mailbox: userMailbox.identityKey
      });
      const savedMessage = await this.saveMessage(messageId, payload, mailData, userMailbox, owner, "inbox");
      if (this.ruleEngine != null) {
        const ruleEngineOutput = await this.ruleEngine.apply({ message: savedMessage });
        savedMessages.push(ruleEngineOutput.message);
      } else {
        savedMessages.push(savedMessage);
      }
    }
    if (savedMessages.length === 0) {
      throw new Error(`no message was saved for message with ID [${mailData.id}]`);
    }
    return savedMessages;
  }
  async saveMessage(messageId, payload, content, userMailbox, owner, folder) {
    const ownerAddress = _addressing.formatAddress.call(void 0, owner, "mail");
    const protoMessagePreview = createProtoMessagePreview(userMailbox, owner, content);
    const encodedProtoMessagePreview = _chunkYQEYV6WAjs.preview.MessagePreview.encode(protoMessagePreview).finish();
    const encryptedProtoMessagePreview = await this.messagePreviewCrypto.encrypt(encodedProtoMessagePreview);
    const messagePreview = {
      kind: payload.Headers.ContentType === "application/vnd.mailchain.verified-credential-request" ? "vc-request" : "mail",
      mailbox: userMailbox.identityKey,
      messageId,
      from: protoMessagePreview.from,
      to: protoMessagePreview.to,
      cc: protoMessagePreview.cc,
      bcc: protoMessagePreview.bcc,
      subject: protoMessagePreview.subject,
      owner: protoMessagePreview.owner,
      snippet: protoMessagePreview.snippet,
      isRead: folder === "outbox",
      systemLabels: folder === "outbox" ? ["outbox"] : ["unread", "inbox"],
      hasAttachment: false,
      timestamp: new Date(protoMessagePreview.timestamp * 1e3)
    };
    const encryptedMessage = await this.messageCrypto.encrypt(payload);
    const { recipients: to, carbonCopyRecipients: cc, blindCarbonCopyRecipients: bcc } = content;
    const addresses = [content.from, ...to, ...cc, ...bcc].map((a) => a.address);
    addresses.push(ownerAddress);
    const addressHashes = await this.addressHasher(addresses);
    const { resourceId } = await this.inboxApi.postEncryptedMessageBody(encryptedMessage).then((res) => res.data);
    await this.inboxApi.putEncryptedMessage(messageId, {
      kind: messagePreview.kind,
      version: 3,
      folder: folder === "outbox" ? _api.PutEncryptedMessageRequestBodyFolderEnum.Outbox : _api.PutEncryptedMessageRequestBodyFolderEnum.Inbox,
      date: messagePreview.timestamp.getTime() / 1e3 - this.messageDateOffset,
      mailbox: Array.from(await this.userMailboxHasher(userMailbox)),
      // Note: 'hashedOwner' is only 'username' hash because there is no need for 'identity-key' because that is covered by 'mailbox'
      hashedOwner: Array.from(_chunk7575INAUjs.getAddressHash.call(void 0, addressHashes, ownerAddress, "username")),
      // Note: 'hashedFrom' takes only single type of hash because there is API type restriction, so 'identity-key' hash is proffered.
      hashedFrom: Array.from(_chunk7575INAUjs.getAddressHash.call(void 0, addressHashes, content.from.address, "identity-key", "username")),
      hashedTo: _chunk7575INAUjs.getMailAddressesHashes.call(void 0, addressHashes, to).map((h) => Array.from(h)),
      hashedCc: _chunk7575INAUjs.getMailAddressesHashes.call(void 0, addressHashes, cc).map((h) => Array.from(h)),
      hashedBcc: _chunk7575INAUjs.getMailAddressesHashes.call(void 0, addressHashes, bcc).map((h) => Array.from(h)),
      encryptedPreview: _encoding.encodeBase64.call(void 0, encryptedProtoMessagePreview),
      messageBodyResourceId: resourceId
    });
    return messagePreview;
  }
  async markOutboxMessageAsSent(messageId) {
    await this.modifySystemLabel(messageId, "outbox", false);
    await this.modifySystemLabel(messageId, "sent", true);
  }
  async modifyArchiveMessage(messageId, archived) {
    await this.modifySystemLabel(messageId, "archive", archived);
  }
  async modifyIsReadMessage(messageId, isRead) {
    await this.modifySystemLabel(messageId, "unread", !isRead);
  }
  async modifyTrashMessage(messageId, trash) {
    await this.modifySystemLabel(messageId, "trash", trash);
  }
  async modifyStarredMessage(messageId, isStarred) {
    await this.modifySystemLabel(messageId, "starred", isStarred);
  }
  async modifySpamMessage_unstable(messageId, isSpam) {
    await this.modifySystemLabel(messageId, "spam", isSpam);
  }
  async modifySystemLabel(messageId, systemLabel, include) {
    await this.modifyUserLabel(messageId, systemLabel, include);
  }
  async modifyUserLabel(messageId, userLabel, include) {
    if (include) {
      await this.inboxApi.putMessageLabel(messageId, userLabel);
    } else {
      await this.inboxApi.deleteMessageLabel(messageId, userLabel);
    }
  }
};
function createProtoMessagePreview(userMailbox, owner, content, snippetLength = 100) {
  return _chunkYQEYV6WAjs.preview.MessagePreview.create({
    owner: _addressing.formatAddress.call(void 0, owner, "mail"),
    mailbox: _crypto.publicKeyToBytes.call(void 0, userMailbox.identityKey),
    to: content.recipients.map((it) => it.address),
    cc: content.carbonCopyRecipients.map((it) => it.address),
    bcc: content.blindCarbonCopyRecipients.map((it) => it.address),
    from: content.from.address,
    subject: content.subject,
    snippet: createMessagePreviewSnippet(content, snippetLength),
    hasAttachment: false,
    // TODO: replace with value from content.attachment when available,
    timestamp: Math.round(content.date.getTime() / 1e3)
  });
}
function createMessagePreviewSnippet(content, snippetLength = 100) {
  const plainTextMessage = _striptags2.default.call(void 0, content.plainTextMessage).replace(/\s+/g, " ");
  return plainTextMessage.substring(0, snippetLength - 1).trim();
}



exports.MailchainMailboxOperations = MailchainMailboxOperations;
