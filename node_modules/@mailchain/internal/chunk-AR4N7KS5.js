"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }


var _chunkGDYJBQYGjs = require('./chunk-GDYJBQYG.js');

// src/messagingKeys/contractResolvers/near.ts
var _encoding = require('@mailchain/encoding');
var _crypto = require('@mailchain/crypto');
var _axios = require('axios'); var _axios2 = _interopRequireDefault(_axios);
var _addressing = require('@mailchain/addressing');
var NearContractCallResolver = class {
  constructor(rpcEndpoint, axiosInstance) {
    this.rpcEndpoint = rpcEndpoint;
    this.axiosInstance = axiosInstance;
  }
  static create(config, axiosInstance = _axios2.default.create()) {
    return new NearContractCallResolver(config.nearRpcUrl, axiosInstance);
  }
  async resolve(contract) {
    const rpcResponse = await this.callContract(contract);
    const result = _encoding.encodeUtf8.call(void 0, Uint8Array.from(rpcResponse.result));
    if (result === "null") {
      return { error: new (0, _chunkGDYJBQYGjs.MessagingKeyNotFoundInContractError)() };
    }
    const parsedResult = parseMessagingKeyContractResult(result);
    if (parsedResult.error != null) {
      return parsedResult;
    }
    return {
      data: {
        messagingKey: parsedResult.data.messagingKey,
        protocol: _addressing.NEAR,
        proof: {
          source: "ContractCall",
          call: contract
        }
      }
    };
  }
  async latestNonce(contract) {
    const rpcResponse = await this.callContract(contract);
    const result = _encoding.encodeUtf8.call(void 0, Uint8Array.from(rpcResponse.result));
    if (result === "null") {
      throw new (0, _chunkGDYJBQYGjs.MessagingKeyNotFoundInContractError)();
    }
    return parseInt(result, 10);
  }
  async callContract(contract) {
    if (contract.body.length === 0) {
      throw new Error("No body on contract call");
    }
    const body = _encoding.encodeUtf8.call(void 0, _encoding.decodeBase64.call(void 0, contract.body));
    const postData = JSON.parse(body);
    const response = await this.axiosInstance.request({
      method: contract.method,
      url: this.rpcEndpoint,
      data: postData
    });
    if (response.status !== 200) {
      throw new Error(
        `Failed to get messaging key from near, status: ${response.status}, response: ${response.data}`
      );
    }
    const { data } = response;
    if (data.result.error != null) {
      throw new Error(`Contract error; error=${data.result.error}`);
    }
    if (!data.result.result) {
      throw new Error(`No error but missing result response: ${data}`);
    }
    return data.result;
  }
};
function parseMessagingKeyContractResult(result) {
  const parsedResult = JSON.parse(result);
  if (typeof parsedResult !== "object") {
    return { error: new (0, _chunkGDYJBQYGjs.InvalidContractResponseError)("Object expected.") };
  }
  const [curve, messageKey] = parsedResult;
  if (curve == null || messageKey == null) {
    return { error: new (0, _chunkGDYJBQYGjs.InvalidContractResponseError)("Result does not have correct number of elements.") };
  }
  if (typeof curve !== "string") {
    return { error: new (0, _chunkGDYJBQYGjs.InvalidContractResponseError)("Curve format must be string.") };
  }
  if (typeof messageKey !== "string") {
    return { error: new (0, _chunkGDYJBQYGjs.InvalidContractResponseError)("Message key format must be string.") };
  }
  return { data: { messagingKey: _crypto.publicKeyFromKind.call(void 0, curve, _encoding.decodeHex.call(void 0, messageKey)) } };
}



exports.NearContractCallResolver = NearContractCallResolver;
