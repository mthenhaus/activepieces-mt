"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }






var _chunk5BV6SE35js = require('./chunk-5BV6SE35.js');


var _chunkHRZAPR6Djs = require('./chunk-HRZAPR6D.js');


var _chunkOJJVD4ZXjs = require('./chunk-OJJVD4ZX.js');


var _chunkQ4GRHUQHjs = require('./chunk-Q4GRHUQH.js');


var _chunkOO5CPMZPjs = require('./chunk-OO5CPMZP.js');


var _chunkQOTIAHF7js = require('./chunk-QOTIAHF7.js');

// src/user/userProfile.ts
var _encoding = require('@mailchain/encoding');







var _addressing = require('@mailchain/addressing');



var _crypto = require('@mailchain/crypto');
var _axios = require('axios');





var _api = require('@mailchain/api');
var UserNotFoundError = class extends Error {
  constructor() {
    super(`user not found for provided key`);
  }
};
var GENERIC_SETTINGS_GROUP = _api.PutUserSettingRequestBodyGroupEnum.Generic;
var CURRENT_MAILBOX_VERSION = 6;
var MailchainUserProfile = class {
  constructor(mailchainAddressDomain, userApi, accountIdentityKey, mailboxCrypto, settingsCrypto, migration) {
    this.mailchainAddressDomain = mailchainAddressDomain;
    this.userApi = userApi;
    this.accountIdentityKey = accountIdentityKey;
    this.mailboxCrypto = mailboxCrypto;
    this.settingsCrypto = settingsCrypto;
    this.migration = migration;
  }
  static create(config, accountIdentityKey, mailboxCrypto, settingsCrypto) {
    const axiosConfig = _api.createAxiosConfiguration.call(void 0, config.apiPath);
    const identityKeys = _chunkQOTIAHF7js.IdentityKeys.create(config);
    const userApi = _api.UserApiFactory.call(void 0, axiosConfig, void 0, _api.getAxiosWithSigner.call(void 0, accountIdentityKey));
    const nameservice = _chunkQ4GRHUQHjs.Nameservices.create(config);
    const migrations = _chunkOO5CPMZPjs.combineMigrations.call(void 0, 
      _chunk5BV6SE35js.createV2IdentityKey.call(void 0, identityKeys, config.mailchainAddressDomain),
      _chunk5BV6SE35js.createV3LabelMigration.call(void 0, config.mailchainAddressDomain),
      _chunk5BV6SE35js.createV4AliasesMigration.call(void 0, config.mailchainAddressDomain),
      _chunk5BV6SE35js.createV5NsMigration.call(void 0, nameservice),
      _chunk5BV6SE35js.createV6FixNsAliasFormatMigration.call(void 0, config.mailchainAddressDomain)
    );
    return new MailchainUserProfile(
      config.mailchainAddressDomain,
      userApi,
      () => Promise.resolve(accountIdentityKey.publicKey),
      mailboxCrypto,
      settingsCrypto,
      migrations
    );
  }
  async getUsername() {
    return this.userApi.getUsername().then((response) => {
      const { data } = response;
      return {
        address: data.address,
        username: data.username
      };
    }).catch((e) => {
      if (_optionalChain([e, 'access', _ => _.response, 'optionalAccess', _2 => _2.status]) === 404) {
        throw new UserNotFoundError();
      }
      throw e;
    });
  }
  async setSetting(key, value, opts) {
    const valueToStore = _optionalChain([opts, 'optionalAccess', _3 => _3.secure]) ? _encoding.encodeBase64.call(void 0, await this.settingsCrypto.encrypt(_encoding.decodeUtf8.call(void 0, value))) : value;
    await this.userApi.putUserSetting(key, {
      value: valueToStore,
      kind: _optionalChain([opts, 'optionalAccess', _4 => _4.secure]) ? "encrypted" : "string",
      group: _optionalChain([opts, 'optionalAccess', _5 => _5.group])
    });
  }
  async getSetting(key) {
    try {
      const { data } = await this.userApi.getUserSetting(key);
      return this.handleSettingsItem(data);
    } catch (e) {
      if (_axios.isAxiosError.call(void 0, e) && (_optionalChain([e, 'access', _6 => _6.response, 'optionalAccess', _7 => _7.status]) === 404 || _optionalChain([e, 'access', _8 => _8.response, 'optionalAccess', _9 => _9.status]) === 422)) {
        return void 0;
      }
      throw e;
    }
  }
  async getSettings(group) {
    try {
      const { data } = await this.userApi.getUserSettings(group);
      const result = /* @__PURE__ */ new Map();
      for (const setting of data.settings) {
        result.set(setting.name, await this.handleSettingsItem(setting));
      }
      return result;
    } catch (e) {
      if (_axios.isAxiosError.call(void 0, e) && _optionalChain([e, 'access', _10 => _10.response, 'optionalAccess', _11 => _11.status]) === 422) {
        return /* @__PURE__ */ new Map();
      }
      throw e;
    }
  }
  async handleSettingsItem(item) {
    if (item.kind === "encrypted" && item.value) {
      return {
        ...item,
        value: _encoding.encodeUtf8.call(void 0, await this.settingsCrypto.decrypt(_encoding.decodeBase64.call(void 0, item.value)))
      };
    }
    return item;
  }
  async deleteSetting(key) {
    await this.userApi.deleteUserSetting(key);
  }
  async mailboxes() {
    const { mailboxes: apiMailboxes } = await this.userApi.getUserMailboxes().then((r) => r.data);
    const resultMailboxes = [];
    for (const apiMailbox of apiMailboxes) {
      try {
        const decryptedMailbox = await this.mailboxCrypto.decrypt(
          _encoding.decodeBase64.call(void 0, apiMailbox.encryptedMailboxInformation)
        );
        const originalMailboxData = {
          version: apiMailbox.version,
          protoMailbox: _chunk5BV6SE35js.user.Mailbox.decode(decryptedMailbox)
        };
        const mailboxData = await this.migration.shouldApply(originalMailboxData) ? await this.migration.apply(originalMailboxData) : originalMailboxData;
        if (apiMailbox.version !== mailboxData.version) {
          console.debug(
            `${apiMailbox.mailboxId} migrated from v${apiMailbox.version} to v${mailboxData.version}`
          );
          this.internalUpdateMailbox(
            apiMailbox.mailboxId,
            mailboxData.protoMailbox,
            mailboxData.version
          ).then(
            () => console.debug(`successfully stored migrated mailbox ${apiMailbox.mailboxId}`),
            (e) => console.warn(`failed storing migrated mailbox ${apiMailbox.mailboxId}`, e)
          );
        }
        const { protoMailbox } = mailboxData;
        const protocol = protoMailbox.protocol;
        const encodedAddress = _addressing.encodeAddressByProtocol.call(void 0, protoMailbox.address, protocol).encoded;
        const fallbackAlias = _chunkOJJVD4ZXjs.createMailboxAlias.call(void 0, 
          _addressing.createWalletAddress.call(void 0, encodedAddress, protocol, this.mailchainAddressDomain)
        );
        const mailboxAliases = protoMailbox.aliases.map(_chunk5BV6SE35js.user.Mailbox.Alias.create).map((protoAlias) => {
          return _chunkOJJVD4ZXjs.createMailboxAlias.call(void 0, _addressing.parseNameServiceAddress.call(void 0, protoAlias.address), {
            allowSending: !protoAlias.blockSending,
            allowReceiving: !protoAlias.blockReceiving
          });
        });
        resultMailboxes.push({
          type: "wallet",
          id: apiMailbox.mailboxId,
          identityKey: _crypto.publicKeyFromBytes.call(void 0, protoMailbox.identityKey),
          label: _nullishCoalesce(protoMailbox.label, () => ( null)),
          aliases: mailboxAliases.length > 0 ? mailboxAliases : [fallbackAlias],
          messagingKeyParams: {
            address: protoMailbox.address,
            protocol,
            network: protoMailbox.network,
            nonce: protoMailbox.nonce
          }
        });
      } catch (e) {
        console.error(`failed processing mailbox ${apiMailbox.mailboxId}`, e);
      }
    }
    return [await this.accountMailbox(), ...resultMailboxes];
  }
  async accountMailbox() {
    const { username, address } = await this.getUsername();
    const addressAlias = _chunkOJJVD4ZXjs.createMailboxAlias.call(void 0, _addressing.createWalletAddress.call(void 0, username, _addressing.MAILCHAIN, this.mailchainAddressDomain));
    return {
      type: "account",
      id: address,
      identityKey: await this.accountIdentityKey(),
      label: null,
      aliases: [addressAlias],
      messagingKeyParams: {
        address: _addressing.decodeAddressByProtocol.call(void 0, username, _addressing.MAILCHAIN).decoded,
        protocol: _addressing.MAILCHAIN,
        network: this.mailchainAddressDomain,
        nonce: 1
      }
    };
  }
  async addMailbox(mailbox) {
    const consolidatedMailbox = _chunkHRZAPR6Djs.consolidateMailbox.call(void 0, mailbox);
    const protoMailbox = createProtoUserMailbox(consolidatedMailbox);
    const encrypted = await this.mailboxCrypto.encrypt(_chunk5BV6SE35js.user.Mailbox.encode(protoMailbox).finish());
    const { mailboxId } = await this.userApi.postUserMailbox({ encryptedMailboxInformation: _encoding.encodeBase64.call(void 0, encrypted), version: CURRENT_MAILBOX_VERSION }).then((res) => res.data);
    return { ...consolidatedMailbox, type: "wallet", id: mailboxId };
  }
  async updateMailbox(mailboxId, mailbox) {
    const consolidatedMailbox = _chunkHRZAPR6Djs.consolidateMailbox.call(void 0, mailbox);
    const protoMailbox = createProtoUserMailbox(consolidatedMailbox);
    await this.internalUpdateMailbox(mailboxId, protoMailbox, CURRENT_MAILBOX_VERSION);
    return { id: mailboxId, type: "wallet", ...consolidatedMailbox };
  }
  async removeMailbox(mailboxId) {
    await this.userApi.deleteUserMailbox(mailboxId);
    return;
  }
  async internalUpdateMailbox(addressId, protoMailbox, version) {
    const encrypted = await this.mailboxCrypto.encrypt(_chunk5BV6SE35js.user.Mailbox.encode(protoMailbox).finish());
    await this.userApi.putUserMailbox(addressId, { encryptedMailboxInformation: _encoding.encodeBase64.call(void 0, encrypted), version });
    return protoMailbox;
  }
};
function createProtoUserMailbox(mailbox) {
  return _chunk5BV6SE35js.user.Mailbox.create({
    identityKey: _crypto.publicKeyToBytes.call(void 0, mailbox.identityKey),
    address: mailbox.messagingKeyParams.address,
    protocol: mailbox.messagingKeyParams.protocol,
    network: mailbox.messagingKeyParams.network,
    nonce: mailbox.messagingKeyParams.nonce,
    label: mailbox.label,
    aliases: mailbox.aliases.map(createProtoAlias)
  });
}
function createProtoAlias(alias) {
  return _chunk5BV6SE35js.user.Mailbox.Alias.create({
    address: _addressing.formatAddress.call(void 0, alias.address, "mail"),
    blockSending: !alias.allowSending,
    blockReceiving: !alias.allowReceiving
  });
}





exports.UserNotFoundError = UserNotFoundError; exports.GENERIC_SETTINGS_GROUP = GENERIC_SETTINGS_GROUP; exports.MailchainUserProfile = MailchainUserProfile;
