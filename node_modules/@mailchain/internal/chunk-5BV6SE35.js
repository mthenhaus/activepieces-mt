"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }// src/user/migrations.ts






var _addressing = require('@mailchain/addressing');
var _nameservices = require('@mailchain/addressing/nameservices');
var _crypto = require('@mailchain/crypto');
var _encoding = require('@mailchain/encoding');

// src/protobuf/user/user.js
var _minimaljs = require('protobufjs/minimal.js'); var _minimaljs2 = _interopRequireDefault(_minimaljs);
var $Reader = _minimaljs2.default.Reader;
var $Writer = _minimaljs2.default.Writer;
var $util = _minimaljs2.default.util;
var $root = _minimaljs2.default.roots["default"] || (_minimaljs2.default.roots["default"] = {});
var user = $root.user = (() => {
  const user2 = {};
  user2.Mailbox = function() {
    function Mailbox(properties) {
      this.aliases = [];
      if (properties) {
        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          if (properties[keys[i]] != null)
            this[keys[i]] = properties[keys[i]];
      }
    }
    Mailbox.prototype.address = $util.newBuffer([]);
    Mailbox.prototype.nonce = 0;
    Mailbox.prototype.protocol = "";
    Mailbox.prototype.network = "";
    Mailbox.prototype.identityKey = $util.newBuffer([]);
    Mailbox.prototype.label = null;
    Mailbox.prototype.aliases = $util.emptyArray;
    let $oneOfFields;
    Object.defineProperty(Mailbox.prototype, "_label", {
      get: $util.oneOfGetter($oneOfFields = ["label"]),
      set: $util.oneOfSetter($oneOfFields)
    });
    Mailbox.create = function create(properties) {
      return new Mailbox(properties);
    };
    Mailbox.encode = function encode(message, writer) {
      if (!writer)
        writer = $Writer.create();
      if (message.address != null && Object.hasOwnProperty.call(message, "address"))
        writer.uint32(
          /* id 1, wireType 2 =*/
          10
        ).bytes(message.address);
      if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
        writer.uint32(
          /* id 2, wireType 0 =*/
          16
        ).uint32(message.nonce);
      if (message.protocol != null && Object.hasOwnProperty.call(message, "protocol"))
        writer.uint32(
          /* id 3, wireType 2 =*/
          26
        ).string(message.protocol);
      if (message.network != null && Object.hasOwnProperty.call(message, "network"))
        writer.uint32(
          /* id 4, wireType 2 =*/
          34
        ).string(message.network);
      if (message.identityKey != null && Object.hasOwnProperty.call(message, "identityKey"))
        writer.uint32(
          /* id 5, wireType 2 =*/
          42
        ).bytes(message.identityKey);
      if (message.label != null && Object.hasOwnProperty.call(message, "label"))
        writer.uint32(
          /* id 6, wireType 2 =*/
          50
        ).string(message.label);
      if (message.aliases != null && message.aliases.length)
        for (let i = 0; i < message.aliases.length; ++i)
          $root.user.Mailbox.Alias.encode(message.aliases[i], writer.uint32(
            /* id 7, wireType 2 =*/
            58
          ).fork()).ldelim();
      return writer;
    };
    Mailbox.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer).ldelim();
    };
    Mailbox.decode = function decode(reader, length) {
      if (!(reader instanceof $Reader))
        reader = $Reader.create(reader);
      let end = length === void 0 ? reader.len : reader.pos + length, message = new $root.user.Mailbox();
      while (reader.pos < end) {
        let tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            message.address = reader.bytes();
            break;
          }
          case 2: {
            message.nonce = reader.uint32();
            break;
          }
          case 3: {
            message.protocol = reader.string();
            break;
          }
          case 4: {
            message.network = reader.string();
            break;
          }
          case 5: {
            message.identityKey = reader.bytes();
            break;
          }
          case 6: {
            message.label = reader.string();
            break;
          }
          case 7: {
            if (!(message.aliases && message.aliases.length))
              message.aliases = [];
            message.aliases.push($root.user.Mailbox.Alias.decode(reader, reader.uint32()));
            break;
          }
          default:
            reader.skipType(tag & 7);
            break;
        }
      }
      return message;
    };
    Mailbox.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof $Reader))
        reader = new $Reader(reader);
      return this.decode(reader, reader.uint32());
    };
    Mailbox.verify = function verify(message) {
      if (typeof message !== "object" || message === null)
        return "object expected";
      let properties = {};
      if (message.address != null && message.hasOwnProperty("address")) {
        if (!(message.address && typeof message.address.length === "number" || $util.isString(message.address)))
          return "address: buffer expected";
      }
      if (message.nonce != null && message.hasOwnProperty("nonce")) {
        if (!$util.isInteger(message.nonce))
          return "nonce: integer expected";
      }
      if (message.protocol != null && message.hasOwnProperty("protocol")) {
        if (!$util.isString(message.protocol))
          return "protocol: string expected";
      }
      if (message.network != null && message.hasOwnProperty("network")) {
        if (!$util.isString(message.network))
          return "network: string expected";
      }
      if (message.identityKey != null && message.hasOwnProperty("identityKey")) {
        if (!(message.identityKey && typeof message.identityKey.length === "number" || $util.isString(message.identityKey)))
          return "identityKey: buffer expected";
      }
      if (message.label != null && message.hasOwnProperty("label")) {
        properties._label = 1;
        if (!$util.isString(message.label))
          return "label: string expected";
      }
      if (message.aliases != null && message.hasOwnProperty("aliases")) {
        if (!Array.isArray(message.aliases))
          return "aliases: array expected";
        for (let i = 0; i < message.aliases.length; ++i) {
          let error = $root.user.Mailbox.Alias.verify(message.aliases[i]);
          if (error)
            return "aliases." + error;
        }
      }
      return null;
    };
    Mailbox.fromObject = function fromObject(object) {
      if (object instanceof $root.user.Mailbox)
        return object;
      let message = new $root.user.Mailbox();
      if (object.address != null) {
        if (typeof object.address === "string")
          $util.base64.decode(object.address, message.address = $util.newBuffer($util.base64.length(object.address)), 0);
        else if (object.address.length >= 0)
          message.address = object.address;
      }
      if (object.nonce != null)
        message.nonce = object.nonce >>> 0;
      if (object.protocol != null)
        message.protocol = String(object.protocol);
      if (object.network != null)
        message.network = String(object.network);
      if (object.identityKey != null) {
        if (typeof object.identityKey === "string")
          $util.base64.decode(object.identityKey, message.identityKey = $util.newBuffer($util.base64.length(object.identityKey)), 0);
        else if (object.identityKey.length >= 0)
          message.identityKey = object.identityKey;
      }
      if (object.label != null)
        message.label = String(object.label);
      if (object.aliases) {
        if (!Array.isArray(object.aliases))
          throw TypeError(".user.Mailbox.aliases: array expected");
        message.aliases = [];
        for (let i = 0; i < object.aliases.length; ++i) {
          if (typeof object.aliases[i] !== "object")
            throw TypeError(".user.Mailbox.aliases: object expected");
          message.aliases[i] = $root.user.Mailbox.Alias.fromObject(object.aliases[i]);
        }
      }
      return message;
    };
    Mailbox.toObject = function toObject(message, options) {
      if (!options)
        options = {};
      let object = {};
      if (options.arrays || options.defaults)
        object.aliases = [];
      if (options.defaults) {
        if (options.bytes === String)
          object.address = "";
        else {
          object.address = [];
          if (options.bytes !== Array)
            object.address = $util.newBuffer(object.address);
        }
        object.nonce = 0;
        object.protocol = "";
        object.network = "";
        if (options.bytes === String)
          object.identityKey = "";
        else {
          object.identityKey = [];
          if (options.bytes !== Array)
            object.identityKey = $util.newBuffer(object.identityKey);
        }
      }
      if (message.address != null && message.hasOwnProperty("address"))
        object.address = options.bytes === String ? $util.base64.encode(message.address, 0, message.address.length) : options.bytes === Array ? Array.prototype.slice.call(message.address) : message.address;
      if (message.nonce != null && message.hasOwnProperty("nonce"))
        object.nonce = message.nonce;
      if (message.protocol != null && message.hasOwnProperty("protocol"))
        object.protocol = message.protocol;
      if (message.network != null && message.hasOwnProperty("network"))
        object.network = message.network;
      if (message.identityKey != null && message.hasOwnProperty("identityKey"))
        object.identityKey = options.bytes === String ? $util.base64.encode(message.identityKey, 0, message.identityKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.identityKey) : message.identityKey;
      if (message.label != null && message.hasOwnProperty("label")) {
        object.label = message.label;
        if (options.oneofs)
          object._label = "label";
      }
      if (message.aliases && message.aliases.length) {
        object.aliases = [];
        for (let j = 0; j < message.aliases.length; ++j)
          object.aliases[j] = $root.user.Mailbox.Alias.toObject(message.aliases[j], options);
      }
      return object;
    };
    Mailbox.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, _minimaljs2.default.util.toJSONOptions);
    };
    Mailbox.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
      if (typeUrlPrefix === void 0) {
        typeUrlPrefix = "type.googleapis.com";
      }
      return typeUrlPrefix + "/user.Mailbox";
    };
    Mailbox.Alias = function() {
      function Alias(properties) {
        if (properties) {
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      Alias.prototype.address = "";
      Alias.prototype.blockSending = false;
      Alias.prototype.blockReceiving = false;
      Alias.create = function create(properties) {
        return new Alias(properties);
      };
      Alias.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.address != null && Object.hasOwnProperty.call(message, "address"))
          writer.uint32(
            /* id 1, wireType 2 =*/
            10
          ).string(message.address);
        if (message.blockSending != null && Object.hasOwnProperty.call(message, "blockSending"))
          writer.uint32(
            /* id 2, wireType 0 =*/
            16
          ).bool(message.blockSending);
        if (message.blockReceiving != null && Object.hasOwnProperty.call(message, "blockReceiving"))
          writer.uint32(
            /* id 3, wireType 0 =*/
            24
          ).bool(message.blockReceiving);
        return writer;
      };
      Alias.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      Alias.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        let end = length === void 0 ? reader.len : reader.pos + length, message = new $root.user.Mailbox.Alias();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              message.address = reader.string();
              break;
            }
            case 2: {
              message.blockSending = reader.bool();
              break;
            }
            case 3: {
              message.blockReceiving = reader.bool();
              break;
            }
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      Alias.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      Alias.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.address != null && message.hasOwnProperty("address")) {
          if (!$util.isString(message.address))
            return "address: string expected";
        }
        if (message.blockSending != null && message.hasOwnProperty("blockSending")) {
          if (typeof message.blockSending !== "boolean")
            return "blockSending: boolean expected";
        }
        if (message.blockReceiving != null && message.hasOwnProperty("blockReceiving")) {
          if (typeof message.blockReceiving !== "boolean")
            return "blockReceiving: boolean expected";
        }
        return null;
      };
      Alias.fromObject = function fromObject(object) {
        if (object instanceof $root.user.Mailbox.Alias)
          return object;
        let message = new $root.user.Mailbox.Alias();
        if (object.address != null)
          message.address = String(object.address);
        if (object.blockSending != null)
          message.blockSending = Boolean(object.blockSending);
        if (object.blockReceiving != null)
          message.blockReceiving = Boolean(object.blockReceiving);
        return message;
      };
      Alias.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        let object = {};
        if (options.defaults) {
          object.address = "";
          object.blockSending = false;
          object.blockReceiving = false;
        }
        if (message.address != null && message.hasOwnProperty("address"))
          object.address = message.address;
        if (message.blockSending != null && message.hasOwnProperty("blockSending"))
          object.blockSending = message.blockSending;
        if (message.blockReceiving != null && message.hasOwnProperty("blockReceiving"))
          object.blockReceiving = message.blockReceiving;
        return object;
      };
      Alias.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, _minimaljs2.default.util.toJSONOptions);
      };
      Alias.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === void 0) {
          typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/user.Mailbox.Alias";
      };
      return Alias;
    }();
    return Mailbox;
  }();
  return user2;
})();

// src/user/migrations.ts
function createV2IdentityKey(identityKeys, mailchainAddressDomain) {
  return {
    shouldApply: (data) => Promise.resolve(data.version === 1),
    apply: async ({ protoMailbox }) => {
      const protocol = protoMailbox.protocol;
      const encodedAddress = _addressing.encodeAddressByProtocol.call(void 0, protoMailbox.address, protocol).encoded;
      const result = await identityKeys.getAddressIdentityKey(
        _addressing.createWalletAddress.call(void 0, encodedAddress, protocol, mailchainAddressDomain)
      );
      if (result == null)
        throw new Error(`no identity key fround for address [${encodedAddress}]`);
      return {
        version: 2,
        protoMailbox: user.Mailbox.create({
          ...protoMailbox,
          identityKey: _crypto.publicKeyToBytes.call(void 0, result.identityKey)
        })
      };
    }
  };
}
function createV3LabelMigration(_mailchainAddressDomain) {
  return {
    shouldApply: (data) => Promise.resolve(data.version === 2),
    apply: (data) => Promise.resolve({
      version: 3,
      protoMailbox: user.Mailbox.create({
        ...data.protoMailbox,
        label: null
      })
    })
  };
}
function createV4AliasesMigration(mailchainAddressDomain) {
  return {
    shouldApply: (data) => Promise.resolve(data.version === 3),
    apply: (data) => {
      const { protoMailbox } = data;
      const protocol = protoMailbox.protocol;
      const encodedAddress = _addressing.encodeAddressByProtocol.call(void 0, protoMailbox.address, protocol).encoded;
      const address = _addressing.formatAddress.call(void 0, 
        _addressing.createWalletAddress.call(void 0, encodedAddress, protocol, mailchainAddressDomain),
        "mail"
      );
      return Promise.resolve({
        version: 4,
        protoMailbox: user.Mailbox.create({
          ...protoMailbox,
          aliases: [{ address, blockSending: false, blockReceiving: false }]
        })
      });
    }
  };
}
function createV5NsMigration(nameservices) {
  return {
    shouldApply: (data) => Promise.resolve(data.version === 4),
    apply: async ({ protoMailbox }) => {
      const identityKey = _crypto.publicKeyFromBytes.call(void 0, protoMailbox.identityKey);
      try {
        const foundNames = await nameservices.reverseResolveNames(identityKey);
        const aliases = [...protoMailbox.aliases];
        for (const { address } of foundNames) {
          const aliasAddress = _addressing.formatAddress.call(void 0, address, "mail");
          if (aliases.some((alias2) => alias2.address === aliasAddress))
            continue;
          const alias = user.Mailbox.Alias.create({
            address: aliasAddress,
            blockSending: false,
            blockReceiving: false
          });
          aliases.push(alias);
        }
        return { version: 5, protoMailbox: user.Mailbox.create({ ...protoMailbox, aliases }) };
      } catch (e) {
        console.warn(
          `failed reverse search for identity key ${_encoding.encodeHexZeroX.call(void 0, 
            protoMailbox.identityKey
          )}. Will bump version without storing NS aliases`
        );
        return { version: 5, protoMailbox };
      }
    }
  };
}
function createV6FixNsAliasFormatMigration(mailchainAddressDomain) {
  return {
    shouldApply: (data) => Promise.resolve(data.version === 5),
    apply: (data) => {
      const aliases = data.protoMailbox.aliases.map((a) => {
        if (a.address == null)
          return a;
        const address = _addressing.parseNameServiceAddress.call(void 0, a.address);
        if (address.domain !== mailchainAddressDomain)
          return a;
        for (const nsDesc of _nameservices.NAMESERVICE_DESCRIPTIONS) {
          const nsAddress = _addressing.createNameServiceAddress.call(void 0, address.username, nsDesc.name, address.domain);
          const matchingDomain = _nameservices.matchesNameservice.call(void 0, nsAddress, nsDesc);
          if (matchingDomain != null) {
            return user.Mailbox.Alias.create({ ...a, address: _addressing.formatAddress.call(void 0, nsAddress, "mail") });
          }
        }
        return a;
      });
      return Promise.resolve({
        version: 6,
        protoMailbox: user.Mailbox.create({ ...data.protoMailbox, aliases })
      });
    }
  };
}








exports.user = user; exports.createV2IdentityKey = createV2IdentityKey; exports.createV3LabelMigration = createV3LabelMigration; exports.createV4AliasesMigration = createV4AliasesMigration; exports.createV5NsMigration = createV5NsMigration; exports.createV6FixNsAliasFormatMigration = createV6FixNsAliasFormatMigration;
