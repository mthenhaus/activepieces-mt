import {
  IdentityKeys
} from "./chunk-7AQ4G6HT.mjs";

// src/nameservices/nameservices.ts
import { publicKeyToBytes, isPublicKeyEqual } from "@mailchain/crypto";
import { encodeHexZeroX } from "@mailchain/encoding";
import {
  checkAddressForErrors,
  formatAddress,
  isTokenAddress,
  parseNameServiceAddress,
  createNameServiceAddress,
  ETHEREUM,
  SOLANA,
  TEZOS
} from "@mailchain/addressing";
import { NAMESERVICE_DESCRIPTIONS } from "@mailchain/addressing/nameservices";
import { IdentityKeysApiFactory, createAxiosConfiguration } from "@mailchain/api";
var PROTOCOLS_SUPPORTING_NAMESERVICE = [ETHEREUM, TEZOS, SOLANA];
var Nameservices = class {
  constructor(identityKeysApi, identityKeysService, mailchainAddressDomain) {
    this.identityKeysApi = identityKeysApi;
    this.identityKeysService = identityKeysService;
    this.mailchainAddressDomain = mailchainAddressDomain;
  }
  static create(config) {
    const identityKeysApi = IdentityKeysApiFactory(createAxiosConfiguration(config.apiPath));
    const identityKeysService = IdentityKeys.create(config);
    return new Nameservices(identityKeysApi, identityKeysService, config.mailchainAddressDomain);
  }
  async reverseResolveNames(identityKey, kind) {
    return this.identityKeysApi.getIdentityKeyResolvableNames(encodeHexZeroX(publicKeyToBytes(identityKey)), kind).then(({ data }) => {
      return (data.resolvableNames ?? []).map((resolved) => ({
        kind: resolved.kind,
        address: parseNameServiceAddress(resolved.fullAddress),
        resolver: resolved.resolver,
        metadata: resolved.metadata ?? void 0
      }));
    });
  }
  async nameResolvesToMailbox(nsName, mailboxIdentityKey) {
    for (const nsDesc of NAMESERVICE_DESCRIPTIONS) {
      const nsAddress = createNameServiceAddress(nsName, nsDesc.name, this.mailchainAddressDomain);
      try {
        const addressIdentityKey = await this.identityKeysService.getAddressIdentityKey(nsAddress);
        if (addressIdentityKey != null && isPublicKeyEqual(addressIdentityKey.identityKey, mailboxIdentityKey)) {
          return nsAddress;
        }
      } catch (e) {
        console.log(`failed to resolve address: ${formatAddress(nsAddress, "mail")}`, e);
      }
    }
    return null;
  }
  async tokenResolvesToMailbox(tokenId, contractAddress, mailbox) {
    const { protocol } = mailbox.messagingKeyParams;
    const contractNsAddress = createNameServiceAddress(contractAddress, protocol, this.mailchainAddressDomain);
    const contractAddressError = checkAddressForErrors(
      formatAddress(contractNsAddress, "mail"),
      this.mailchainAddressDomain
    );
    if (contractAddressError != null) {
      throw new Error(`Invalid contract address ${contractAddress} for protocol ${protocol}`);
    }
    const tokenNsAddress = createNameServiceAddress(
      `${tokenId}.${contractAddress}`,
      protocol,
      this.mailchainAddressDomain
    );
    if (!isTokenAddress(tokenNsAddress)) {
      throw new Error(`Invalid address ${formatAddress(tokenNsAddress, "mail")}`);
    }
    try {
      const tokenAddressIdentityKey = await this.identityKeysService.getAddressIdentityKey(tokenNsAddress);
      if (tokenAddressIdentityKey != null && isPublicKeyEqual(tokenAddressIdentityKey.identityKey, mailbox.identityKey)) {
        return tokenNsAddress;
      }
    } catch (e) {
      console.log(`failed to resolve address: ${formatAddress(tokenNsAddress, "mail")}`, e);
    }
    return null;
  }
};

export {
  PROTOCOLS_SUPPORTING_NAMESERVICE,
  Nameservices
};
