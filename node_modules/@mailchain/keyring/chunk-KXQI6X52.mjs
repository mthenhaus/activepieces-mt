import {
  DERIVATION_PATH_DATE_OFFSET,
  DERIVATION_PATH_ENCRYPTION_KEY_ROOT,
  DERIVATION_PATH_IDENTITY_KEY_ROOT,
  DERIVATION_PATH_INBOX_ROOT,
  DERIVATION_PATH_MESSAGING_KEY_ROOT,
  DERIVATION_PATH_USER_PROFILE,
  DERIVATION_PATH_USER_PROFILE_SETTINGS
} from "./chunk-LZ2TUDZT.mjs";
import {
  ecdhKeyRingDecrypter
} from "./chunk-2WOOVKGU.mjs";
import {
  __publicField
} from "./chunk-NHABU752.mjs";

// src/keyring.ts
import {
  PrivateKeyDecrypter,
  PrivateKeyEncrypter,
  ED25519PrivateKey,
  deriveHardenedKey,
  ED25519ExtendedPrivateKey
} from "@mailchain/crypto";
import { encodeHex, encodeHexZeroX } from "@mailchain/encoding";
import { decodeAddressByProtocol, MAILCHAIN } from "@mailchain/addressing";
var KeyRing = class {
  /**
   *
   * @param accountKey This key is never stored in the key chain only used to derive other keys.
   */
  constructor(accountKey) {
    __publicField(this, "_accountIdentityKey");
    __publicField(this, "_rootEncryptionKey");
    __publicField(this, "_rootUserProfileEncryptionKey");
    __publicField(this, "_userMailboxEncryptionKey");
    __publicField(this, "_userSettingsEncryptionKey");
    __publicField(this, "_rootInboxKey");
    // used to derive messaging keys for all protocol addresses
    __publicField(this, "_protocolAddressRootMessagingKey");
    __publicField(this, "_accountMessagingKey");
    this._accountIdentityKey = deriveHardenedKey(
      ED25519ExtendedPrivateKey.fromPrivateKey(accountKey),
      DERIVATION_PATH_IDENTITY_KEY_ROOT
    );
    const rootMessagingKey = deriveHardenedKey(
      ED25519ExtendedPrivateKey.fromPrivateKey(accountKey),
      DERIVATION_PATH_MESSAGING_KEY_ROOT
    );
    this._protocolAddressRootMessagingKey = deriveHardenedKey(
      ED25519ExtendedPrivateKey.fromPrivateKey(rootMessagingKey.privateKey),
      1
    );
    const rootAccountMessagingKey = deriveHardenedKey(
      ED25519ExtendedPrivateKey.fromPrivateKey(rootMessagingKey.privateKey),
      "protocol=mailchain"
    );
    this._accountMessagingKey = deriveHardenedKey(
      ED25519ExtendedPrivateKey.fromPrivateKey(rootAccountMessagingKey.privateKey),
      1
    );
    this._rootEncryptionKey = deriveHardenedKey(
      ED25519ExtendedPrivateKey.fromPrivateKey(accountKey),
      DERIVATION_PATH_ENCRYPTION_KEY_ROOT
    );
    this._rootUserProfileEncryptionKey = deriveHardenedKey(
      ED25519ExtendedPrivateKey.fromPrivateKey(this._rootEncryptionKey.privateKey),
      DERIVATION_PATH_USER_PROFILE
    );
    this._userSettingsEncryptionKey = deriveHardenedKey(
      ED25519ExtendedPrivateKey.fromPrivateKey(this._rootUserProfileEncryptionKey.privateKey),
      DERIVATION_PATH_USER_PROFILE_SETTINGS
    );
    this._userMailboxEncryptionKey = this._rootUserProfileEncryptionKey;
    this._rootInboxKey = deriveHardenedKey(
      ED25519ExtendedPrivateKey.fromPrivateKey(this._rootEncryptionKey.privateKey),
      DERIVATION_PATH_INBOX_ROOT
    );
  }
  /**
   * Use your Secret Recovery Phrase to authenticate your keyring.
   * @param secretRecoveryPhrase a 24 word [BIP 39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki) compatible mnemonic phrase.
   */
  static fromSecretRecoveryPhrase(secretRecoveryPhrase, password) {
    return new this(ED25519PrivateKey.fromMnemonicPhrase(secretRecoveryPhrase, password));
  }
  static fromPrivateKey(key) {
    return new this(key);
  }
  rootEncryptionPublicKey() {
    return this._rootEncryptionKey.privateKey.publicKey;
  }
  rootInboxKey() {
    return this._rootInboxKey.privateKey;
  }
  inboxMessageDateOffset() {
    const year2000 = 946684800;
    const offsetKey = deriveHardenedKey(
      ED25519ExtendedPrivateKey.fromPrivateKey(this._rootInboxKey.privateKey),
      DERIVATION_PATH_DATE_OFFSET
    );
    const offset = Number(BigInt(encodeHexZeroX(offsetKey.bytes)) % BigInt(year2000));
    return offset;
  }
  inboxKey() {
    const inboxKey = this._rootInboxKey.privateKey;
    const decrypter = PrivateKeyDecrypter.fromPrivateKey(inboxKey);
    const encrypter = PrivateKeyEncrypter.fromPrivateKey(inboxKey);
    return { encrypt: (input) => encrypter.encrypt(input), decrypt: (input) => decrypter.decrypt(input) };
  }
  /**
   * Crypto operations for encrypting and decrypting the persisted data of the user mailboxes.
   */
  userMailboxCrypto() {
    const mailboxKey = this._userMailboxEncryptionKey.privateKey;
    const decrypter = PrivateKeyDecrypter.fromPrivateKey(mailboxKey);
    const encrypter = PrivateKeyEncrypter.fromPrivateKey(mailboxKey);
    return { encrypt: (input) => encrypter.encrypt(input), decrypt: (input) => decrypter.decrypt(input) };
  }
  /**
   * Crypto operations for encrypting and decrypting the persisted data of the user settings.
   */
  userSettingsCrypto() {
    const mailboxKey = this._userSettingsEncryptionKey.privateKey;
    const decrypter = PrivateKeyDecrypter.fromPrivateKey(mailboxKey);
    const encrypter = PrivateKeyEncrypter.fromPrivateKey(mailboxKey);
    return { encrypt: (input) => encrypter.encrypt(input), decrypt: (input) => decrypter.decrypt(input) };
  }
  /**
   * Gets messaging key that can be used for signing and decrypting for a specific protocol address.
   * @param address protocol address e.g. 0x1234.... for ethereum.
   * @param protocol a {@link ProtocolType}
   * @param nonce in most cases you will want to use the latest nonce.
   * @returns
   */
  addressMessagingKey(address, protocol, nonce) {
    const decodedAddress = decodeAddressByProtocol(address, protocol).decoded;
    return this.addressBytesMessagingKey(decodedAddress, protocol, nonce);
  }
  /**
   * Gets messaging key that can be exported for a specific protocol address.
   * @param address protocol address e.g. 0x1234.... for ethereum
   * @param protocol a {@link ProtocolType}
   * @param nonce in most cases you will want to use the latest nonce.
   * @returns
   */
  addressExportableMessagingKey(address, protocol, nonce) {
    const decodedAddress = decodeAddressByProtocol(address, protocol).decoded;
    return this.addressBytesExportableMessagingKey(decodedAddress, protocol, nonce);
  }
  addressBytesMessagingKey(address, protocol, nonce) {
    const addressKey = this.addressBytesExportableMessagingKey(address, protocol, nonce);
    return ecdhKeyRingDecrypter(addressKey);
  }
  addressBytesExportableMessagingKey(address, protocol, nonce) {
    if (protocol === MAILCHAIN) {
      return this.accountExportableMessagingKey();
    }
    const addressKeyRoot = deriveHardenedKey(
      this._protocolAddressRootMessagingKey,
      `protocol=${protocol},address=${encodeHex(address)}`
    );
    return deriveHardenedKey(addressKeyRoot, nonce).privateKey;
  }
  accountExportableMessagingKey() {
    return this._accountMessagingKey.privateKey;
  }
  accountMessagingKey() {
    const key = this.accountExportableMessagingKey();
    return ecdhKeyRingDecrypter(key);
  }
  accountIdentityKey() {
    const key = this._accountIdentityKey.privateKey;
    return {
      curve: key.curve,
      sign: (input) => key.sign(input),
      publicKey: key.publicKey
    };
  }
};

export {
  KeyRing
};
