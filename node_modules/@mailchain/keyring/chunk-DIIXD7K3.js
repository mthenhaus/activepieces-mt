"use strict";Object.defineProperty(exports, "__esModule", {value: true});







var _chunkCXGOL37Pjs = require('./chunk-CXGOL37P.js');


var _chunk74WFEZ7Pjs = require('./chunk-74WFEZ7P.js');


var _chunkXXPGZHWZjs = require('./chunk-XXPGZHWZ.js');

// src/keyring.ts






var _crypto = require('@mailchain/crypto');
var _encoding = require('@mailchain/encoding');
var _addressing = require('@mailchain/addressing');
var KeyRing = class {
  /**
   *
   * @param accountKey This key is never stored in the key chain only used to derive other keys.
   */
  constructor(accountKey) {
    _chunkXXPGZHWZjs.__publicField.call(void 0, this, "_accountIdentityKey");
    _chunkXXPGZHWZjs.__publicField.call(void 0, this, "_rootEncryptionKey");
    _chunkXXPGZHWZjs.__publicField.call(void 0, this, "_rootUserProfileEncryptionKey");
    _chunkXXPGZHWZjs.__publicField.call(void 0, this, "_userMailboxEncryptionKey");
    _chunkXXPGZHWZjs.__publicField.call(void 0, this, "_userSettingsEncryptionKey");
    _chunkXXPGZHWZjs.__publicField.call(void 0, this, "_rootInboxKey");
    // used to derive messaging keys for all protocol addresses
    _chunkXXPGZHWZjs.__publicField.call(void 0, this, "_protocolAddressRootMessagingKey");
    _chunkXXPGZHWZjs.__publicField.call(void 0, this, "_accountMessagingKey");
    this._accountIdentityKey = _crypto.deriveHardenedKey.call(void 0, 
      _crypto.ED25519ExtendedPrivateKey.fromPrivateKey(accountKey),
      _chunkCXGOL37Pjs.DERIVATION_PATH_IDENTITY_KEY_ROOT
    );
    const rootMessagingKey = _crypto.deriveHardenedKey.call(void 0, 
      _crypto.ED25519ExtendedPrivateKey.fromPrivateKey(accountKey),
      _chunkCXGOL37Pjs.DERIVATION_PATH_MESSAGING_KEY_ROOT
    );
    this._protocolAddressRootMessagingKey = _crypto.deriveHardenedKey.call(void 0, 
      _crypto.ED25519ExtendedPrivateKey.fromPrivateKey(rootMessagingKey.privateKey),
      1
    );
    const rootAccountMessagingKey = _crypto.deriveHardenedKey.call(void 0, 
      _crypto.ED25519ExtendedPrivateKey.fromPrivateKey(rootMessagingKey.privateKey),
      "protocol=mailchain"
    );
    this._accountMessagingKey = _crypto.deriveHardenedKey.call(void 0, 
      _crypto.ED25519ExtendedPrivateKey.fromPrivateKey(rootAccountMessagingKey.privateKey),
      1
    );
    this._rootEncryptionKey = _crypto.deriveHardenedKey.call(void 0, 
      _crypto.ED25519ExtendedPrivateKey.fromPrivateKey(accountKey),
      _chunkCXGOL37Pjs.DERIVATION_PATH_ENCRYPTION_KEY_ROOT
    );
    this._rootUserProfileEncryptionKey = _crypto.deriveHardenedKey.call(void 0, 
      _crypto.ED25519ExtendedPrivateKey.fromPrivateKey(this._rootEncryptionKey.privateKey),
      _chunkCXGOL37Pjs.DERIVATION_PATH_USER_PROFILE
    );
    this._userSettingsEncryptionKey = _crypto.deriveHardenedKey.call(void 0, 
      _crypto.ED25519ExtendedPrivateKey.fromPrivateKey(this._rootUserProfileEncryptionKey.privateKey),
      _chunkCXGOL37Pjs.DERIVATION_PATH_USER_PROFILE_SETTINGS
    );
    this._userMailboxEncryptionKey = this._rootUserProfileEncryptionKey;
    this._rootInboxKey = _crypto.deriveHardenedKey.call(void 0, 
      _crypto.ED25519ExtendedPrivateKey.fromPrivateKey(this._rootEncryptionKey.privateKey),
      _chunkCXGOL37Pjs.DERIVATION_PATH_INBOX_ROOT
    );
  }
  /**
   * Use your Secret Recovery Phrase to authenticate your keyring.
   * @param secretRecoveryPhrase a 24 word [BIP 39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki) compatible mnemonic phrase.
   */
  static fromSecretRecoveryPhrase(secretRecoveryPhrase, password) {
    return new this(_crypto.ED25519PrivateKey.fromMnemonicPhrase(secretRecoveryPhrase, password));
  }
  static fromPrivateKey(key) {
    return new this(key);
  }
  rootEncryptionPublicKey() {
    return this._rootEncryptionKey.privateKey.publicKey;
  }
  rootInboxKey() {
    return this._rootInboxKey.privateKey;
  }
  inboxMessageDateOffset() {
    const year2000 = 946684800;
    const offsetKey = _crypto.deriveHardenedKey.call(void 0, 
      _crypto.ED25519ExtendedPrivateKey.fromPrivateKey(this._rootInboxKey.privateKey),
      _chunkCXGOL37Pjs.DERIVATION_PATH_DATE_OFFSET
    );
    const offset = Number(BigInt(_encoding.encodeHexZeroX.call(void 0, offsetKey.bytes)) % BigInt(year2000));
    return offset;
  }
  inboxKey() {
    const inboxKey = this._rootInboxKey.privateKey;
    const decrypter = _crypto.PrivateKeyDecrypter.fromPrivateKey(inboxKey);
    const encrypter = _crypto.PrivateKeyEncrypter.fromPrivateKey(inboxKey);
    return { encrypt: (input) => encrypter.encrypt(input), decrypt: (input) => decrypter.decrypt(input) };
  }
  /**
   * Crypto operations for encrypting and decrypting the persisted data of the user mailboxes.
   */
  userMailboxCrypto() {
    const mailboxKey = this._userMailboxEncryptionKey.privateKey;
    const decrypter = _crypto.PrivateKeyDecrypter.fromPrivateKey(mailboxKey);
    const encrypter = _crypto.PrivateKeyEncrypter.fromPrivateKey(mailboxKey);
    return { encrypt: (input) => encrypter.encrypt(input), decrypt: (input) => decrypter.decrypt(input) };
  }
  /**
   * Crypto operations for encrypting and decrypting the persisted data of the user settings.
   */
  userSettingsCrypto() {
    const mailboxKey = this._userSettingsEncryptionKey.privateKey;
    const decrypter = _crypto.PrivateKeyDecrypter.fromPrivateKey(mailboxKey);
    const encrypter = _crypto.PrivateKeyEncrypter.fromPrivateKey(mailboxKey);
    return { encrypt: (input) => encrypter.encrypt(input), decrypt: (input) => decrypter.decrypt(input) };
  }
  /**
   * Gets messaging key that can be used for signing and decrypting for a specific protocol address.
   * @param address protocol address e.g. 0x1234.... for ethereum.
   * @param protocol a {@link ProtocolType}
   * @param nonce in most cases you will want to use the latest nonce.
   * @returns
   */
  addressMessagingKey(address, protocol, nonce) {
    const decodedAddress = _addressing.decodeAddressByProtocol.call(void 0, address, protocol).decoded;
    return this.addressBytesMessagingKey(decodedAddress, protocol, nonce);
  }
  /**
   * Gets messaging key that can be exported for a specific protocol address.
   * @param address protocol address e.g. 0x1234.... for ethereum
   * @param protocol a {@link ProtocolType}
   * @param nonce in most cases you will want to use the latest nonce.
   * @returns
   */
  addressExportableMessagingKey(address, protocol, nonce) {
    const decodedAddress = _addressing.decodeAddressByProtocol.call(void 0, address, protocol).decoded;
    return this.addressBytesExportableMessagingKey(decodedAddress, protocol, nonce);
  }
  addressBytesMessagingKey(address, protocol, nonce) {
    const addressKey = this.addressBytesExportableMessagingKey(address, protocol, nonce);
    return _chunk74WFEZ7Pjs.ecdhKeyRingDecrypter.call(void 0, addressKey);
  }
  addressBytesExportableMessagingKey(address, protocol, nonce) {
    if (protocol === _addressing.MAILCHAIN) {
      return this.accountExportableMessagingKey();
    }
    const addressKeyRoot = _crypto.deriveHardenedKey.call(void 0, 
      this._protocolAddressRootMessagingKey,
      `protocol=${protocol},address=${_encoding.encodeHex.call(void 0, address)}`
    );
    return _crypto.deriveHardenedKey.call(void 0, addressKeyRoot, nonce).privateKey;
  }
  accountExportableMessagingKey() {
    return this._accountMessagingKey.privateKey;
  }
  accountMessagingKey() {
    const key = this.accountExportableMessagingKey();
    return _chunk74WFEZ7Pjs.ecdhKeyRingDecrypter.call(void 0, key);
  }
  accountIdentityKey() {
    const key = this._accountIdentityKey.privateKey;
    return {
      curve: key.curve,
      sign: (input) => key.sign(input),
      publicKey: key.publicKey
    };
  }
};



exports.KeyRing = KeyRing;
