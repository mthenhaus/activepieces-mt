import {
  addressFromPublicKey
} from "./chunk-DGSHHA5W.mjs";

// src/protocols/filecoin/delegatedAddress.ts
import { decodeUtf8 } from "@mailchain/encoding";
import { decodeBase32, encodeBase32 } from "@mailchain/encoding/base32";
import { blake2b } from "@noble/hashes/blake2b";
import isEqual from "lodash/isEqual.js";
var MIN_FIL_ADDRESS_STR_LENGTH = 6;
var MAX_FIL_ADDRESS_STR_LENGTH = 115;
var MAINNET_PREFIX = "f";
var CALIBRATION_PREFIX = "t";
var ETHEREUM_NAMESPACE = 10;
var ETHEREUM_ADDRESS_LENGTH = 20;
var CHECKSUM_LENGTH = 4;
function convertFilDelegatedAddressToEthAddress(fileCoinAddress) {
  const filAddress = fileCoinAddress.toLowerCase();
  if (!(filAddress.startsWith(MAINNET_PREFIX) || filAddress.startsWith(CALIBRATION_PREFIX))) {
    return {
      error: new Error(
        `invalid Filecoin address, should start with '${MAINNET_PREFIX}' or '${CALIBRATION_PREFIX}'`
      )
    };
  }
  if (filAddress.length < MIN_FIL_ADDRESS_STR_LENGTH || filAddress.length > MAX_FIL_ADDRESS_STR_LENGTH) {
    return { error: new Error("invalid address length") };
  }
  const raw = filAddress.slice(2);
  const namespaceStr = raw.slice(0, raw.indexOf("f"));
  const encodedSubAddress = raw.slice(raw.indexOf("f") + 1);
  const namespace = parseInt(namespaceStr, 10);
  if (namespace !== ETHEREUM_NAMESPACE) {
    return {
      error: new Error(`invalid namespace, supported only Ethereum Address Manager {${ETHEREUM_NAMESPACE}}`)
    };
  }
  const subAddress = decodeBase32(encodedSubAddress);
  if (subAddress.length < ETHEREUM_ADDRESS_LENGTH + CHECKSUM_LENGTH) {
    return { error: new Error("invalid subAddress length") };
  }
  const ethAddress = subAddress.slice(0, ETHEREUM_ADDRESS_LENGTH);
  const checksum = subAddress.slice(ETHEREUM_ADDRESS_LENGTH);
  if (ethAddress.length !== ETHEREUM_ADDRESS_LENGTH) {
    return { error: new Error("invalid Ethereum address length") };
  }
  if (!validateChecksum(4 /* DELEGATED */, namespace, ethAddress, checksum)) {
    return { error: new Error("invalid address checksum") };
  }
  return { data: ethAddress };
}
async function filDelegatedAddressFromPublicKey(publicKey) {
  const ethAddress = await addressFromPublicKey(publicKey);
  return convertEthAddressToFilDelegated(ethAddress, MAINNET_PREFIX);
}
function convertEthAddressToFilDelegated(ethereumAddress, prefix = MAINNET_PREFIX) {
  if (ethereumAddress.length != ETHEREUM_ADDRESS_LENGTH) {
    throw new Error("invalid Ethereum address length");
  }
  const checksum = computeAddressChecksum(4 /* DELEGATED */, ETHEREUM_NAMESPACE, ethereumAddress);
  const subAddress = new Uint8Array(ethereumAddress.length + checksum.length);
  subAddress.set(ethereumAddress, 0);
  subAddress.set(checksum, ethereumAddress.length);
  const encodedSubAddr = encodeBase32(subAddress);
  const filAddress = `${prefix}${4 /* DELEGATED */}${ETHEREUM_NAMESPACE}f${encodedSubAddr}`;
  return decodeUtf8(filAddress);
}
function validateChecksum(addressType, namespace, address, checksum) {
  const digest = computeAddressChecksum(addressType, namespace, address);
  return isEqual(digest, checksum);
}
function computeAddressChecksum(addressType, namespace, address) {
  const namespaceBytes = numberToUInt8Array(namespace);
  const payload = new Uint8Array(1 + namespaceBytes.length + address.length);
  payload.set(new Uint8Array([addressType]), 0);
  payload.set(namespaceBytes, 1);
  payload.set(address, 1 + namespaceBytes.length);
  return blake2b(payload, { dkLen: CHECKSUM_LENGTH });
}
function numberToUInt8Array(num) {
  if (num === 0)
    return new Uint8Array([0]);
  const res = [];
  res.unshift(num & 255);
  while (num >= 256) {
    num = num >>> 8;
    res.unshift(num & 255);
  }
  return new Uint8Array(res);
}

export {
  MAINNET_PREFIX,
  CALIBRATION_PREFIX,
  convertFilDelegatedAddressToEthAddress,
  filDelegatedAddressFromPublicKey,
  convertEthAddressToFilDelegated
};
