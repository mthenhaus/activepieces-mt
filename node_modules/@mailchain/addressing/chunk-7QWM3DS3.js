"use strict";Object.defineProperty(exports, "__esModule", {value: true});

var _chunkO73NCH4Njs = require('./chunk-O73NCH4N.js');

// src/protocols/tezos/address.ts
var _crypto = require('@mailchain/crypto');
var _sha256 = require('@noble/hashes/sha256');
var _blake2b = require('@noble/hashes/blake2b');
var _encoding = require('@mailchain/encoding');
function tezosAddressFromPublicKey(publicKey) {
  let prefixArray;
  switch (publicKey.curve) {
    case _crypto.KindSECP256K1:
      prefixArray = _chunkO73NCH4Njs.prefix.tz2;
      break;
    case _crypto.KindED25519:
      prefixArray = _chunkO73NCH4Njs.prefix.tz1;
      break;
    case _crypto.KindSECP256R1:
      prefixArray = _chunkO73NCH4Njs.prefix.tz3;
      break;
    default:
      throw new Error(`public key curve not supported`);
  }
  return composeAddress(publicKey.bytes, prefixArray);
}
function checksum(input) {
  const h = _sha256.sha256.call(void 0, input);
  const h2 = _sha256.sha256.call(void 0, h);
  return h2.slice(0, 4);
}
function hash(pkBytes) {
  return _blake2b.blake2b.call(void 0, pkBytes, { dkLen: 160 / 8 });
}
function composeAddress(key, prefixArray) {
  const h = hash(key);
  const result = new Uint8Array(27);
  result.set(prefixArray, 0);
  result.set(h, 3);
  result.set(checksum(result.slice(0, 23)), 23);
  return result;
}
function validateTezosAddress(address) {
  if (address.length !== 36) {
    return false;
  } else if (address.slice(0, 3) !== "tz1" /* TZ1 */ && address.slice(0, 3) !== "tz2" /* TZ2 */ && address.slice(0, 3) !== "tz3" /* TZ3 */) {
    return false;
  } else if (!_encoding.isBase58.call(void 0, address)) {
    return false;
  }
  const decoded = _encoding.decodeBase58.call(void 0, address);
  const addressChecksum = checksum(decoded.slice(0, 23));
  if (decoded.slice(-4).toString() !== addressChecksum.toString()) {
    return false;
  }
  return true;
}




exports.tezosAddressFromPublicKey = tezosAddressFromPublicKey; exports.validateTezosAddress = validateTezosAddress;
