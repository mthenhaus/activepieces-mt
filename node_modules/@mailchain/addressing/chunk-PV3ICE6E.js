"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _chunkQBWJRO3Pjs = require('./chunk-QBWJRO3P.js');

// src/protocols/filecoin/delegatedAddress.ts
var _encoding = require('@mailchain/encoding');
var _base32 = require('@mailchain/encoding/base32');
var _blake2b = require('@noble/hashes/blake2b');
var _isEqualjs = require('lodash/isEqual.js'); var _isEqualjs2 = _interopRequireDefault(_isEqualjs);
var MIN_FIL_ADDRESS_STR_LENGTH = 6;
var MAX_FIL_ADDRESS_STR_LENGTH = 115;
var MAINNET_PREFIX = "f";
var CALIBRATION_PREFIX = "t";
var ETHEREUM_NAMESPACE = 10;
var ETHEREUM_ADDRESS_LENGTH = 20;
var CHECKSUM_LENGTH = 4;
function convertFilDelegatedAddressToEthAddress(fileCoinAddress) {
  const filAddress = fileCoinAddress.toLowerCase();
  if (!(filAddress.startsWith(MAINNET_PREFIX) || filAddress.startsWith(CALIBRATION_PREFIX))) {
    return {
      error: new Error(
        `invalid Filecoin address, should start with '${MAINNET_PREFIX}' or '${CALIBRATION_PREFIX}'`
      )
    };
  }
  if (filAddress.length < MIN_FIL_ADDRESS_STR_LENGTH || filAddress.length > MAX_FIL_ADDRESS_STR_LENGTH) {
    return { error: new Error("invalid address length") };
  }
  const raw = filAddress.slice(2);
  const namespaceStr = raw.slice(0, raw.indexOf("f"));
  const encodedSubAddress = raw.slice(raw.indexOf("f") + 1);
  const namespace = parseInt(namespaceStr, 10);
  if (namespace !== ETHEREUM_NAMESPACE) {
    return {
      error: new Error(`invalid namespace, supported only Ethereum Address Manager {${ETHEREUM_NAMESPACE}}`)
    };
  }
  const subAddress = _base32.decodeBase32.call(void 0, encodedSubAddress);
  if (subAddress.length < ETHEREUM_ADDRESS_LENGTH + CHECKSUM_LENGTH) {
    return { error: new Error("invalid subAddress length") };
  }
  const ethAddress = subAddress.slice(0, ETHEREUM_ADDRESS_LENGTH);
  const checksum = subAddress.slice(ETHEREUM_ADDRESS_LENGTH);
  if (ethAddress.length !== ETHEREUM_ADDRESS_LENGTH) {
    return { error: new Error("invalid Ethereum address length") };
  }
  if (!validateChecksum(4 /* DELEGATED */, namespace, ethAddress, checksum)) {
    return { error: new Error("invalid address checksum") };
  }
  return { data: ethAddress };
}
async function filDelegatedAddressFromPublicKey(publicKey) {
  const ethAddress = await _chunkQBWJRO3Pjs.addressFromPublicKey.call(void 0, publicKey);
  return convertEthAddressToFilDelegated(ethAddress, MAINNET_PREFIX);
}
function convertEthAddressToFilDelegated(ethereumAddress, prefix = MAINNET_PREFIX) {
  if (ethereumAddress.length != ETHEREUM_ADDRESS_LENGTH) {
    throw new Error("invalid Ethereum address length");
  }
  const checksum = computeAddressChecksum(4 /* DELEGATED */, ETHEREUM_NAMESPACE, ethereumAddress);
  const subAddress = new Uint8Array(ethereumAddress.length + checksum.length);
  subAddress.set(ethereumAddress, 0);
  subAddress.set(checksum, ethereumAddress.length);
  const encodedSubAddr = _base32.encodeBase32.call(void 0, subAddress);
  const filAddress = `${prefix}${4 /* DELEGATED */}${ETHEREUM_NAMESPACE}f${encodedSubAddr}`;
  return _encoding.decodeUtf8.call(void 0, filAddress);
}
function validateChecksum(addressType, namespace, address, checksum) {
  const digest = computeAddressChecksum(addressType, namespace, address);
  return _isEqualjs2.default.call(void 0, digest, checksum);
}
function computeAddressChecksum(addressType, namespace, address) {
  const namespaceBytes = numberToUInt8Array(namespace);
  const payload = new Uint8Array(1 + namespaceBytes.length + address.length);
  payload.set(new Uint8Array([addressType]), 0);
  payload.set(namespaceBytes, 1);
  payload.set(address, 1 + namespaceBytes.length);
  return _blake2b.blake2b.call(void 0, payload, { dkLen: CHECKSUM_LENGTH });
}
function numberToUInt8Array(num) {
  if (num === 0)
    return new Uint8Array([0]);
  const res = [];
  res.unshift(num & 255);
  while (num >= 256) {
    num = num >>> 8;
    res.unshift(num & 255);
  }
  return new Uint8Array(res);
}







exports.MAINNET_PREFIX = MAINNET_PREFIX; exports.CALIBRATION_PREFIX = CALIBRATION_PREFIX; exports.convertFilDelegatedAddressToEthAddress = convertFilDelegatedAddressToEthAddress; exports.filDelegatedAddressFromPublicKey = filDelegatedAddressFromPublicKey; exports.convertEthAddressToFilDelegated = convertEthAddressToFilDelegated;
