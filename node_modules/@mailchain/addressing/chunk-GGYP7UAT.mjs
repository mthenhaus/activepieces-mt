import {
  prefix
} from "./chunk-B46YFNHS.mjs";

// src/protocols/tezos/address.ts
import { KindED25519, KindSECP256K1, KindSECP256R1 } from "@mailchain/crypto";
import { sha256 } from "@noble/hashes/sha256";
import { blake2b } from "@noble/hashes/blake2b";
import { decodeBase58, isBase58 } from "@mailchain/encoding";
function tezosAddressFromPublicKey(publicKey) {
  let prefixArray;
  switch (publicKey.curve) {
    case KindSECP256K1:
      prefixArray = prefix.tz2;
      break;
    case KindED25519:
      prefixArray = prefix.tz1;
      break;
    case KindSECP256R1:
      prefixArray = prefix.tz3;
      break;
    default:
      throw new Error(`public key curve not supported`);
  }
  return composeAddress(publicKey.bytes, prefixArray);
}
function checksum(input) {
  const h = sha256(input);
  const h2 = sha256(h);
  return h2.slice(0, 4);
}
function hash(pkBytes) {
  return blake2b(pkBytes, { dkLen: 160 / 8 });
}
function composeAddress(key, prefixArray) {
  const h = hash(key);
  const result = new Uint8Array(27);
  result.set(prefixArray, 0);
  result.set(h, 3);
  result.set(checksum(result.slice(0, 23)), 23);
  return result;
}
function validateTezosAddress(address) {
  if (address.length !== 36) {
    return false;
  } else if (address.slice(0, 3) !== "tz1" /* TZ1 */ && address.slice(0, 3) !== "tz2" /* TZ2 */ && address.slice(0, 3) !== "tz3" /* TZ3 */) {
    return false;
  } else if (!isBase58(address)) {
    return false;
  }
  const decoded = decodeBase58(address);
  const addressChecksum = checksum(decoded.slice(0, 23));
  if (decoded.slice(-4).toString() !== addressChecksum.toString()) {
    return false;
  }
  return true;
}

export {
  tezosAddressFromPublicKey,
  validateTezosAddress
};
