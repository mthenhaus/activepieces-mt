"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } }// src/protocols/ethereum/address.ts
var _crypto = require('@mailchain/crypto');
var _encoding = require('@mailchain/encoding');
async function addressFromPublicKey(publicKey) {
  if (publicKey.curve !== _crypto.KindSECP256K1) {
    throw new Error(`public key must be ${_crypto.KindSECP256K1}`);
  }
  const { computeAddress } = await Promise.resolve().then(() => _interopRequireWildcard(require("@ethersproject/transactions")));
  return _encoding.decodeHexZeroX.call(void 0, computeAddress(publicKey.bytes));
}
function validateEthereumAddress(address) {
  return /^0x[a-fA-F0-9]{40}/.test(address);
}
function validateEthereumTokenOwnerAddress(address) {
  return /^[0-9]*.0x[a-fA-F0-9]{40}/.test(address);
}





exports.addressFromPublicKey = addressFromPublicKey; exports.validateEthereumAddress = validateEthereumAddress; exports.validateEthereumTokenOwnerAddress = validateEthereumTokenOwnerAddress;
