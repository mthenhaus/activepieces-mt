import {
  BadlyFormattedAddressError,
  IdentityProviderAddressInvalidError
} from "./chunk-O4TP64YU.mjs";
import {
  validateNearAccountId
} from "./chunk-4HRTWHYX.mjs";
import {
  validateFilecoinAddress
} from "./chunk-MZRLAGO3.mjs";
import {
  validateSolanaAddress
} from "./chunk-X7CUXOZW.mjs";
import {
  validateTezosAddress
} from "./chunk-GGYP7UAT.mjs";
import {
  validateEthereumAddress,
  validateEthereumTokenOwnerAddress
} from "./chunk-DGSHHA5W.mjs";
import {
  ETHEREUM,
  NEAR,
  SOLANA,
  TEZOS
} from "./chunk-53HGU7GY.mjs";

// src/checkAddressForErrors.ts
var DEFAULT_MAILCHAIN_DOMAIN = "mailchain.com";
function checkAddressForErrors(address, mailchainDomain = DEFAULT_MAILCHAIN_DOMAIN) {
  address = address.trim();
  if (!address.endsWith(`${mailchainDomain}`)) {
    return new BadlyFormattedAddressError();
  }
  const parts = address.split("@");
  if (parts.length !== 2) {
    return new BadlyFormattedAddressError();
  }
  const local = parts[0];
  const domain = parts[1];
  const domainParts = parts[1].split(".");
  if (domain === DEFAULT_MAILCHAIN_DOMAIN) {
    return validateMailchainProtocolAddress(local);
  } else if (domainParts.length === 3) {
    return validateIdentityProviderAddress(local, domainParts[0]);
  }
  return void 0;
}
function validateMailchainProtocolAddress(tldTrimmedAddress) {
  const mailchainAddressPattern = /^[a-zA-Z0-9-_]{2,20}$/;
  if (!mailchainAddressPattern.test(tldTrimmedAddress)) {
    return new IdentityProviderAddressInvalidError();
  }
  return void 0;
}
function validateIdentityProviderAddress(address, identityProvider) {
  switch (identityProvider) {
    case ETHEREUM:
      if (!validateEthereumAddress(address) && !validateEthereumTokenOwnerAddress(address)) {
        return new IdentityProviderAddressInvalidError();
      }
      break;
    case NEAR:
      if (!validateNearAccountId(address)) {
        return new IdentityProviderAddressInvalidError();
      }
      break;
    case TEZOS:
      if (!validateTezosAddress(address)) {
        return new IdentityProviderAddressInvalidError();
      }
      break;
    case "filecoin":
      if (!validateFilecoinAddress(address)) {
        return new IdentityProviderAddressInvalidError();
      }
      break;
    case SOLANA:
      if (!validateSolanaAddress(address)) {
        return new IdentityProviderAddressInvalidError();
      }
      break;
  }
  return void 0;
}

export {
  checkAddressForErrors
};
