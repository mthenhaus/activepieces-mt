import {
  formatMailLike
} from "./chunk-TNDO2PDN.mjs";
import {
  matchesNameservice
} from "./chunk-XPEND7LX.mjs";
import {
  NAMESERVICE_DESCRIPTIONS
} from "./chunk-ZO2YQCZV.mjs";
import {
  isEthereumAddress,
  isMailchainAccountAddress,
  isNearImplicitAccount,
  isTezosAddress
} from "./chunk-5DXGVNVQ.mjs";
import {
  createNameServiceAddress
} from "./chunk-EDI5FTJ3.mjs";
import {
  parseWalletAddress
} from "./chunk-DGHYOYLZ.mjs";
import {
  decodeAddressByProtocol
} from "./chunk-UBQM5UAE.mjs";
import {
  ETHEREUM,
  NEAR,
  TEZOS
} from "./chunk-53HGU7GY.mjs";

// src/addressFormattingRule.ts
var humanMailchainAccount = (address) => {
  if (isMailchainAccountAddress(address)) {
    const domainParts = address.domain.split(".");
    return formatMailLike(address.username, domainParts[0]);
  }
  return void 0;
};
var humanNearAddress = (address) => {
  const props = parseWalletAddress(address);
  if (props == null || props.protocol !== NEAR)
    return;
  const usernameParts = address.username.split(".");
  if (usernameParts.length == 1 && isNearImplicitAccount({
    domain: address.domain,
    username: usernameParts[0]
  })) {
    return formatMailLike(
      [`${usernameParts[0].slice(0, 6)}...${usernameParts[0].slice(-4)}`, ...usernameParts.slice(1)].join("."),
      props.protocol
    );
  } else if (usernameParts.length >= 2 && isNearImplicitAccount({
    domain: address.domain,
    username: usernameParts[0]
  }) && usernameParts[usernameParts.length - 1] !== "near") {
    return formatMailLike(
      [`${usernameParts[0].slice(0, 6)}...${usernameParts[0].slice(-4)}`, ...usernameParts.slice(1)].join("."),
      props.protocol
    );
  } else if (usernameParts.length >= 2 && usernameParts[usernameParts.length - 1] !== "near") {
    return formatMailLike(address.username, props.protocol);
  }
  return address.username;
};
var humanTezosAddress = (address) => {
  if (!isTezosAddress(address))
    return void 0;
  return formatMailLike(`${address.username.slice(0, 7)}...${address.username.slice(-4)}`, TEZOS);
};
var humanEthereumAddress = (address) => {
  if (!isEthereumAddress(address))
    return void 0;
  return formatMailLike(`${address.username.slice(0, 6)}...${address.username.slice(-4)}`, ETHEREUM);
};
var humanWalletAddress = (address) => {
  const domainParts = address.domain.split(".");
  if (domainParts.length <= 2)
    return void 0;
  const props = parseWalletAddress(address);
  if (props == null)
    return void 0;
  try {
    decodeAddressByProtocol(address.username, props.protocol);
    return formatMailLike(`${address.username.slice(0, 4)}...${address.username.slice(-4)}`, props.protocol);
  } catch (e) {
    return void 0;
  }
};
var humanNsAddress = (address) => {
  for (const desc of NAMESERVICE_DESCRIPTIONS) {
    const matchingNsDomain = matchesNameservice(address, desc);
    if (matchingNsDomain) {
      const nsDomainCollision = NAMESERVICE_DESCRIPTIONS.some(
        (nsd) => desc.name !== nsd.name && nsd.domains.includes(matchingNsDomain)
      );
      return nsDomainCollision ? `${address.username}@${desc.name}` : address.username;
    }
  }
  return void 0;
};
var humanTokenAddress = (address) => {
  const usernameParts = address.username.split(".");
  if (usernameParts.length !== 2)
    return void 0;
  const [tokenId, walletUsername] = usernameParts;
  if (/^\d+$/.test(tokenId) === false)
    return void 0;
  const walletAddress = createNameServiceAddress(walletUsername, address.domain);
  const walletProps = parseWalletAddress(walletAddress);
  if (walletProps == null)
    return void 0;
  let walletAddressStr = void 0;
  switch (walletProps.protocol) {
    case ETHEREUM:
      walletAddressStr = humanEthereumAddress(walletAddress);
      break;
    case NEAR:
      walletAddressStr = humanNearAddress(walletAddress);
      break;
    case TEZOS:
      walletAddressStr = humanTezosAddress(walletAddress);
      break;
    default:
      return void 0;
  }
  if (walletAddressStr == null)
    return void 0;
  return `${tokenId}.${walletAddressStr}`;
};
var humanCatchAll = (address) => {
  const domainParts = address.domain.split(".");
  if (domainParts.length === 2) {
    return formatMailLike(address.username, domainParts[0]);
  } else if (domainParts.length > 2) {
    const domainPartsToInclude = domainParts.slice(0, -2);
    return formatMailLike(address.username, ...domainPartsToInclude);
  }
  return formatMailLike(address.username, address.domain);
};
var humanNameServiceFormatters = [
  humanMailchainAccount,
  humanNearAddress,
  humanTezosAddress,
  humanEthereumAddress,
  humanTokenAddress,
  humanNsAddress,
  humanWalletAddress,
  humanCatchAll
];

export {
  humanNameServiceFormatters
};
