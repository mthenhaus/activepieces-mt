"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }

var _chunkE6OAXMPTjs = require('./chunk-E6OAXMPT.js');


var _chunkOS5AHDT5js = require('./chunk-OS5AHDT5.js');


var _chunkL7UXQ4P2js = require('./chunk-L7UXQ4P2.js');


var _chunkBAZMUWY4js = require('./chunk-BAZMUWY4.js');


var _chunkP66WQYVAjs = require('./chunk-P66WQYVA.js');


var _chunk7QWM3DS3js = require('./chunk-7QWM3DS3.js');


var _chunkQBWJRO3Pjs = require('./chunk-QBWJRO3P.js');




var _chunk7K2RPUW3js = require('./chunk-7K2RPUW3.js');

// src/addressPredicates.ts
function isMailchainAccountAddress(address) {
  const isMailchainUsername = address.username.match(/(^[a-zA-Z0-9][_\-a-zA-Z0-9]{0,18}[a-zA-Z0-9])$/) != null;
  const isJustMailchainDomain = address.domain.match(/^mailchain\.[a-z]+$/) != null;
  return isMailchainUsername && isJustMailchainDomain;
}
function isEthereumAddress(address) {
  const props = _chunkOS5AHDT5js.parseWalletAddress.call(void 0, address);
  if (_optionalChain([props, 'optionalAccess', _ => _.protocol]) !== _chunk7K2RPUW3js.ETHEREUM)
    return false;
  return _chunkQBWJRO3Pjs.validateEthereumAddress.call(void 0, address.username);
}
function isNearImplicitAccount(address) {
  const props = _chunkOS5AHDT5js.parseWalletAddress.call(void 0, address);
  if (_optionalChain([props, 'optionalAccess', _2 => _2.protocol]) !== _chunk7K2RPUW3js.NEAR)
    return false;
  return _chunkL7UXQ4P2js.validateNearImplicitAccount.call(void 0, address.username);
}
function isTezosAddress(address) {
  const props = _chunkOS5AHDT5js.parseWalletAddress.call(void 0, address);
  if (_optionalChain([props, 'optionalAccess', _3 => _3.protocol]) !== _chunk7K2RPUW3js.TEZOS)
    return false;
  return _chunk7QWM3DS3js.validateTezosAddress.call(void 0, address.username);
}
function isFilecoinAddress(address) {
  const domainParts = address.domain.split(".");
  if (domainParts[0] !== "filecoin")
    return false;
  return _chunkBAZMUWY4js.validateFilecoinAddress.call(void 0, address.username);
}
function isTokenAddress(address) {
  const usernameParts = address.username.split(".");
  if (usernameParts.length !== 2)
    return false;
  const [tokenId, walletUsername] = usernameParts;
  if (/^\d+$/.test(tokenId) === false)
    return false;
  const walletAddress = _chunkE6OAXMPTjs.createNameServiceAddress.call(void 0, walletUsername, address.domain);
  const walletProps = _chunkOS5AHDT5js.parseWalletAddress.call(void 0, walletAddress);
  if (!walletProps)
    return false;
  switch (walletProps.protocol) {
    case _chunk7K2RPUW3js.ETHEREUM:
      return _chunkQBWJRO3Pjs.validateEthereumAddress.call(void 0, walletUsername);
    default:
      return false;
  }
}
function isSolanaAddress(address) {
  const domainParts = address.domain.split(".");
  if (domainParts[0] !== "solana")
    return false;
  return _chunkP66WQYVAjs.validateSolanaAddress.call(void 0, address.username);
}









exports.isMailchainAccountAddress = isMailchainAccountAddress; exports.isEthereumAddress = isEthereumAddress; exports.isNearImplicitAccount = isNearImplicitAccount; exports.isTezosAddress = isTezosAddress; exports.isFilecoinAddress = isFilecoinAddress; exports.isTokenAddress = isTokenAddress; exports.isSolanaAddress = isSolanaAddress;
