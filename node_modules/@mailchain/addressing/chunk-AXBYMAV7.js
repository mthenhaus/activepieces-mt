"use strict";Object.defineProperty(exports, "__esModule", {value: true});

var _chunk4WTCQFUOjs = require('./chunk-4WTCQFUO.js');









var _chunk7K2RPUW3js = require('./chunk-7K2RPUW3.js');

// src/encoding.ts
var _encoding = require('@mailchain/encoding');
function encodeAddressByProtocol(address, protocol) {
  const encoding = encodingByProtocol(protocol);
  const encoded = _chunk4WTCQFUOjs.casingByProtocol.call(void 0, _encoding.encode.call(void 0, encoding, address), protocol);
  return { encoded, encoding };
}
function decodeAddressByProtocol(address, protocol) {
  const encoding = encodingByProtocol(protocol);
  const decoded = _encoding.decode.call(void 0, encoding, _chunk4WTCQFUOjs.casingByProtocol.call(void 0, address, protocol));
  return { decoded, encoding };
}
function encodingByProtocol(protocol) {
  switch (protocol) {
    case _chunk7K2RPUW3js.ALGORAND:
      return _encoding.EncodingTypes.Base32;
    case _chunk7K2RPUW3js.ETHEREUM:
      return _encoding.EncodingTypes.Hex0xPrefix;
    case _chunk7K2RPUW3js.SUBSTRATE:
    case _chunk7K2RPUW3js.TEZOS:
    case _chunk7K2RPUW3js.SOLANA:
      return _encoding.EncodingTypes.Base58;
    case _chunk7K2RPUW3js.MAILCHAIN:
    case _chunk7K2RPUW3js.NEAR:
      return _encoding.EncodingTypes.Utf8;
    default:
      throw new Error(`unknown address encoding of [${protocol}]. Supported ${_chunk7K2RPUW3js.ALL_PROTOCOLS}.`);
  }
}





exports.encodeAddressByProtocol = encodeAddressByProtocol; exports.decodeAddressByProtocol = decodeAddressByProtocol; exports.encodingByProtocol = encodingByProtocol;
