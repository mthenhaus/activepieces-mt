"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }






var _chunkZFXYEUUWjs = require('./chunk-ZFXYEUUW.js');




var _chunk7VCGQ36Wjs = require('./chunk-7VCGQ36W.js');

// src/api/api.ts
var _axios = require('axios'); var _axios2 = _interopRequireDefault(_axios);
var AddressEncodingEnum = {
  Hex0xPrefix: "hex/0x-prefix",
  HexPlain: "hex/plain",
  TextUtf8: "text/utf-8",
  Base58Plain: "base58/plain"
};
var ContractCallMethodEnum = {
  Post: "POST",
  Get: "GET"
};
var EncryptedAccountSecretEncryptionKindEnum = {
  Opaque: "opaque",
  Metamask: "metamask"
};
var EncryptedAccountSecretSecretKindEnum = {
  Account: "account",
  Mnemonic: "mnemonic"
};
var GetUsernameAvailableResponseBodyReasonEnum = {
  Reserved: "reserved",
  Invalid: "invalid",
  Taken: "taken",
  Available: "available",
  Unavailable: "unavailable"
};
var ImageKindEnum = {
  Image: "image",
  Token: "token"
};
var MessageKindEnum = {
  Mail: "mail",
  VcRequest: "vc-request"
};
var PrivateKeyCurveEnum = {
  Secp256k1: "secp256k1",
  Ed25519: "ed25519",
  Secp256r1: "secp256r1"
};
var PrivateKeyEncodingEnum = {
  _0xPrefix: "hex/0x-prefix",
  Plain: "hex/plain"
};
var PublicKeyCurveEnum = {
  Secp256k1: "secp256k1",
  Ed25519: "ed25519",
  Secp256r1: "secp256r1"
};
var PublicKeyEncodingEnum = {
  _0xPrefix: "hex/0x-prefix",
  Plain: "hex/plain"
};
var PutEncryptedMessageRequestBodyFolderEnum = {
  Outbox: "outbox",
  Inbox: "inbox"
};
var PutEncryptedMessageRequestBodyKindEnum = {
  Mail: "mail",
  VcRequest: "vc-request"
};
var PutUserSettingRequestBodyGroupEnum = {
  Generic: "generic",
  UserRules: "user-rules"
};
var PutUserSettingRequestBodyKindEnum = {
  String: "string",
  Bool: "bool",
  Encrypted: "encrypted"
};
var RegisteredKeyProofSigningMethodEnum = {
  EthereumPersonalMessage: "ethereum_personal_message",
  RawEd25519: "raw_ed25519",
  TezosSignedMessageMicheline: "tezos_signed_message_micheline"
};
var SettingGroupEnum = {
  Generic: "generic",
  UserRules: "user-rules"
};
var SettingKindEnum = {
  String: "string",
  Encrypted: "encrypted"
};
var AddressesApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * 
     * @summary Get identity for an address.
     * @param {string} address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
     * @param {number} [at] The time to query the messaging key at.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAddressIdentityKey: async (address, at, options = {}) => {
      _chunkZFXYEUUWjs.assertParamExists.call(void 0, "getAddressIdentityKey", "address", address);
      const localVarPath = `/addresses/{address}/identity-key`.replace(`{${"address"}}`, encodeURIComponent(String(address)));
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      if (at !== void 0) {
        localVarQueryParameter["at"] = at;
      }
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 
     * @summary Get messaging key for an address.
     * @param {string} address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
     * @param {number} [at] The time to query the messaging key at.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAddressMessagingKey: async (address, at, options = {}) => {
      _chunkZFXYEUUWjs.assertParamExists.call(void 0, "getAddressMessagingKey", "address", address);
      const localVarPath = `/addresses/{address}/messaging-key`.replace(`{${"address"}}`, encodeURIComponent(String(address)));
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      if (at !== void 0) {
        localVarQueryParameter["at"] = at;
      }
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 
     * @summary Get status for messaging key for an address.
     * @param {string} address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
     * @param {number} [at] The time to query the messaging key at.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAddressMessagingKeyStatus: async (address, at, options = {}) => {
      _chunkZFXYEUUWjs.assertParamExists.call(void 0, "getAddressMessagingKeyStatus", "address", address);
      const localVarPath = `/addresses/{address}/resolved-messaging-key`.replace(`{${"address"}}`, encodeURIComponent(String(address)));
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      if (at !== void 0) {
        localVarQueryParameter["at"] = at;
      }
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 
     * @summary Get identity for an address.
     * @param {string} address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAddressMetadata: async (address, options = {}) => {
      _chunkZFXYEUUWjs.assertParamExists.call(void 0, "getAddressMetadata", "address", address);
      const localVarPath = `/addresses/{address}/metadata`.replace(`{${"address"}}`, encodeURIComponent(String(address)));
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var AddressesApiFp = function(configuration) {
  const localVarAxiosParamCreator = AddressesApiAxiosParamCreator(configuration);
  return {
    /**
     * 
     * @summary Get identity for an address.
     * @param {string} address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
     * @param {number} [at] The time to query the messaging key at.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAddressIdentityKey(address, at, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAddressIdentityKey(address, at, options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    },
    /**
     * 
     * @summary Get messaging key for an address.
     * @param {string} address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
     * @param {number} [at] The time to query the messaging key at.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAddressMessagingKey(address, at, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAddressMessagingKey(address, at, options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    },
    /**
     * 
     * @summary Get status for messaging key for an address.
     * @param {string} address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
     * @param {number} [at] The time to query the messaging key at.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAddressMessagingKeyStatus(address, at, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAddressMessagingKeyStatus(address, at, options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    },
    /**
     * 
     * @summary Get identity for an address.
     * @param {string} address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAddressMetadata(address, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAddressMetadata(address, options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    }
  };
};
var AddressesApiFactory = function(configuration, basePath, axios) {
  const localVarFp = AddressesApiFp(configuration);
  return {
    /**
     * 
     * @summary Get identity for an address.
     * @param {string} address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
     * @param {number} [at] The time to query the messaging key at.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAddressIdentityKey(address, at, options) {
      return localVarFp.getAddressIdentityKey(address, at, options).then((request) => request(axios, basePath));
    },
    /**
     * 
     * @summary Get messaging key for an address.
     * @param {string} address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
     * @param {number} [at] The time to query the messaging key at.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAddressMessagingKey(address, at, options) {
      return localVarFp.getAddressMessagingKey(address, at, options).then((request) => request(axios, basePath));
    },
    /**
     * 
     * @summary Get status for messaging key for an address.
     * @param {string} address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
     * @param {number} [at] The time to query the messaging key at.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAddressMessagingKeyStatus(address, at, options) {
      return localVarFp.getAddressMessagingKeyStatus(address, at, options).then((request) => request(axios, basePath));
    },
    /**
     * 
     * @summary Get identity for an address.
     * @param {string} address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAddressMetadata(address, options) {
      return localVarFp.getAddressMetadata(address, options).then((request) => request(axios, basePath));
    }
  };
};
var AddressesApi = class extends _chunk7VCGQ36Wjs.BaseAPI {
  /**
   * 
   * @summary Get identity for an address.
   * @param {string} address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
   * @param {number} [at] The time to query the messaging key at.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AddressesApi
   */
  getAddressIdentityKey(address, at, options) {
    return AddressesApiFp(this.configuration).getAddressIdentityKey(address, at, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * 
   * @summary Get messaging key for an address.
   * @param {string} address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
   * @param {number} [at] The time to query the messaging key at.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AddressesApi
   */
  getAddressMessagingKey(address, at, options) {
    return AddressesApiFp(this.configuration).getAddressMessagingKey(address, at, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * 
   * @summary Get status for messaging key for an address.
   * @param {string} address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
   * @param {number} [at] The time to query the messaging key at.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AddressesApi
   */
  getAddressMessagingKeyStatus(address, at, options) {
    return AddressesApiFp(this.configuration).getAddressMessagingKeyStatus(address, at, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * 
   * @summary Get identity for an address.
   * @param {string} address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AddressesApi
   */
  getAddressMetadata(address, options) {
    return AddressesApiFp(this.configuration).getAddressMetadata(address, options).then((request) => request(this.axios, this.basePath));
  }
};
var AuthApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * 
     * @summary Finalize authentication.
     * @param {AccountAuthFinalizeRequestBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountAuthFinalize: async (body, options = {}) => {
      const localVarPath = `/user/auth-finalize`;
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      localVarHeaderParameter["Content-Type"] = "application/json";
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = _chunkZFXYEUUWjs.serializeDataIfNeeded.call(void 0, body, localVarRequestOptions, configuration);
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 
     * @summary Start authentication.
     * @param {AccountAuthInitRequestBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountAuthInit: async (body, options = {}) => {
      const localVarPath = `/user/auth-init`;
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      localVarHeaderParameter["Content-Type"] = "application/json";
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = _chunkZFXYEUUWjs.serializeDataIfNeeded.call(void 0, body, localVarRequestOptions, configuration);
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 
     * @summary Complete opaque registration flow.
     * @param {AccountRegisterCreateRequestBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountRegisterCreate: async (body, options = {}) => {
      const localVarPath = `/user/register-create`;
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      localVarHeaderParameter["Content-Type"] = "application/json";
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = _chunkZFXYEUUWjs.serializeDataIfNeeded.call(void 0, body, localVarRequestOptions, configuration);
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 
     * @summary Finalize registration.
     * @param {AccountRegisterFinalizeRequestBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountRegisterFinalize: async (body, options = {}) => {
      const localVarPath = `/user/register-finalize`;
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      localVarHeaderParameter["Content-Type"] = "application/json";
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = _chunkZFXYEUUWjs.serializeDataIfNeeded.call(void 0, body, localVarRequestOptions, configuration);
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 
     * @summary Start registration process.
     * @param {AccountRegisterInitRequestBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountRegisterInit: async (body, options = {}) => {
      const localVarPath = `/user/register-init`;
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      localVarHeaderParameter["Content-Type"] = "application/json";
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = _chunkZFXYEUUWjs.serializeDataIfNeeded.call(void 0, body, localVarRequestOptions, configuration);
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 
     * @summary Complete opaque reset flow.
     * @param {PasswordResetCreateRequestBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    passwordResetCreate: async (body, options = {}) => {
      const localVarPath = `/user/password-reset-create`;
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      localVarHeaderParameter["Content-Type"] = "application/json";
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = _chunkZFXYEUUWjs.serializeDataIfNeeded.call(void 0, body, localVarRequestOptions, configuration);
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 
     * @summary Finalize reset password.
     * @param {PasswordResetFinalizeRequestBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    passwordResetFinalize: async (body, options = {}) => {
      const localVarPath = `/user/password-reset-finalize`;
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      localVarHeaderParameter["Content-Type"] = "application/json";
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = _chunkZFXYEUUWjs.serializeDataIfNeeded.call(void 0, body, localVarRequestOptions, configuration);
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 
     * @summary Start reset password process.
     * @param {PasswordResetInitRequestBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    passwordResetInit: async (body, options = {}) => {
      const localVarPath = `/user/password-reset-init`;
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      localVarHeaderParameter["Content-Type"] = "application/json";
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = _chunkZFXYEUUWjs.serializeDataIfNeeded.call(void 0, body, localVarRequestOptions, configuration);
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var AuthApiFp = function(configuration) {
  const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration);
  return {
    /**
     * 
     * @summary Finalize authentication.
     * @param {AccountAuthFinalizeRequestBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async accountAuthFinalize(body, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.accountAuthFinalize(body, options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    },
    /**
     * 
     * @summary Start authentication.
     * @param {AccountAuthInitRequestBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async accountAuthInit(body, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.accountAuthInit(body, options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    },
    /**
     * 
     * @summary Complete opaque registration flow.
     * @param {AccountRegisterCreateRequestBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async accountRegisterCreate(body, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.accountRegisterCreate(body, options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    },
    /**
     * 
     * @summary Finalize registration.
     * @param {AccountRegisterFinalizeRequestBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async accountRegisterFinalize(body, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.accountRegisterFinalize(body, options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    },
    /**
     * 
     * @summary Start registration process.
     * @param {AccountRegisterInitRequestBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async accountRegisterInit(body, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.accountRegisterInit(body, options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    },
    /**
     * 
     * @summary Complete opaque reset flow.
     * @param {PasswordResetCreateRequestBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async passwordResetCreate(body, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.passwordResetCreate(body, options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    },
    /**
     * 
     * @summary Finalize reset password.
     * @param {PasswordResetFinalizeRequestBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async passwordResetFinalize(body, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.passwordResetFinalize(body, options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    },
    /**
     * 
     * @summary Start reset password process.
     * @param {PasswordResetInitRequestBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async passwordResetInit(body, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.passwordResetInit(body, options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    }
  };
};
var AuthApiFactory = function(configuration, basePath, axios) {
  const localVarFp = AuthApiFp(configuration);
  return {
    /**
     * 
     * @summary Finalize authentication.
     * @param {AccountAuthFinalizeRequestBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountAuthFinalize(body, options) {
      return localVarFp.accountAuthFinalize(body, options).then((request) => request(axios, basePath));
    },
    /**
     * 
     * @summary Start authentication.
     * @param {AccountAuthInitRequestBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountAuthInit(body, options) {
      return localVarFp.accountAuthInit(body, options).then((request) => request(axios, basePath));
    },
    /**
     * 
     * @summary Complete opaque registration flow.
     * @param {AccountRegisterCreateRequestBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountRegisterCreate(body, options) {
      return localVarFp.accountRegisterCreate(body, options).then((request) => request(axios, basePath));
    },
    /**
     * 
     * @summary Finalize registration.
     * @param {AccountRegisterFinalizeRequestBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountRegisterFinalize(body, options) {
      return localVarFp.accountRegisterFinalize(body, options).then((request) => request(axios, basePath));
    },
    /**
     * 
     * @summary Start registration process.
     * @param {AccountRegisterInitRequestBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountRegisterInit(body, options) {
      return localVarFp.accountRegisterInit(body, options).then((request) => request(axios, basePath));
    },
    /**
     * 
     * @summary Complete opaque reset flow.
     * @param {PasswordResetCreateRequestBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    passwordResetCreate(body, options) {
      return localVarFp.passwordResetCreate(body, options).then((request) => request(axios, basePath));
    },
    /**
     * 
     * @summary Finalize reset password.
     * @param {PasswordResetFinalizeRequestBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    passwordResetFinalize(body, options) {
      return localVarFp.passwordResetFinalize(body, options).then((request) => request(axios, basePath));
    },
    /**
     * 
     * @summary Start reset password process.
     * @param {PasswordResetInitRequestBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    passwordResetInit(body, options) {
      return localVarFp.passwordResetInit(body, options).then((request) => request(axios, basePath));
    }
  };
};
var AuthApi = class extends _chunk7VCGQ36Wjs.BaseAPI {
  /**
   * 
   * @summary Finalize authentication.
   * @param {AccountAuthFinalizeRequestBody} [body] 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  accountAuthFinalize(body, options) {
    return AuthApiFp(this.configuration).accountAuthFinalize(body, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * 
   * @summary Start authentication.
   * @param {AccountAuthInitRequestBody} [body] 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  accountAuthInit(body, options) {
    return AuthApiFp(this.configuration).accountAuthInit(body, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * 
   * @summary Complete opaque registration flow.
   * @param {AccountRegisterCreateRequestBody} [body] 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  accountRegisterCreate(body, options) {
    return AuthApiFp(this.configuration).accountRegisterCreate(body, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * 
   * @summary Finalize registration.
   * @param {AccountRegisterFinalizeRequestBody} [body] 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  accountRegisterFinalize(body, options) {
    return AuthApiFp(this.configuration).accountRegisterFinalize(body, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * 
   * @summary Start registration process.
   * @param {AccountRegisterInitRequestBody} [body] 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  accountRegisterInit(body, options) {
    return AuthApiFp(this.configuration).accountRegisterInit(body, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * 
   * @summary Complete opaque reset flow.
   * @param {PasswordResetCreateRequestBody} [body] 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  passwordResetCreate(body, options) {
    return AuthApiFp(this.configuration).passwordResetCreate(body, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * 
   * @summary Finalize reset password.
   * @param {PasswordResetFinalizeRequestBody} [body] 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  passwordResetFinalize(body, options) {
    return AuthApiFp(this.configuration).passwordResetFinalize(body, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * 
   * @summary Start reset password process.
   * @param {PasswordResetInitRequestBody} [body] 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  passwordResetInit(body, options) {
    return AuthApiFp(this.configuration).passwordResetInit(body, options).then((request) => request(this.axios, this.basePath));
  }
};
var IdentityKeysApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * This method will get the identity key associated with a blockchain address. Protocols have different methods for retrieving or calculating a public key from an address.
     * @summary Identity key from blockchain address.
     * @param {string} address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana'} protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIdentityKey: async (address, protocol, options = {}) => {
      _chunkZFXYEUUWjs.assertParamExists.call(void 0, "getIdentityKey", "address", address);
      _chunkZFXYEUUWjs.assertParamExists.call(void 0, "getIdentityKey", "protocol", protocol);
      const localVarPath = `/protocols/{protocol}/addresses/{address}/identity-key`.replace(`{${"address"}}`, encodeURIComponent(String(address))).replace(`{${"protocol"}}`, encodeURIComponent(String(protocol)));
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Calculates all addresses for supported protocols. Then checks to see if vended messaging keys have been created. Only returns addresses that have vended messaging keys.
     * @summary Gets all for an address for an identity key.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIdentityKeyAddresses: async (identityKey, options = {}) => {
      _chunkZFXYEUUWjs.assertParamExists.call(void 0, "getIdentityKeyAddresses", "identityKey", identityKey);
      const localVarPath = `/identity-keys/{identityKey}/addresses`.replace(`{${"identityKey"}}`, encodeURIComponent(String(identityKey)));
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * This method will get take the identity key and look against each protocol where it could be present and check against supported name service resolvers. It will return all resolved names.
     * @summary Get all linked names for a resolver
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {Array<string>} [kind] Kind of reverse resolver to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIdentityKeyResolvableNames: async (identityKey, kind, options = {}) => {
      _chunkZFXYEUUWjs.assertParamExists.call(void 0, "getIdentityKeyResolvableNames", "identityKey", identityKey);
      const localVarPath = `/identity-keys/{identityKey}/resolvable-names`.replace(`{${"identityKey"}}`, encodeURIComponent(String(identityKey)));
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      if (kind) {
        localVarQueryParameter["kind"] = kind.join(_chunk7VCGQ36Wjs.COLLECTION_FORMATS.csv);
      }
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 
     * @summary Get a Mailchain messaging key.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {number} [at] The time to query the messaging key at.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMsgKey: async (identityKey, at, options = {}) => {
      _chunkZFXYEUUWjs.assertParamExists.call(void 0, "getMsgKey", "identityKey", identityKey);
      const localVarPath = `/identity-key/{identityKey}/messaging-key`.replace(`{${"identityKey"}}`, encodeURIComponent(String(identityKey)));
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      if (at !== void 0) {
        localVarQueryParameter["at"] = at;
      }
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Save the identity key for the given address. Identity keys are only saved for protocols where the key cannot be determined from the address.
     * @summary Store address identity key.
     * @param {string} address Address to look for encoded based on the protocol standard.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {string} protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putAddressIdentityKey: async (address, identityKey, protocol, options = {}) => {
      _chunkZFXYEUUWjs.assertParamExists.call(void 0, "putAddressIdentityKey", "address", address);
      _chunkZFXYEUUWjs.assertParamExists.call(void 0, "putAddressIdentityKey", "identityKey", identityKey);
      _chunkZFXYEUUWjs.assertParamExists.call(void 0, "putAddressIdentityKey", "protocol", protocol);
      const localVarPath = `/protocols/{protocol}/addresses/{address}/identity-keys/{identityKey}`.replace(`{${"address"}}`, encodeURIComponent(String(address))).replace(`{${"identityKey"}}`, encodeURIComponent(String(identityKey))).replace(`{${"protocol"}}`, encodeURIComponent(String(protocol)));
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Only address owners can change an address\'s messaging key. Owner\'s need to sign a message that includes the new messaging key and nonce.
     * @summary Upload a messaging key for an address\'s identity key.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {PutMsgKeyByIDKeyRequestBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putMsgKeyByIDKey: async (identityKey, body, options = {}) => {
      _chunkZFXYEUUWjs.assertParamExists.call(void 0, "putMsgKeyByIDKey", "identityKey", identityKey);
      _chunkZFXYEUUWjs.assertParamExists.call(void 0, "putMsgKeyByIDKey", "body", body);
      const localVarPath = `/identity-key/{identityKey}/messaging-key`.replace(`{${"identityKey"}}`, encodeURIComponent(String(identityKey)));
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      localVarHeaderParameter["Content-Type"] = "application/json";
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = _chunkZFXYEUUWjs.serializeDataIfNeeded.call(void 0, body, localVarRequestOptions, configuration);
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var IdentityKeysApiFp = function(configuration) {
  const localVarAxiosParamCreator = IdentityKeysApiAxiosParamCreator(configuration);
  return {
    /**
     * This method will get the identity key associated with a blockchain address. Protocols have different methods for retrieving or calculating a public key from an address.
     * @summary Identity key from blockchain address.
     * @param {string} address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana'} protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getIdentityKey(address, protocol, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentityKey(address, protocol, options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    },
    /**
     * Calculates all addresses for supported protocols. Then checks to see if vended messaging keys have been created. Only returns addresses that have vended messaging keys.
     * @summary Gets all for an address for an identity key.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getIdentityKeyAddresses(identityKey, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentityKeyAddresses(identityKey, options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    },
    /**
     * This method will get take the identity key and look against each protocol where it could be present and check against supported name service resolvers. It will return all resolved names.
     * @summary Get all linked names for a resolver
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {Array<string>} [kind] Kind of reverse resolver to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getIdentityKeyResolvableNames(identityKey, kind, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentityKeyResolvableNames(identityKey, kind, options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    },
    /**
     * 
     * @summary Get a Mailchain messaging key.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {number} [at] The time to query the messaging key at.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMsgKey(identityKey, at, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMsgKey(identityKey, at, options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    },
    /**
     * Save the identity key for the given address. Identity keys are only saved for protocols where the key cannot be determined from the address.
     * @summary Store address identity key.
     * @param {string} address Address to look for encoded based on the protocol standard.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {string} protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async putAddressIdentityKey(address, identityKey, protocol, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.putAddressIdentityKey(address, identityKey, protocol, options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    },
    /**
     * Only address owners can change an address\'s messaging key. Owner\'s need to sign a message that includes the new messaging key and nonce.
     * @summary Upload a messaging key for an address\'s identity key.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {PutMsgKeyByIDKeyRequestBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async putMsgKeyByIDKey(identityKey, body, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.putMsgKeyByIDKey(identityKey, body, options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    }
  };
};
var IdentityKeysApiFactory = function(configuration, basePath, axios) {
  const localVarFp = IdentityKeysApiFp(configuration);
  return {
    /**
     * This method will get the identity key associated with a blockchain address. Protocols have different methods for retrieving or calculating a public key from an address.
     * @summary Identity key from blockchain address.
     * @param {string} address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana'} protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIdentityKey(address, protocol, options) {
      return localVarFp.getIdentityKey(address, protocol, options).then((request) => request(axios, basePath));
    },
    /**
     * Calculates all addresses for supported protocols. Then checks to see if vended messaging keys have been created. Only returns addresses that have vended messaging keys.
     * @summary Gets all for an address for an identity key.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIdentityKeyAddresses(identityKey, options) {
      return localVarFp.getIdentityKeyAddresses(identityKey, options).then((request) => request(axios, basePath));
    },
    /**
     * This method will get take the identity key and look against each protocol where it could be present and check against supported name service resolvers. It will return all resolved names.
     * @summary Get all linked names for a resolver
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {Array<string>} [kind] Kind of reverse resolver to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIdentityKeyResolvableNames(identityKey, kind, options) {
      return localVarFp.getIdentityKeyResolvableNames(identityKey, kind, options).then((request) => request(axios, basePath));
    },
    /**
     * 
     * @summary Get a Mailchain messaging key.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {number} [at] The time to query the messaging key at.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMsgKey(identityKey, at, options) {
      return localVarFp.getMsgKey(identityKey, at, options).then((request) => request(axios, basePath));
    },
    /**
     * Save the identity key for the given address. Identity keys are only saved for protocols where the key cannot be determined from the address.
     * @summary Store address identity key.
     * @param {string} address Address to look for encoded based on the protocol standard.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {string} protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putAddressIdentityKey(address, identityKey, protocol, options) {
      return localVarFp.putAddressIdentityKey(address, identityKey, protocol, options).then((request) => request(axios, basePath));
    },
    /**
     * Only address owners can change an address\'s messaging key. Owner\'s need to sign a message that includes the new messaging key and nonce.
     * @summary Upload a messaging key for an address\'s identity key.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {PutMsgKeyByIDKeyRequestBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putMsgKeyByIDKey(identityKey, body, options) {
      return localVarFp.putMsgKeyByIDKey(identityKey, body, options).then((request) => request(axios, basePath));
    }
  };
};
var IdentityKeysApi = class extends _chunk7VCGQ36Wjs.BaseAPI {
  /**
   * This method will get the identity key associated with a blockchain address. Protocols have different methods for retrieving or calculating a public key from an address.
   * @summary Identity key from blockchain address.
   * @param {string} address Address to look for encoded based on the protocol standard.
   * @param {'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana'} protocol Protocol where address is looked up.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IdentityKeysApi
   */
  getIdentityKey(address, protocol, options) {
    return IdentityKeysApiFp(this.configuration).getIdentityKey(address, protocol, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Calculates all addresses for supported protocols. Then checks to see if vended messaging keys have been created. Only returns addresses that have vended messaging keys.
   * @summary Gets all for an address for an identity key.
   * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IdentityKeysApi
   */
  getIdentityKeyAddresses(identityKey, options) {
    return IdentityKeysApiFp(this.configuration).getIdentityKeyAddresses(identityKey, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * This method will get take the identity key and look against each protocol where it could be present and check against supported name service resolvers. It will return all resolved names.
   * @summary Get all linked names for a resolver
   * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
   * @param {Array<string>} [kind] Kind of reverse resolver to return.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IdentityKeysApi
   */
  getIdentityKeyResolvableNames(identityKey, kind, options) {
    return IdentityKeysApiFp(this.configuration).getIdentityKeyResolvableNames(identityKey, kind, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * 
   * @summary Get a Mailchain messaging key.
   * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
   * @param {number} [at] The time to query the messaging key at.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IdentityKeysApi
   */
  getMsgKey(identityKey, at, options) {
    return IdentityKeysApiFp(this.configuration).getMsgKey(identityKey, at, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Save the identity key for the given address. Identity keys are only saved for protocols where the key cannot be determined from the address.
   * @summary Store address identity key.
   * @param {string} address Address to look for encoded based on the protocol standard.
   * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
   * @param {string} protocol Protocol where address is looked up.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IdentityKeysApi
   */
  putAddressIdentityKey(address, identityKey, protocol, options) {
    return IdentityKeysApiFp(this.configuration).putAddressIdentityKey(address, identityKey, protocol, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Only address owners can change an address\'s messaging key. Owner\'s need to sign a message that includes the new messaging key and nonce.
   * @summary Upload a messaging key for an address\'s identity key.
   * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
   * @param {PutMsgKeyByIDKeyRequestBody} body 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IdentityKeysApi
   */
  putMsgKeyByIDKey(identityKey, body, options) {
    return IdentityKeysApiFp(this.configuration).putMsgKeyByIDKey(identityKey, body, options).then((request) => request(this.axios, this.basePath));
  }
};
var InboxApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * 
     * @summary Remove label from message.
     * @param {string} messageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
     * @param {string} label Label to add to the message.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMessageLabel: async (messageId, label, options = {}) => {
      _chunkZFXYEUUWjs.assertParamExists.call(void 0, "deleteMessageLabel", "messageId", messageId);
      _chunkZFXYEUUWjs.assertParamExists.call(void 0, "deleteMessageLabel", "label", label);
      const localVarPath = `/inbox/messages/{messageId}/labels/{label}`.replace(`{${"messageId"}}`, encodeURIComponent(String(messageId))).replace(`{${"label"}}`, encodeURIComponent(String(label)));
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get encrypted payload message body
     * @param {string} messageId The message id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEncryptedMessageBody: async (messageId, options = {}) => {
      _chunkZFXYEUUWjs.assertParamExists.call(void 0, "getEncryptedMessageBody", "messageId", messageId);
      const localVarPath = `/inbox/messages/{messageId}/body`.replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)));
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get message item
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMailboxOverview: async (mailboxes, options = {}) => {
      const localVarPath = `/inbox/overview`;
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      if (mailboxes) {
        localVarQueryParameter["mailboxes"] = mailboxes.join(_chunk7VCGQ36Wjs.COLLECTION_FORMATS.csv);
      }
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get message item
     * @param {string} messageId The message id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessage: async (messageId, options = {}) => {
      _chunkZFXYEUUWjs.assertParamExists.call(void 0, "getMessage", "messageId", messageId);
      const localVarPath = `/inbox/messages/{messageId}`.replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)));
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get messages that have been archived
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInArchivedView: async (labels, from, to, offset, limit, mailboxes, options = {}) => {
      const localVarPath = `/inbox/views/archived`;
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      if (labels) {
        localVarQueryParameter["labels"] = labels.join(_chunk7VCGQ36Wjs.COLLECTION_FORMATS.csv);
      }
      if (from !== void 0) {
        localVarQueryParameter["from"] = from;
      }
      if (to) {
        localVarQueryParameter["to"] = to.join(_chunk7VCGQ36Wjs.COLLECTION_FORMATS.csv);
      }
      if (offset !== void 0) {
        localVarQueryParameter["offset"] = offset;
      }
      if (limit !== void 0) {
        localVarQueryParameter["limit"] = limit;
      }
      if (mailboxes) {
        localVarQueryParameter["mailboxes"] = mailboxes.join(_chunk7VCGQ36Wjs.COLLECTION_FORMATS.csv);
      }
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get messages in inbox
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInInboxView: async (labels, from, to, offset, limit, mailboxes, options = {}) => {
      const localVarPath = `/inbox/views/inbox`;
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      if (labels) {
        localVarQueryParameter["labels"] = labels.join(_chunk7VCGQ36Wjs.COLLECTION_FORMATS.csv);
      }
      if (from !== void 0) {
        localVarQueryParameter["from"] = from;
      }
      if (to) {
        localVarQueryParameter["to"] = to.join(_chunk7VCGQ36Wjs.COLLECTION_FORMATS.csv);
      }
      if (offset !== void 0) {
        localVarQueryParameter["offset"] = offset;
      }
      if (limit !== void 0) {
        localVarQueryParameter["limit"] = limit;
      }
      if (mailboxes) {
        localVarQueryParameter["mailboxes"] = mailboxes.join(_chunk7VCGQ36Wjs.COLLECTION_FORMATS.csv);
      }
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 
     * @summary Get messages that have not sent yet.
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInOutboxView: async (labels, from, to, offset, limit, mailboxes, options = {}) => {
      const localVarPath = `/inbox/views/outbox`;
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      if (labels) {
        localVarQueryParameter["labels"] = labels.join(_chunk7VCGQ36Wjs.COLLECTION_FORMATS.csv);
      }
      if (from !== void 0) {
        localVarQueryParameter["from"] = from;
      }
      if (to) {
        localVarQueryParameter["to"] = to.join(_chunk7VCGQ36Wjs.COLLECTION_FORMATS.csv);
      }
      if (offset !== void 0) {
        localVarQueryParameter["offset"] = offset;
      }
      if (limit !== void 0) {
        localVarQueryParameter["limit"] = limit;
      }
      if (mailboxes) {
        localVarQueryParameter["mailboxes"] = mailboxes.join(_chunk7VCGQ36Wjs.COLLECTION_FORMATS.csv);
      }
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get messages in sent folder
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInSentView: async (labels, from, to, offset, limit, mailboxes, options = {}) => {
      const localVarPath = `/inbox/views/sent`;
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      if (labels) {
        localVarQueryParameter["labels"] = labels.join(_chunk7VCGQ36Wjs.COLLECTION_FORMATS.csv);
      }
      if (from !== void 0) {
        localVarQueryParameter["from"] = from;
      }
      if (to) {
        localVarQueryParameter["to"] = to.join(_chunk7VCGQ36Wjs.COLLECTION_FORMATS.csv);
      }
      if (offset !== void 0) {
        localVarQueryParameter["offset"] = offset;
      }
      if (limit !== void 0) {
        localVarQueryParameter["limit"] = limit;
      }
      if (mailboxes) {
        localVarQueryParameter["mailboxes"] = mailboxes.join(_chunk7VCGQ36Wjs.COLLECTION_FORMATS.csv);
      }
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get messages in spam folder
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInSpamView: async (labels, from, to, offset, limit, mailboxes, options = {}) => {
      const localVarPath = `/inbox/views/spam`;
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      if (labels) {
        localVarQueryParameter["labels"] = labels.join(_chunk7VCGQ36Wjs.COLLECTION_FORMATS.csv);
      }
      if (from !== void 0) {
        localVarQueryParameter["from"] = from;
      }
      if (to) {
        localVarQueryParameter["to"] = to.join(_chunk7VCGQ36Wjs.COLLECTION_FORMATS.csv);
      }
      if (offset !== void 0) {
        localVarQueryParameter["offset"] = offset;
      }
      if (limit !== void 0) {
        localVarQueryParameter["limit"] = limit;
      }
      if (mailboxes) {
        localVarQueryParameter["mailboxes"] = mailboxes.join(_chunk7VCGQ36Wjs.COLLECTION_FORMATS.csv);
      }
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 
     * @summary Get messages marked as starred by the user.
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInStarredView: async (labels, from, to, offset, limit, mailboxes, options = {}) => {
      const localVarPath = `/inbox/views/starred`;
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      if (labels) {
        localVarQueryParameter["labels"] = labels.join(_chunk7VCGQ36Wjs.COLLECTION_FORMATS.csv);
      }
      if (from !== void 0) {
        localVarQueryParameter["from"] = from;
      }
      if (to) {
        localVarQueryParameter["to"] = to.join(_chunk7VCGQ36Wjs.COLLECTION_FORMATS.csv);
      }
      if (offset !== void 0) {
        localVarQueryParameter["offset"] = offset;
      }
      if (limit !== void 0) {
        localVarQueryParameter["limit"] = limit;
      }
      if (mailboxes) {
        localVarQueryParameter["mailboxes"] = mailboxes.join(_chunk7VCGQ36Wjs.COLLECTION_FORMATS.csv);
      }
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get messages in trash folder
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInTrashView: async (labels, from, to, offset, limit, mailboxes, options = {}) => {
      const localVarPath = `/inbox/views/trash`;
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      if (labels) {
        localVarQueryParameter["labels"] = labels.join(_chunk7VCGQ36Wjs.COLLECTION_FORMATS.csv);
      }
      if (from !== void 0) {
        localVarQueryParameter["from"] = from;
      }
      if (to) {
        localVarQueryParameter["to"] = to.join(_chunk7VCGQ36Wjs.COLLECTION_FORMATS.csv);
      }
      if (offset !== void 0) {
        localVarQueryParameter["offset"] = offset;
      }
      if (limit !== void 0) {
        localVarQueryParameter["limit"] = limit;
      }
      if (mailboxes) {
        localVarQueryParameter["mailboxes"] = mailboxes.join(_chunk7VCGQ36Wjs.COLLECTION_FORMATS.csv);
      }
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 
     * @summary Get messages that have not been read by the user.
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInUnreadView: async (labels, from, to, offset, limit, mailboxes, options = {}) => {
      const localVarPath = `/inbox/views/unread`;
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      if (labels) {
        localVarQueryParameter["labels"] = labels.join(_chunk7VCGQ36Wjs.COLLECTION_FORMATS.csv);
      }
      if (from !== void 0) {
        localVarQueryParameter["from"] = from;
      }
      if (to) {
        localVarQueryParameter["to"] = to.join(_chunk7VCGQ36Wjs.COLLECTION_FORMATS.csv);
      }
      if (offset !== void 0) {
        localVarQueryParameter["offset"] = offset;
      }
      if (limit !== void 0) {
        localVarQueryParameter["limit"] = limit;
      }
      if (mailboxes) {
        localVarQueryParameter["mailboxes"] = mailboxes.join(_chunk7VCGQ36Wjs.COLLECTION_FORMATS.csv);
      }
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Store a message body for later retrieval
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postEncryptedMessageBody: async (body, options = {}) => {
      _chunkZFXYEUUWjs.assertParamExists.call(void 0, "postEncryptedMessageBody", "body", body);
      const localVarPath = `/inbox/message-bodies`;
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      localVarHeaderParameter["Content-Type"] = "application/octet-stream";
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = _chunkZFXYEUUWjs.serializeDataIfNeeded.call(void 0, body, localVarRequestOptions, configuration);
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * The message will be stored in the user\'s inbox. The inbox is private and all encryption happens on the clients machine. The client must keep track of what key was used to encrypt as it will be needed to decrypt later.  To support filtering, sorting and previews while revealing the minimum amount possible to the inbox the client must process the message before and populate the body.
     * @summary Add message to inbox.
     * @param {string} messageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
     * @param {PutEncryptedMessageRequestBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putEncryptedMessage: async (messageId, body, options = {}) => {
      _chunkZFXYEUUWjs.assertParamExists.call(void 0, "putEncryptedMessage", "messageId", messageId);
      _chunkZFXYEUUWjs.assertParamExists.call(void 0, "putEncryptedMessage", "body", body);
      const localVarPath = `/inbox/messages/{messageId}`.replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)));
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      localVarHeaderParameter["Content-Type"] = "application/json";
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = _chunkZFXYEUUWjs.serializeDataIfNeeded.call(void 0, body, localVarRequestOptions, configuration);
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 
     * @summary Add label to message.
     * @param {string} messageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
     * @param {string} label Label to add to the message.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putMessageLabel: async (messageId, label, options = {}) => {
      _chunkZFXYEUUWjs.assertParamExists.call(void 0, "putMessageLabel", "messageId", messageId);
      _chunkZFXYEUUWjs.assertParamExists.call(void 0, "putMessageLabel", "label", label);
      const localVarPath = `/inbox/messages/{messageId}/labels/{label}`.replace(`{${"messageId"}}`, encodeURIComponent(String(messageId))).replace(`{${"label"}}`, encodeURIComponent(String(label)));
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var InboxApiFp = function(configuration) {
  const localVarAxiosParamCreator = InboxApiAxiosParamCreator(configuration);
  return {
    /**
     * 
     * @summary Remove label from message.
     * @param {string} messageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
     * @param {string} label Label to add to the message.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteMessageLabel(messageId, label, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMessageLabel(messageId, label, options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    },
    /**
     * Get encrypted payload message body
     * @param {string} messageId The message id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEncryptedMessageBody(messageId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEncryptedMessageBody(messageId, options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    },
    /**
     * Get message item
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMailboxOverview(mailboxes, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMailboxOverview(mailboxes, options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    },
    /**
     * Get message item
     * @param {string} messageId The message id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMessage(messageId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMessage(messageId, options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    },
    /**
     * Get messages that have been archived
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMessagesInArchivedView(labels, from, to, offset, limit, mailboxes, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMessagesInArchivedView(labels, from, to, offset, limit, mailboxes, options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    },
    /**
     * Get messages in inbox
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMessagesInInboxView(labels, from, to, offset, limit, mailboxes, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMessagesInInboxView(labels, from, to, offset, limit, mailboxes, options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    },
    /**
     * 
     * @summary Get messages that have not sent yet.
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMessagesInOutboxView(labels, from, to, offset, limit, mailboxes, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMessagesInOutboxView(labels, from, to, offset, limit, mailboxes, options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    },
    /**
     * Get messages in sent folder
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMessagesInSentView(labels, from, to, offset, limit, mailboxes, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMessagesInSentView(labels, from, to, offset, limit, mailboxes, options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    },
    /**
     * Get messages in spam folder
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMessagesInSpamView(labels, from, to, offset, limit, mailboxes, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMessagesInSpamView(labels, from, to, offset, limit, mailboxes, options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    },
    /**
     * 
     * @summary Get messages marked as starred by the user.
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMessagesInStarredView(labels, from, to, offset, limit, mailboxes, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMessagesInStarredView(labels, from, to, offset, limit, mailboxes, options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    },
    /**
     * Get messages in trash folder
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMessagesInTrashView(labels, from, to, offset, limit, mailboxes, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMessagesInTrashView(labels, from, to, offset, limit, mailboxes, options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    },
    /**
     * 
     * @summary Get messages that have not been read by the user.
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMessagesInUnreadView(labels, from, to, offset, limit, mailboxes, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMessagesInUnreadView(labels, from, to, offset, limit, mailboxes, options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    },
    /**
     * Store a message body for later retrieval
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postEncryptedMessageBody(body, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postEncryptedMessageBody(body, options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    },
    /**
     * The message will be stored in the user\'s inbox. The inbox is private and all encryption happens on the clients machine. The client must keep track of what key was used to encrypt as it will be needed to decrypt later.  To support filtering, sorting and previews while revealing the minimum amount possible to the inbox the client must process the message before and populate the body.
     * @summary Add message to inbox.
     * @param {string} messageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
     * @param {PutEncryptedMessageRequestBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async putEncryptedMessage(messageId, body, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.putEncryptedMessage(messageId, body, options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    },
    /**
     * 
     * @summary Add label to message.
     * @param {string} messageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
     * @param {string} label Label to add to the message.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async putMessageLabel(messageId, label, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.putMessageLabel(messageId, label, options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    }
  };
};
var InboxApiFactory = function(configuration, basePath, axios) {
  const localVarFp = InboxApiFp(configuration);
  return {
    /**
     * 
     * @summary Remove label from message.
     * @param {string} messageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
     * @param {string} label Label to add to the message.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMessageLabel(messageId, label, options) {
      return localVarFp.deleteMessageLabel(messageId, label, options).then((request) => request(axios, basePath));
    },
    /**
     * Get encrypted payload message body
     * @param {string} messageId The message id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEncryptedMessageBody(messageId, options) {
      return localVarFp.getEncryptedMessageBody(messageId, options).then((request) => request(axios, basePath));
    },
    /**
     * Get message item
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMailboxOverview(mailboxes, options) {
      return localVarFp.getMailboxOverview(mailboxes, options).then((request) => request(axios, basePath));
    },
    /**
     * Get message item
     * @param {string} messageId The message id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessage(messageId, options) {
      return localVarFp.getMessage(messageId, options).then((request) => request(axios, basePath));
    },
    /**
     * Get messages that have been archived
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInArchivedView(labels, from, to, offset, limit, mailboxes, options) {
      return localVarFp.getMessagesInArchivedView(labels, from, to, offset, limit, mailboxes, options).then((request) => request(axios, basePath));
    },
    /**
     * Get messages in inbox
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInInboxView(labels, from, to, offset, limit, mailboxes, options) {
      return localVarFp.getMessagesInInboxView(labels, from, to, offset, limit, mailboxes, options).then((request) => request(axios, basePath));
    },
    /**
     * 
     * @summary Get messages that have not sent yet.
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInOutboxView(labels, from, to, offset, limit, mailboxes, options) {
      return localVarFp.getMessagesInOutboxView(labels, from, to, offset, limit, mailboxes, options).then((request) => request(axios, basePath));
    },
    /**
     * Get messages in sent folder
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInSentView(labels, from, to, offset, limit, mailboxes, options) {
      return localVarFp.getMessagesInSentView(labels, from, to, offset, limit, mailboxes, options).then((request) => request(axios, basePath));
    },
    /**
     * Get messages in spam folder
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInSpamView(labels, from, to, offset, limit, mailboxes, options) {
      return localVarFp.getMessagesInSpamView(labels, from, to, offset, limit, mailboxes, options).then((request) => request(axios, basePath));
    },
    /**
     * 
     * @summary Get messages marked as starred by the user.
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInStarredView(labels, from, to, offset, limit, mailboxes, options) {
      return localVarFp.getMessagesInStarredView(labels, from, to, offset, limit, mailboxes, options).then((request) => request(axios, basePath));
    },
    /**
     * Get messages in trash folder
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInTrashView(labels, from, to, offset, limit, mailboxes, options) {
      return localVarFp.getMessagesInTrashView(labels, from, to, offset, limit, mailboxes, options).then((request) => request(axios, basePath));
    },
    /**
     * 
     * @summary Get messages that have not been read by the user.
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInUnreadView(labels, from, to, offset, limit, mailboxes, options) {
      return localVarFp.getMessagesInUnreadView(labels, from, to, offset, limit, mailboxes, options).then((request) => request(axios, basePath));
    },
    /**
     * Store a message body for later retrieval
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postEncryptedMessageBody(body, options) {
      return localVarFp.postEncryptedMessageBody(body, options).then((request) => request(axios, basePath));
    },
    /**
     * The message will be stored in the user\'s inbox. The inbox is private and all encryption happens on the clients machine. The client must keep track of what key was used to encrypt as it will be needed to decrypt later.  To support filtering, sorting and previews while revealing the minimum amount possible to the inbox the client must process the message before and populate the body.
     * @summary Add message to inbox.
     * @param {string} messageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
     * @param {PutEncryptedMessageRequestBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putEncryptedMessage(messageId, body, options) {
      return localVarFp.putEncryptedMessage(messageId, body, options).then((request) => request(axios, basePath));
    },
    /**
     * 
     * @summary Add label to message.
     * @param {string} messageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
     * @param {string} label Label to add to the message.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putMessageLabel(messageId, label, options) {
      return localVarFp.putMessageLabel(messageId, label, options).then((request) => request(axios, basePath));
    }
  };
};
var InboxApi = class extends _chunk7VCGQ36Wjs.BaseAPI {
  /**
   * 
   * @summary Remove label from message.
   * @param {string} messageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
   * @param {string} label Label to add to the message.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InboxApi
   */
  deleteMessageLabel(messageId, label, options) {
    return InboxApiFp(this.configuration).deleteMessageLabel(messageId, label, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Get encrypted payload message body
   * @param {string} messageId The message id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InboxApi
   */
  getEncryptedMessageBody(messageId, options) {
    return InboxApiFp(this.configuration).getEncryptedMessageBody(messageId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Get message item
   * @param {Array<string>} [mailboxes] Filter overview by mailbox
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InboxApi
   */
  getMailboxOverview(mailboxes, options) {
    return InboxApiFp(this.configuration).getMailboxOverview(mailboxes, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Get message item
   * @param {string} messageId The message id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InboxApi
   */
  getMessage(messageId, options) {
    return InboxApiFp(this.configuration).getMessage(messageId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Get messages that have been archived
   * @param {Array<string>} [labels] Labels to additionally search for
   * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
   * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
   * @param {number} [offset] Messages offset. Starting point of paginated messages.
   * @param {number} [limit] Messages limit. Message count in each page.
   * @param {Array<string>} [mailboxes] Filter overview by mailbox
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InboxApi
   */
  getMessagesInArchivedView(labels, from, to, offset, limit, mailboxes, options) {
    return InboxApiFp(this.configuration).getMessagesInArchivedView(labels, from, to, offset, limit, mailboxes, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Get messages in inbox
   * @param {Array<string>} [labels] Labels to additionally search for
   * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
   * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
   * @param {number} [offset] Messages offset. Starting point of paginated messages.
   * @param {number} [limit] Messages limit. Message count in each page.
   * @param {Array<string>} [mailboxes] Filter overview by mailbox
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InboxApi
   */
  getMessagesInInboxView(labels, from, to, offset, limit, mailboxes, options) {
    return InboxApiFp(this.configuration).getMessagesInInboxView(labels, from, to, offset, limit, mailboxes, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * 
   * @summary Get messages that have not sent yet.
   * @param {Array<string>} [labels] Labels to additionally search for
   * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
   * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
   * @param {number} [offset] Messages offset. Starting point of paginated messages.
   * @param {number} [limit] Messages limit. Message count in each page.
   * @param {Array<string>} [mailboxes] Filter overview by mailbox
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InboxApi
   */
  getMessagesInOutboxView(labels, from, to, offset, limit, mailboxes, options) {
    return InboxApiFp(this.configuration).getMessagesInOutboxView(labels, from, to, offset, limit, mailboxes, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Get messages in sent folder
   * @param {Array<string>} [labels] Labels to additionally search for
   * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
   * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
   * @param {number} [offset] Messages offset. Starting point of paginated messages.
   * @param {number} [limit] Messages limit. Message count in each page.
   * @param {Array<string>} [mailboxes] Filter overview by mailbox
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InboxApi
   */
  getMessagesInSentView(labels, from, to, offset, limit, mailboxes, options) {
    return InboxApiFp(this.configuration).getMessagesInSentView(labels, from, to, offset, limit, mailboxes, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Get messages in spam folder
   * @param {Array<string>} [labels] Labels to additionally search for
   * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
   * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
   * @param {number} [offset] Messages offset. Starting point of paginated messages.
   * @param {number} [limit] Messages limit. Message count in each page.
   * @param {Array<string>} [mailboxes] Filter overview by mailbox
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InboxApi
   */
  getMessagesInSpamView(labels, from, to, offset, limit, mailboxes, options) {
    return InboxApiFp(this.configuration).getMessagesInSpamView(labels, from, to, offset, limit, mailboxes, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * 
   * @summary Get messages marked as starred by the user.
   * @param {Array<string>} [labels] Labels to additionally search for
   * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
   * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
   * @param {number} [offset] Messages offset. Starting point of paginated messages.
   * @param {number} [limit] Messages limit. Message count in each page.
   * @param {Array<string>} [mailboxes] Filter overview by mailbox
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InboxApi
   */
  getMessagesInStarredView(labels, from, to, offset, limit, mailboxes, options) {
    return InboxApiFp(this.configuration).getMessagesInStarredView(labels, from, to, offset, limit, mailboxes, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Get messages in trash folder
   * @param {Array<string>} [labels] Labels to additionally search for
   * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
   * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
   * @param {number} [offset] Messages offset. Starting point of paginated messages.
   * @param {number} [limit] Messages limit. Message count in each page.
   * @param {Array<string>} [mailboxes] Filter overview by mailbox
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InboxApi
   */
  getMessagesInTrashView(labels, from, to, offset, limit, mailboxes, options) {
    return InboxApiFp(this.configuration).getMessagesInTrashView(labels, from, to, offset, limit, mailboxes, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * 
   * @summary Get messages that have not been read by the user.
   * @param {Array<string>} [labels] Labels to additionally search for
   * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
   * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
   * @param {number} [offset] Messages offset. Starting point of paginated messages.
   * @param {number} [limit] Messages limit. Message count in each page.
   * @param {Array<string>} [mailboxes] Filter overview by mailbox
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InboxApi
   */
  getMessagesInUnreadView(labels, from, to, offset, limit, mailboxes, options) {
    return InboxApiFp(this.configuration).getMessagesInUnreadView(labels, from, to, offset, limit, mailboxes, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Store a message body for later retrieval
   * @param {object} body 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InboxApi
   */
  postEncryptedMessageBody(body, options) {
    return InboxApiFp(this.configuration).postEncryptedMessageBody(body, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * The message will be stored in the user\'s inbox. The inbox is private and all encryption happens on the clients machine. The client must keep track of what key was used to encrypt as it will be needed to decrypt later.  To support filtering, sorting and previews while revealing the minimum amount possible to the inbox the client must process the message before and populate the body.
   * @summary Add message to inbox.
   * @param {string} messageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
   * @param {PutEncryptedMessageRequestBody} body 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InboxApi
   */
  putEncryptedMessage(messageId, body, options) {
    return InboxApiFp(this.configuration).putEncryptedMessage(messageId, body, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * 
   * @summary Add label to message.
   * @param {string} messageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
   * @param {string} label Label to add to the message.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InboxApi
   */
  putMessageLabel(messageId, label, options) {
    return InboxApiFp(this.configuration).putMessageLabel(messageId, label, options).then((request) => request(this.axios, this.basePath));
  }
};
var MessagingKeysApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Calculates all addresses for supported protocols. Then checks to see if vended messaging keys have been created. Only returns addresses that have vended messaging keys.
     * @summary Gets all for an address for an identity key.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIdentityKeyAddresses: async (identityKey, options = {}) => {
      _chunkZFXYEUUWjs.assertParamExists.call(void 0, "getIdentityKeyAddresses", "identityKey", identityKey);
      const localVarPath = `/identity-keys/{identityKey}/addresses`.replace(`{${"identityKey"}}`, encodeURIComponent(String(identityKey)));
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get identity key nonce
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIdentityKeyNonce: async (identityKey, options = {}) => {
      _chunkZFXYEUUWjs.assertParamExists.call(void 0, "getIdentityKeyNonce", "identityKey", identityKey);
      const localVarPath = `/identity-key/{identityKey}/nonce`.replace(`{${"identityKey"}}`, encodeURIComponent(String(identityKey)));
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 
     * @summary Get\'s the public to used to verify Mailchain provided messaging keys.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMailchainPublicKey: async (options = {}) => {
      const localVarPath = `/verification-keys/messaging`;
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 
     * @summary Get a Mailchain messaging key.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {number} [at] The time to query the messaging key at.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMsgKey: async (identityKey, at, options = {}) => {
      _chunkZFXYEUUWjs.assertParamExists.call(void 0, "getMsgKey", "identityKey", identityKey);
      const localVarPath = `/identity-key/{identityKey}/messaging-key`.replace(`{${"identityKey"}}`, encodeURIComponent(String(identityKey)));
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      if (at !== void 0) {
        localVarQueryParameter["at"] = at;
      }
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get protocol address nonce
     * @param {string} address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana'} protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProtocolAddressNonce: async (address, protocol, options = {}) => {
      _chunkZFXYEUUWjs.assertParamExists.call(void 0, "getProtocolAddressNonce", "address", address);
      _chunkZFXYEUUWjs.assertParamExists.call(void 0, "getProtocolAddressNonce", "protocol", protocol);
      const localVarPath = `/protocols/{protocol}/addresses/{address}/nonce`.replace(`{${"address"}}`, encodeURIComponent(String(address))).replace(`{${"protocol"}}`, encodeURIComponent(String(protocol)));
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * First it looks up the identity key for the address to see if a user has registered a messaging key for the blockchain address. If a key is not registered it will return a Mailchain vended messaging key. Note: this will only return the vended messaging for owners of the address.
     * @summary Get\'s the private messaging key for a blockchain address.
     * @param {string} address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana'} protocol Protocol where address is looked up.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVendedPrivateMessagingKey: async (address, protocol, identityKey, options = {}) => {
      _chunkZFXYEUUWjs.assertParamExists.call(void 0, "getVendedPrivateMessagingKey", "address", address);
      _chunkZFXYEUUWjs.assertParamExists.call(void 0, "getVendedPrivateMessagingKey", "protocol", protocol);
      _chunkZFXYEUUWjs.assertParamExists.call(void 0, "getVendedPrivateMessagingKey", "identityKey", identityKey);
      const localVarPath = `/protocols/{protocol}/addresses/{address}/vended-private-messaging-key`.replace(`{${"address"}}`, encodeURIComponent(String(address))).replace(`{${"protocol"}}`, encodeURIComponent(String(protocol)));
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      if (identityKey !== void 0) {
        localVarQueryParameter["identityKey"] = identityKey;
      }
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * First it looks up the identity key for the address to see if a user has registered that the public key. In this case it will vend messaging key for the identity key. Otherwise it will vend a messaging key for the blockchain address.
     * @summary Get\'s the public messaging key for a blockchain address.
     * @param {string} address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana'} protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVendedPublicMessagingKey: async (address, protocol, options = {}) => {
      _chunkZFXYEUUWjs.assertParamExists.call(void 0, "getVendedPublicMessagingKey", "address", address);
      _chunkZFXYEUUWjs.assertParamExists.call(void 0, "getVendedPublicMessagingKey", "protocol", protocol);
      const localVarPath = `/protocols/{protocol}/addresses/{address}/vended-public-messaging-key`.replace(`{${"address"}}`, encodeURIComponent(String(address))).replace(`{${"protocol"}}`, encodeURIComponent(String(protocol)));
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Only address owners can change an address\'s messaging key. Owner\'s need to sign a message that includes the new messaging key and nonce.
     * @summary Upload a messaging key for an address\'s identity key.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {PutMsgKeyByIDKeyRequestBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putMsgKeyByIDKey: async (identityKey, body, options = {}) => {
      _chunkZFXYEUUWjs.assertParamExists.call(void 0, "putMsgKeyByIDKey", "identityKey", identityKey);
      _chunkZFXYEUUWjs.assertParamExists.call(void 0, "putMsgKeyByIDKey", "body", body);
      const localVarPath = `/identity-key/{identityKey}/messaging-key`.replace(`{${"identityKey"}}`, encodeURIComponent(String(identityKey)));
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      localVarHeaderParameter["Content-Type"] = "application/json";
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = _chunkZFXYEUUWjs.serializeDataIfNeeded.call(void 0, body, localVarRequestOptions, configuration);
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var MessagingKeysApiFp = function(configuration) {
  const localVarAxiosParamCreator = MessagingKeysApiAxiosParamCreator(configuration);
  return {
    /**
     * Calculates all addresses for supported protocols. Then checks to see if vended messaging keys have been created. Only returns addresses that have vended messaging keys.
     * @summary Gets all for an address for an identity key.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getIdentityKeyAddresses(identityKey, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentityKeyAddresses(identityKey, options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    },
    /**
     * Get identity key nonce
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getIdentityKeyNonce(identityKey, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getIdentityKeyNonce(identityKey, options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    },
    /**
     * 
     * @summary Get\'s the public to used to verify Mailchain provided messaging keys.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMailchainPublicKey(options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMailchainPublicKey(options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    },
    /**
     * 
     * @summary Get a Mailchain messaging key.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {number} [at] The time to query the messaging key at.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMsgKey(identityKey, at, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMsgKey(identityKey, at, options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    },
    /**
     * Get protocol address nonce
     * @param {string} address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana'} protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getProtocolAddressNonce(address, protocol, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getProtocolAddressNonce(address, protocol, options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    },
    /**
     * First it looks up the identity key for the address to see if a user has registered a messaging key for the blockchain address. If a key is not registered it will return a Mailchain vended messaging key. Note: this will only return the vended messaging for owners of the address.
     * @summary Get\'s the private messaging key for a blockchain address.
     * @param {string} address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana'} protocol Protocol where address is looked up.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getVendedPrivateMessagingKey(address, protocol, identityKey, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getVendedPrivateMessagingKey(address, protocol, identityKey, options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    },
    /**
     * First it looks up the identity key for the address to see if a user has registered that the public key. In this case it will vend messaging key for the identity key. Otherwise it will vend a messaging key for the blockchain address.
     * @summary Get\'s the public messaging key for a blockchain address.
     * @param {string} address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana'} protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getVendedPublicMessagingKey(address, protocol, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getVendedPublicMessagingKey(address, protocol, options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    },
    /**
     * Only address owners can change an address\'s messaging key. Owner\'s need to sign a message that includes the new messaging key and nonce.
     * @summary Upload a messaging key for an address\'s identity key.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {PutMsgKeyByIDKeyRequestBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async putMsgKeyByIDKey(identityKey, body, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.putMsgKeyByIDKey(identityKey, body, options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    }
  };
};
var MessagingKeysApiFactory = function(configuration, basePath, axios) {
  const localVarFp = MessagingKeysApiFp(configuration);
  return {
    /**
     * Calculates all addresses for supported protocols. Then checks to see if vended messaging keys have been created. Only returns addresses that have vended messaging keys.
     * @summary Gets all for an address for an identity key.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIdentityKeyAddresses(identityKey, options) {
      return localVarFp.getIdentityKeyAddresses(identityKey, options).then((request) => request(axios, basePath));
    },
    /**
     * Get identity key nonce
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIdentityKeyNonce(identityKey, options) {
      return localVarFp.getIdentityKeyNonce(identityKey, options).then((request) => request(axios, basePath));
    },
    /**
     * 
     * @summary Get\'s the public to used to verify Mailchain provided messaging keys.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMailchainPublicKey(options) {
      return localVarFp.getMailchainPublicKey(options).then((request) => request(axios, basePath));
    },
    /**
     * 
     * @summary Get a Mailchain messaging key.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {number} [at] The time to query the messaging key at.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMsgKey(identityKey, at, options) {
      return localVarFp.getMsgKey(identityKey, at, options).then((request) => request(axios, basePath));
    },
    /**
     * Get protocol address nonce
     * @param {string} address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana'} protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProtocolAddressNonce(address, protocol, options) {
      return localVarFp.getProtocolAddressNonce(address, protocol, options).then((request) => request(axios, basePath));
    },
    /**
     * First it looks up the identity key for the address to see if a user has registered a messaging key for the blockchain address. If a key is not registered it will return a Mailchain vended messaging key. Note: this will only return the vended messaging for owners of the address.
     * @summary Get\'s the private messaging key for a blockchain address.
     * @param {string} address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana'} protocol Protocol where address is looked up.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVendedPrivateMessagingKey(address, protocol, identityKey, options) {
      return localVarFp.getVendedPrivateMessagingKey(address, protocol, identityKey, options).then((request) => request(axios, basePath));
    },
    /**
     * First it looks up the identity key for the address to see if a user has registered that the public key. In this case it will vend messaging key for the identity key. Otherwise it will vend a messaging key for the blockchain address.
     * @summary Get\'s the public messaging key for a blockchain address.
     * @param {string} address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana'} protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVendedPublicMessagingKey(address, protocol, options) {
      return localVarFp.getVendedPublicMessagingKey(address, protocol, options).then((request) => request(axios, basePath));
    },
    /**
     * Only address owners can change an address\'s messaging key. Owner\'s need to sign a message that includes the new messaging key and nonce.
     * @summary Upload a messaging key for an address\'s identity key.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {PutMsgKeyByIDKeyRequestBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putMsgKeyByIDKey(identityKey, body, options) {
      return localVarFp.putMsgKeyByIDKey(identityKey, body, options).then((request) => request(axios, basePath));
    }
  };
};
var MessagingKeysApi = class extends _chunk7VCGQ36Wjs.BaseAPI {
  /**
   * Calculates all addresses for supported protocols. Then checks to see if vended messaging keys have been created. Only returns addresses that have vended messaging keys.
   * @summary Gets all for an address for an identity key.
   * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MessagingKeysApi
   */
  getIdentityKeyAddresses(identityKey, options) {
    return MessagingKeysApiFp(this.configuration).getIdentityKeyAddresses(identityKey, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Get identity key nonce
   * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MessagingKeysApi
   */
  getIdentityKeyNonce(identityKey, options) {
    return MessagingKeysApiFp(this.configuration).getIdentityKeyNonce(identityKey, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * 
   * @summary Get\'s the public to used to verify Mailchain provided messaging keys.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MessagingKeysApi
   */
  getMailchainPublicKey(options) {
    return MessagingKeysApiFp(this.configuration).getMailchainPublicKey(options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * 
   * @summary Get a Mailchain messaging key.
   * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
   * @param {number} [at] The time to query the messaging key at.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MessagingKeysApi
   */
  getMsgKey(identityKey, at, options) {
    return MessagingKeysApiFp(this.configuration).getMsgKey(identityKey, at, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Get protocol address nonce
   * @param {string} address Address to look for encoded based on the protocol standard.
   * @param {'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana'} protocol Protocol where address is looked up.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MessagingKeysApi
   */
  getProtocolAddressNonce(address, protocol, options) {
    return MessagingKeysApiFp(this.configuration).getProtocolAddressNonce(address, protocol, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * First it looks up the identity key for the address to see if a user has registered a messaging key for the blockchain address. If a key is not registered it will return a Mailchain vended messaging key. Note: this will only return the vended messaging for owners of the address.
   * @summary Get\'s the private messaging key for a blockchain address.
   * @param {string} address Address to look for encoded based on the protocol standard.
   * @param {'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana'} protocol Protocol where address is looked up.
   * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MessagingKeysApi
   */
  getVendedPrivateMessagingKey(address, protocol, identityKey, options) {
    return MessagingKeysApiFp(this.configuration).getVendedPrivateMessagingKey(address, protocol, identityKey, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * First it looks up the identity key for the address to see if a user has registered that the public key. In this case it will vend messaging key for the identity key. Otherwise it will vend a messaging key for the blockchain address.
   * @summary Get\'s the public messaging key for a blockchain address.
   * @param {string} address Address to look for encoded based on the protocol standard.
   * @param {'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana'} protocol Protocol where address is looked up.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MessagingKeysApi
   */
  getVendedPublicMessagingKey(address, protocol, options) {
    return MessagingKeysApiFp(this.configuration).getVendedPublicMessagingKey(address, protocol, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Only address owners can change an address\'s messaging key. Owner\'s need to sign a message that includes the new messaging key and nonce.
   * @summary Upload a messaging key for an address\'s identity key.
   * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
   * @param {PutMsgKeyByIDKeyRequestBody} body 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MessagingKeysApi
   */
  putMsgKeyByIDKey(identityKey, body, options) {
    return MessagingKeysApiFp(this.configuration).putMsgKeyByIDKey(identityKey, body, options).then((request) => request(this.axios, this.basePath));
  }
};
var TransportApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Get unconfirmed delivery requests for a recipient
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDeliveryRequests: async (options = {}) => {
      const localVarPath = `/transport/delivery-requests`;
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get encrypted payload message body
     * @param {string} payloadId The payload id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEncryptedPayload: async (payloadId, options = {}) => {
      _chunkZFXYEUUWjs.assertParamExists.call(void 0, "getEncryptedPayload", "payloadId", payloadId);
      const localVarPath = `/transport/payloads/{payloadId}`.replace(`{${"payloadId"}}`, encodeURIComponent(String(payloadId)));
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Create a new request that delivers a message to the intended address.
     * @summary Add a delivery request
     * @param {PostDeliveryRequestRequestBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postDeliveryRequest: async (body, options = {}) => {
      _chunkZFXYEUUWjs.assertParamExists.call(void 0, "postDeliveryRequest", "body", body);
      const localVarPath = `/transport/delivery-requests`;
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      localVarHeaderParameter["Content-Type"] = "application/json";
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = _chunkZFXYEUUWjs.serializeDataIfNeeded.call(void 0, body, localVarRequestOptions, configuration);
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Store a payload for later delivery
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postEncryptedPayload: async (body, options = {}) => {
      _chunkZFXYEUUWjs.assertParamExists.call(void 0, "postEncryptedPayload", "body", body);
      const localVarPath = `/transport/payloads`;
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      localVarHeaderParameter["Content-Type"] = "application/octet-stream";
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = _chunkZFXYEUUWjs.serializeDataIfNeeded.call(void 0, body, localVarRequestOptions, configuration);
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Put delivery request confirmation
     * @param {string} deliveryRequestHash Hash of delivery request. Hex encoded with 0x prefix.
     * @param {PutDeliveryRequestConfirmationRequestBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putDeliveryRequestConfirmation: async (deliveryRequestHash, body, options = {}) => {
      _chunkZFXYEUUWjs.assertParamExists.call(void 0, "putDeliveryRequestConfirmation", "deliveryRequestHash", deliveryRequestHash);
      _chunkZFXYEUUWjs.assertParamExists.call(void 0, "putDeliveryRequestConfirmation", "body", body);
      const localVarPath = `/transport/delivery-requests/{deliveryRequestHash}/delivery-proof`.replace(`{${"deliveryRequestHash"}}`, encodeURIComponent(String(deliveryRequestHash)));
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      localVarHeaderParameter["Content-Type"] = "application/json";
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = _chunkZFXYEUUWjs.serializeDataIfNeeded.call(void 0, body, localVarRequestOptions, configuration);
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var TransportApiFp = function(configuration) {
  const localVarAxiosParamCreator = TransportApiAxiosParamCreator(configuration);
  return {
    /**
     * Get unconfirmed delivery requests for a recipient
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDeliveryRequests(options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDeliveryRequests(options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    },
    /**
     * Get encrypted payload message body
     * @param {string} payloadId The payload id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEncryptedPayload(payloadId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEncryptedPayload(payloadId, options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    },
    /**
     * Create a new request that delivers a message to the intended address.
     * @summary Add a delivery request
     * @param {PostDeliveryRequestRequestBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postDeliveryRequest(body, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postDeliveryRequest(body, options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    },
    /**
     * Store a payload for later delivery
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postEncryptedPayload(body, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postEncryptedPayload(body, options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    },
    /**
     * Put delivery request confirmation
     * @param {string} deliveryRequestHash Hash of delivery request. Hex encoded with 0x prefix.
     * @param {PutDeliveryRequestConfirmationRequestBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async putDeliveryRequestConfirmation(deliveryRequestHash, body, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.putDeliveryRequestConfirmation(deliveryRequestHash, body, options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    }
  };
};
var TransportApiFactory = function(configuration, basePath, axios) {
  const localVarFp = TransportApiFp(configuration);
  return {
    /**
     * Get unconfirmed delivery requests for a recipient
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDeliveryRequests(options) {
      return localVarFp.getDeliveryRequests(options).then((request) => request(axios, basePath));
    },
    /**
     * Get encrypted payload message body
     * @param {string} payloadId The payload id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEncryptedPayload(payloadId, options) {
      return localVarFp.getEncryptedPayload(payloadId, options).then((request) => request(axios, basePath));
    },
    /**
     * Create a new request that delivers a message to the intended address.
     * @summary Add a delivery request
     * @param {PostDeliveryRequestRequestBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postDeliveryRequest(body, options) {
      return localVarFp.postDeliveryRequest(body, options).then((request) => request(axios, basePath));
    },
    /**
     * Store a payload for later delivery
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postEncryptedPayload(body, options) {
      return localVarFp.postEncryptedPayload(body, options).then((request) => request(axios, basePath));
    },
    /**
     * Put delivery request confirmation
     * @param {string} deliveryRequestHash Hash of delivery request. Hex encoded with 0x prefix.
     * @param {PutDeliveryRequestConfirmationRequestBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putDeliveryRequestConfirmation(deliveryRequestHash, body, options) {
      return localVarFp.putDeliveryRequestConfirmation(deliveryRequestHash, body, options).then((request) => request(axios, basePath));
    }
  };
};
var TransportApi = class extends _chunk7VCGQ36Wjs.BaseAPI {
  /**
   * Get unconfirmed delivery requests for a recipient
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransportApi
   */
  getDeliveryRequests(options) {
    return TransportApiFp(this.configuration).getDeliveryRequests(options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Get encrypted payload message body
   * @param {string} payloadId The payload id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransportApi
   */
  getEncryptedPayload(payloadId, options) {
    return TransportApiFp(this.configuration).getEncryptedPayload(payloadId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Create a new request that delivers a message to the intended address.
   * @summary Add a delivery request
   * @param {PostDeliveryRequestRequestBody} body 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransportApi
   */
  postDeliveryRequest(body, options) {
    return TransportApiFp(this.configuration).postDeliveryRequest(body, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Store a payload for later delivery
   * @param {object} body 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransportApi
   */
  postEncryptedPayload(body, options) {
    return TransportApiFp(this.configuration).postEncryptedPayload(body, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Put delivery request confirmation
   * @param {string} deliveryRequestHash Hash of delivery request. Hex encoded with 0x prefix.
   * @param {PutDeliveryRequestConfirmationRequestBody} body 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransportApi
   */
  putDeliveryRequestConfirmation(deliveryRequestHash, body, options) {
    return TransportApiFp(this.configuration).putDeliveryRequestConfirmation(deliveryRequestHash, body, options).then((request) => request(this.axios, this.basePath));
  }
};
var UserApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * 
     * @summary Deletes an mailbox from the account.
     * @param {string} mailboxId ID of the mailbox to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserMailbox: async (mailboxId, options = {}) => {
      _chunkZFXYEUUWjs.assertParamExists.call(void 0, "deleteUserMailbox", "mailboxId", mailboxId);
      const localVarPath = `/user/mailboxes/{mailboxId}`.replace(`{${"mailboxId"}}`, encodeURIComponent(String(mailboxId)));
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 
     * @summary Deletes a user setting.
     * @param {string} setting Setting to looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserSetting: async (setting, options = {}) => {
      _chunkZFXYEUUWjs.assertParamExists.call(void 0, "deleteUserSetting", "setting", setting);
      const localVarPath = `/user/settings/{setting}`.replace(`{${"setting"}}`, encodeURIComponent(String(setting)));
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * This method will get the user session. Incoming cookie will be checked too see if it\'s expired or invalidated
     * @summary Session cookie.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSessionCookie: async (options = {}) => {
      const localVarPath = `/user/session`;
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 
     * @summary Get mailboxes registered with Mailchain account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserMailboxes: async (options = {}) => {
      const localVarPath = `/user/mailboxes`;
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 
     * @summary Get a Mailchain settings by setting id.
     * @param {string} setting Setting to looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserSetting: async (setting, options = {}) => {
      _chunkZFXYEUUWjs.assertParamExists.call(void 0, "getUserSetting", "setting", setting);
      const localVarPath = `/user/settings/{setting}`.replace(`{${"setting"}}`, encodeURIComponent(String(setting)));
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 
     * @summary Get a Mailchain settings.
     * @param {string} [group] Group of setting to looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserSettings: async (group, options = {}) => {
      const localVarPath = `/user/settings`;
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      if (group !== void 0) {
        localVarQueryParameter["group"] = group;
      }
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get username for currently authenticated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsername: async (options = {}) => {
      const localVarPath = `/user/username`;
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 
     * @summary Adds an mailboxes to an account.
     * @param {PostUserMailboxRequestBody} body Encrypted list of mailboxes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUserMailbox: async (body, options = {}) => {
      _chunkZFXYEUUWjs.assertParamExists.call(void 0, "postUserMailbox", "body", body);
      const localVarPath = `/user/mailboxes`;
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      localVarHeaderParameter["Content-Type"] = "application/json";
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = _chunkZFXYEUUWjs.serializeDataIfNeeded.call(void 0, body, localVarRequestOptions, configuration);
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 
     * @summary Updates a previous stored mailbox for an account.
     * @param {string} mailboxId ID of the mailbox to update
     * @param {PutUserMailboxRequestBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putUserMailbox: async (mailboxId, body, options = {}) => {
      _chunkZFXYEUUWjs.assertParamExists.call(void 0, "putUserMailbox", "mailboxId", mailboxId);
      _chunkZFXYEUUWjs.assertParamExists.call(void 0, "putUserMailbox", "body", body);
      const localVarPath = `/user/mailboxes/{mailboxId}`.replace(`{${"mailboxId"}}`, encodeURIComponent(String(mailboxId)));
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      localVarHeaderParameter["Content-Type"] = "application/json";
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = _chunkZFXYEUUWjs.serializeDataIfNeeded.call(void 0, body, localVarRequestOptions, configuration);
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 
     * @summary Sets a user setting.
     * @param {string} setting Name of the setting to store
     * @param {PutUserSettingRequestBody} body Encrypted private key to store
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putUserSetting: async (setting, body, options = {}) => {
      _chunkZFXYEUUWjs.assertParamExists.call(void 0, "putUserSetting", "setting", setting);
      _chunkZFXYEUUWjs.assertParamExists.call(void 0, "putUserSetting", "body", body);
      const localVarPath = `/user/settings/{setting}`.replace(`{${"setting"}}`, encodeURIComponent(String(setting)));
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      localVarHeaderParameter["Content-Type"] = "application/json";
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = _chunkZFXYEUUWjs.serializeDataIfNeeded.call(void 0, body, localVarRequestOptions, configuration);
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var UserApiFp = function(configuration) {
  const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration);
  return {
    /**
     * 
     * @summary Deletes an mailbox from the account.
     * @param {string} mailboxId ID of the mailbox to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUserMailbox(mailboxId, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserMailbox(mailboxId, options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    },
    /**
     * 
     * @summary Deletes a user setting.
     * @param {string} setting Setting to looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUserSetting(setting, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserSetting(setting, options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    },
    /**
     * This method will get the user session. Incoming cookie will be checked too see if it\'s expired or invalidated
     * @summary Session cookie.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSessionCookie(options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionCookie(options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    },
    /**
     * 
     * @summary Get mailboxes registered with Mailchain account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserMailboxes(options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUserMailboxes(options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    },
    /**
     * 
     * @summary Get a Mailchain settings by setting id.
     * @param {string} setting Setting to looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserSetting(setting, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUserSetting(setting, options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    },
    /**
     * 
     * @summary Get a Mailchain settings.
     * @param {string} [group] Group of setting to looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserSettings(group, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUserSettings(group, options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    },
    /**
     * Get username for currently authenticated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUsername(options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUsername(options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    },
    /**
     * 
     * @summary Adds an mailboxes to an account.
     * @param {PostUserMailboxRequestBody} body Encrypted list of mailboxes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postUserMailbox(body, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postUserMailbox(body, options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    },
    /**
     * 
     * @summary Updates a previous stored mailbox for an account.
     * @param {string} mailboxId ID of the mailbox to update
     * @param {PutUserMailboxRequestBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async putUserMailbox(mailboxId, body, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.putUserMailbox(mailboxId, body, options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    },
    /**
     * 
     * @summary Sets a user setting.
     * @param {string} setting Name of the setting to store
     * @param {PutUserSettingRequestBody} body Encrypted private key to store
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async putUserSetting(setting, body, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.putUserSetting(setting, body, options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    }
  };
};
var UserApiFactory = function(configuration, basePath, axios) {
  const localVarFp = UserApiFp(configuration);
  return {
    /**
     * 
     * @summary Deletes an mailbox from the account.
     * @param {string} mailboxId ID of the mailbox to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserMailbox(mailboxId, options) {
      return localVarFp.deleteUserMailbox(mailboxId, options).then((request) => request(axios, basePath));
    },
    /**
     * 
     * @summary Deletes a user setting.
     * @param {string} setting Setting to looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserSetting(setting, options) {
      return localVarFp.deleteUserSetting(setting, options).then((request) => request(axios, basePath));
    },
    /**
     * This method will get the user session. Incoming cookie will be checked too see if it\'s expired or invalidated
     * @summary Session cookie.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSessionCookie(options) {
      return localVarFp.getSessionCookie(options).then((request) => request(axios, basePath));
    },
    /**
     * 
     * @summary Get mailboxes registered with Mailchain account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserMailboxes(options) {
      return localVarFp.getUserMailboxes(options).then((request) => request(axios, basePath));
    },
    /**
     * 
     * @summary Get a Mailchain settings by setting id.
     * @param {string} setting Setting to looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserSetting(setting, options) {
      return localVarFp.getUserSetting(setting, options).then((request) => request(axios, basePath));
    },
    /**
     * 
     * @summary Get a Mailchain settings.
     * @param {string} [group] Group of setting to looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserSettings(group, options) {
      return localVarFp.getUserSettings(group, options).then((request) => request(axios, basePath));
    },
    /**
     * Get username for currently authenticated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsername(options) {
      return localVarFp.getUsername(options).then((request) => request(axios, basePath));
    },
    /**
     * 
     * @summary Adds an mailboxes to an account.
     * @param {PostUserMailboxRequestBody} body Encrypted list of mailboxes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUserMailbox(body, options) {
      return localVarFp.postUserMailbox(body, options).then((request) => request(axios, basePath));
    },
    /**
     * 
     * @summary Updates a previous stored mailbox for an account.
     * @param {string} mailboxId ID of the mailbox to update
     * @param {PutUserMailboxRequestBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putUserMailbox(mailboxId, body, options) {
      return localVarFp.putUserMailbox(mailboxId, body, options).then((request) => request(axios, basePath));
    },
    /**
     * 
     * @summary Sets a user setting.
     * @param {string} setting Name of the setting to store
     * @param {PutUserSettingRequestBody} body Encrypted private key to store
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putUserSetting(setting, body, options) {
      return localVarFp.putUserSetting(setting, body, options).then((request) => request(axios, basePath));
    }
  };
};
var UserApi = class extends _chunk7VCGQ36Wjs.BaseAPI {
  /**
   * 
   * @summary Deletes an mailbox from the account.
   * @param {string} mailboxId ID of the mailbox to update
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  deleteUserMailbox(mailboxId, options) {
    return UserApiFp(this.configuration).deleteUserMailbox(mailboxId, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * 
   * @summary Deletes a user setting.
   * @param {string} setting Setting to looked up.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  deleteUserSetting(setting, options) {
    return UserApiFp(this.configuration).deleteUserSetting(setting, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * This method will get the user session. Incoming cookie will be checked too see if it\'s expired or invalidated
   * @summary Session cookie.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  getSessionCookie(options) {
    return UserApiFp(this.configuration).getSessionCookie(options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * 
   * @summary Get mailboxes registered with Mailchain account.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  getUserMailboxes(options) {
    return UserApiFp(this.configuration).getUserMailboxes(options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * 
   * @summary Get a Mailchain settings by setting id.
   * @param {string} setting Setting to looked up.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  getUserSetting(setting, options) {
    return UserApiFp(this.configuration).getUserSetting(setting, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * 
   * @summary Get a Mailchain settings.
   * @param {string} [group] Group of setting to looked up.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  getUserSettings(group, options) {
    return UserApiFp(this.configuration).getUserSettings(group, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * Get username for currently authenticated user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  getUsername(options) {
    return UserApiFp(this.configuration).getUsername(options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * 
   * @summary Adds an mailboxes to an account.
   * @param {PostUserMailboxRequestBody} body Encrypted list of mailboxes.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  postUserMailbox(body, options) {
    return UserApiFp(this.configuration).postUserMailbox(body, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * 
   * @summary Updates a previous stored mailbox for an account.
   * @param {string} mailboxId ID of the mailbox to update
   * @param {PutUserMailboxRequestBody} body 
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  putUserMailbox(mailboxId, body, options) {
    return UserApiFp(this.configuration).putUserMailbox(mailboxId, body, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * 
   * @summary Sets a user setting.
   * @param {string} setting Name of the setting to store
   * @param {PutUserSettingRequestBody} body Encrypted private key to store
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  putUserSetting(setting, body, options) {
    return UserApiFp(this.configuration).putUserSetting(setting, body, options).then((request) => request(this.axios, this.basePath));
  }
};
var UsersApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * This method will get the identity key associated with the Mailchain username.
     * @summary Identity key from blockchain address.
     * @param {string} username Username to get identity key for. This is the user name e.g. alice@mailchain.com would be alice. Usernames are case insensitive.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserIdentityKey: async (username, options = {}) => {
      _chunkZFXYEUUWjs.assertParamExists.call(void 0, "getUserIdentityKey", "username", username);
      const localVarPath = `/users/{username}/identity-key`.replace(`{${"username"}}`, encodeURIComponent(String(username)));
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * 
     * @summary Used to check if an username exists.
     * @param {string} username Username to search for. This is the user name e.g. alice@mailchain.com would be alice. Usernames are case insensitive.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsernameAvailable: async (username, options = {}) => {
      _chunkZFXYEUUWjs.assertParamExists.call(void 0, "getUsernameAvailable", "username", username);
      const localVarPath = `/users`;
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      if (username !== void 0) {
        localVarQueryParameter["username"] = username;
      }
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var UsersApiFp = function(configuration) {
  const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration);
  return {
    /**
     * This method will get the identity key associated with the Mailchain username.
     * @summary Identity key from blockchain address.
     * @param {string} username Username to get identity key for. This is the user name e.g. alice@mailchain.com would be alice. Usernames are case insensitive.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserIdentityKey(username, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUserIdentityKey(username, options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    },
    /**
     * 
     * @summary Used to check if an username exists.
     * @param {string} username Username to search for. This is the user name e.g. alice@mailchain.com would be alice. Usernames are case insensitive.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUsernameAvailable(username, options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUsernameAvailable(username, options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    }
  };
};
var UsersApiFactory = function(configuration, basePath, axios) {
  const localVarFp = UsersApiFp(configuration);
  return {
    /**
     * This method will get the identity key associated with the Mailchain username.
     * @summary Identity key from blockchain address.
     * @param {string} username Username to get identity key for. This is the user name e.g. alice@mailchain.com would be alice. Usernames are case insensitive.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserIdentityKey(username, options) {
      return localVarFp.getUserIdentityKey(username, options).then((request) => request(axios, basePath));
    },
    /**
     * 
     * @summary Used to check if an username exists.
     * @param {string} username Username to search for. This is the user name e.g. alice@mailchain.com would be alice. Usernames are case insensitive.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsernameAvailable(username, options) {
      return localVarFp.getUsernameAvailable(username, options).then((request) => request(axios, basePath));
    }
  };
};
var UsersApi = class extends _chunk7VCGQ36Wjs.BaseAPI {
  /**
   * This method will get the identity key associated with the Mailchain username.
   * @summary Identity key from blockchain address.
   * @param {string} username Username to get identity key for. This is the user name e.g. alice@mailchain.com would be alice. Usernames are case insensitive.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  getUserIdentityKey(username, options) {
    return UsersApiFp(this.configuration).getUserIdentityKey(username, options).then((request) => request(this.axios, this.basePath));
  }
  /**
   * 
   * @summary Used to check if an username exists.
   * @param {string} username Username to search for. This is the user name e.g. alice@mailchain.com would be alice. Usernames are case insensitive.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  getUsernameAvailable(username, options) {
    return UsersApiFp(this.configuration).getUsernameAvailable(username, options).then((request) => request(this.axios, this.basePath));
  }
};
var VersionApiAxiosParamCreator = function(configuration) {
  return {
    /**
     * Get version of the running mailchain client application and API. This method be used to determine what version of the API and client is being used and what functionality.
     * @summary Get version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVersion: async (options = {}) => {
      const localVarPath = `/version`;
      const localVarUrlObj = new URL(localVarPath, _chunkZFXYEUUWjs.DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {};
      const localVarQueryParameter = {};
      _chunkZFXYEUUWjs.setSearchParams.call(void 0, localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      return {
        url: _chunkZFXYEUUWjs.toPathString.call(void 0, localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};
var VersionApiFp = function(configuration) {
  const localVarAxiosParamCreator = VersionApiAxiosParamCreator(configuration);
  return {
    /**
     * Get version of the running mailchain client application and API. This method be used to determine what version of the API and client is being used and what functionality.
     * @summary Get version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getVersion(options) {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getVersion(options);
      return _chunkZFXYEUUWjs.createRequestFunction.call(void 0, localVarAxiosArgs, _axios2.default, _chunk7VCGQ36Wjs.BASE_PATH, configuration);
    }
  };
};
var VersionApiFactory = function(configuration, basePath, axios) {
  const localVarFp = VersionApiFp(configuration);
  return {
    /**
     * Get version of the running mailchain client application and API. This method be used to determine what version of the API and client is being used and what functionality.
     * @summary Get version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVersion(options) {
      return localVarFp.getVersion(options).then((request) => request(axios, basePath));
    }
  };
};
var VersionApi = class extends _chunk7VCGQ36Wjs.BaseAPI {
  /**
   * Get version of the running mailchain client application and API. This method be used to determine what version of the API and client is being used and what functionality.
   * @summary Get version
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VersionApi
   */
  getVersion(options) {
    return VersionApiFp(this.configuration).getVersion(options).then((request) => request(this.axios, this.basePath));
  }
};
























































exports.AddressEncodingEnum = AddressEncodingEnum; exports.ContractCallMethodEnum = ContractCallMethodEnum; exports.EncryptedAccountSecretEncryptionKindEnum = EncryptedAccountSecretEncryptionKindEnum; exports.EncryptedAccountSecretSecretKindEnum = EncryptedAccountSecretSecretKindEnum; exports.GetUsernameAvailableResponseBodyReasonEnum = GetUsernameAvailableResponseBodyReasonEnum; exports.ImageKindEnum = ImageKindEnum; exports.MessageKindEnum = MessageKindEnum; exports.PrivateKeyCurveEnum = PrivateKeyCurveEnum; exports.PrivateKeyEncodingEnum = PrivateKeyEncodingEnum; exports.PublicKeyCurveEnum = PublicKeyCurveEnum; exports.PublicKeyEncodingEnum = PublicKeyEncodingEnum; exports.PutEncryptedMessageRequestBodyFolderEnum = PutEncryptedMessageRequestBodyFolderEnum; exports.PutEncryptedMessageRequestBodyKindEnum = PutEncryptedMessageRequestBodyKindEnum; exports.PutUserSettingRequestBodyGroupEnum = PutUserSettingRequestBodyGroupEnum; exports.PutUserSettingRequestBodyKindEnum = PutUserSettingRequestBodyKindEnum; exports.RegisteredKeyProofSigningMethodEnum = RegisteredKeyProofSigningMethodEnum; exports.SettingGroupEnum = SettingGroupEnum; exports.SettingKindEnum = SettingKindEnum; exports.AddressesApiAxiosParamCreator = AddressesApiAxiosParamCreator; exports.AddressesApiFp = AddressesApiFp; exports.AddressesApiFactory = AddressesApiFactory; exports.AddressesApi = AddressesApi; exports.AuthApiAxiosParamCreator = AuthApiAxiosParamCreator; exports.AuthApiFp = AuthApiFp; exports.AuthApiFactory = AuthApiFactory; exports.AuthApi = AuthApi; exports.IdentityKeysApiAxiosParamCreator = IdentityKeysApiAxiosParamCreator; exports.IdentityKeysApiFp = IdentityKeysApiFp; exports.IdentityKeysApiFactory = IdentityKeysApiFactory; exports.IdentityKeysApi = IdentityKeysApi; exports.InboxApiAxiosParamCreator = InboxApiAxiosParamCreator; exports.InboxApiFp = InboxApiFp; exports.InboxApiFactory = InboxApiFactory; exports.InboxApi = InboxApi; exports.MessagingKeysApiAxiosParamCreator = MessagingKeysApiAxiosParamCreator; exports.MessagingKeysApiFp = MessagingKeysApiFp; exports.MessagingKeysApiFactory = MessagingKeysApiFactory; exports.MessagingKeysApi = MessagingKeysApi; exports.TransportApiAxiosParamCreator = TransportApiAxiosParamCreator; exports.TransportApiFp = TransportApiFp; exports.TransportApiFactory = TransportApiFactory; exports.TransportApi = TransportApi; exports.UserApiAxiosParamCreator = UserApiAxiosParamCreator; exports.UserApiFp = UserApiFp; exports.UserApiFactory = UserApiFactory; exports.UserApi = UserApi; exports.UsersApiAxiosParamCreator = UsersApiAxiosParamCreator; exports.UsersApiFp = UsersApiFp; exports.UsersApiFactory = UsersApiFactory; exports.UsersApi = UsersApi; exports.VersionApiAxiosParamCreator = VersionApiAxiosParamCreator; exports.VersionApiFp = VersionApiFp; exports.VersionApiFactory = VersionApiFactory; exports.VersionApi = VersionApi;
