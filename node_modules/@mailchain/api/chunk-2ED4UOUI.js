"use strict";Object.defineProperty(exports, "__esModule", {value: true});

var _chunk4Y7ZB3S4js = require('./chunk-4Y7ZB3S4.js');



var _chunk3R6QMA72js = require('./chunk-3R6QMA72.js');

// src/helpers/apiKeyToCryptoKey.ts





var _crypto = require('@mailchain/crypto');
var _encoding = require('@mailchain/encoding');
var _secp256r1 = require('@mailchain/crypto/secp256r1');
function convertPublic(key) {
  switch (key.curve) {
    case _chunk3R6QMA72js.PublicKeyCurveEnum.Ed25519:
      return new (0, _crypto.ED25519PublicKey)(_encoding.decode.call(void 0, key.encoding, key.value));
    case _chunk3R6QMA72js.PublicKeyCurveEnum.Secp256k1:
      return new (0, _crypto.SECP256K1PublicKey)(_encoding.decode.call(void 0, key.encoding, key.value));
    case _chunk3R6QMA72js.PublicKeyCurveEnum.Secp256r1:
      return new (0, _secp256r1.SECP256R1PublicKey)(_encoding.decode.call(void 0, key.encoding, key.value));
    default:
      throw new (0, _chunk4Y7ZB3S4js.ErrorUnsupportedKey)(key.curve);
  }
}
function convertPrivate(key) {
  switch (key.curve) {
    case _chunk3R6QMA72js.PrivateKeyCurveEnum.Ed25519:
      return _crypto.ED25519PrivateKey.fromSecretKey(_encoding.decode.call(void 0, key.encoding, key.value));
    case _chunk3R6QMA72js.PrivateKeyCurveEnum.Secp256k1:
      return new (0, _crypto.SECP256K1PrivateKey)(_encoding.decode.call(void 0, key.encoding, key.value));
    case _chunk3R6QMA72js.PrivateKeyCurveEnum.Secp256r1:
      return new (0, _secp256r1.SECP256R1PrivateKey)(_encoding.decode.call(void 0, key.encoding, key.value));
    default:
      throw new (0, _chunk4Y7ZB3S4js.ErrorUnsupportedKey)(key.curve);
  }
}




exports.convertPublic = convertPublic; exports.convertPrivate = convertPrivate;
