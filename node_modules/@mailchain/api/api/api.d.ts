import * as axios from 'axios';
import { AxiosRequestConfig, AxiosInstance, AxiosPromise } from 'axios';
import { Configuration } from './configuration.js';
import { RequestArgs, BaseAPI } from './base.js';

/**
 *
 * @export
 * @interface AccountAuthFinalizeRequestBody
 */
interface AccountAuthFinalizeRequestBody {
    /**
     *
     * @type {string}
     * @memberof AccountAuthFinalizeRequestBody
     */
    'authState': string;
    /**
     * Create a new session cookie during this request. Session cookies are used to private an key to securely store secrets by the application.
     * @type {boolean}
     * @memberof AccountAuthFinalizeRequestBody
     */
    'createSessionCookie'?: boolean;
    /**
     *
     * @type {string}
     * @memberof AccountAuthFinalizeRequestBody
     */
    'params': string;
}
/**
 *
 * @export
 * @interface AccountAuthFinalizeResponseBody
 */
interface AccountAuthFinalizeResponseBody {
    /**
     *
     * @type {EncryptedAccountSecret}
     * @memberof AccountAuthFinalizeResponseBody
     */
    'encryptedAccountSecret': EncryptedAccountSecret;
    /**
     *
     * @type {string}
     * @memberof AccountAuthFinalizeResponseBody
     */
    'session': string;
}
/**
 *
 * @export
 * @interface AccountAuthInitRequestBody
 */
interface AccountAuthInitRequestBody {
    /**
     * Response from the proof of humanity challenge. Captcha\'s are used to prevent accounts from attempting to login form suspicious requests.
     * @type {string}
     * @memberof AccountAuthInitRequestBody
     */
    'captchaResponse': string;
    /**
     *
     * @type {string}
     * @memberof AccountAuthInitRequestBody
     */
    'params': string;
    /**
     * Username to register. This is the user name e.g. alice@mailchain.com would be alice. Usernames are case insensitive.
     * @type {string}
     * @memberof AccountAuthInitRequestBody
     */
    'username': string;
}
/**
 *
 * @export
 * @interface AccountAuthInitResponseBody
 */
interface AccountAuthInitResponseBody {
    /**
     *
     * @type {string}
     * @memberof AccountAuthInitResponseBody
     */
    'authStartResponse': string;
    /**
     *
     * @type {string}
     * @memberof AccountAuthInitResponseBody
     */
    'state': string;
}
/**
 *
 * @export
 * @interface AccountRegisterCreateRequestBody
 */
interface AccountRegisterCreateRequestBody {
    /**
     * Opaque authentication initialize parameters.
     * @type {string}
     * @memberof AccountRegisterCreateRequestBody
     */
    'authInitParams': string;
    /**
     * Opaque registration finalize parameters.
     * @type {string}
     * @memberof AccountRegisterCreateRequestBody
     */
    'registerFinalizeParams': string;
    /**
     * Username to register. This is the user name e.g. alice@mailchain.com would be alice. Usernames are case insensitive.
     * @type {string}
     * @memberof AccountRegisterCreateRequestBody
     */
    'username': string;
}
/**
 *
 * @export
 * @interface AccountRegisterCreateResponseBody
 */
interface AccountRegisterCreateResponseBody {
    /**
     *
     * @type {string}
     * @memberof AccountRegisterCreateResponseBody
     */
    'authStartResponse': string;
    /**
     *
     * @type {string}
     * @memberof AccountRegisterCreateResponseBody
     */
    'state': string;
}
/**
 *
 * @export
 * @interface AccountRegisterFinalizeRequestBody
 */
interface AccountRegisterFinalizeRequestBody {
    /**
     * Opaque authentication finalize parameters.
     * @type {string}
     * @memberof AccountRegisterFinalizeRequestBody
     */
    'authFinalizeParams': string;
    /**
     * Authentication state
     * @type {string}
     * @memberof AccountRegisterFinalizeRequestBody
     */
    'authState': string;
    /**
     * EncryptedMnemonicEntropy contains mnemonic phrase converted to entropy this is encrypt by the client using opaque client secret key.
     * @type {string}
     * @memberof AccountRegisterFinalizeRequestBody
     */
    'encryptedMnemonicEntropy': string;
    /**
     *
     * @type {MessagingKey}
     * @memberof AccountRegisterFinalizeRequestBody
     */
    'messagingKey'?: MessagingKey;
    /**
     * Session generated by opaque client after login.finish is completed
     * @type {string}
     * @memberof AccountRegisterFinalizeRequestBody
     */
    'session': string;
    /**
     * Registration session provided by the server in initial registration response is signed by the account key.
     * @type {string}
     * @memberof AccountRegisterFinalizeRequestBody
     */
    'signedRegistrationSession': string;
    /**
     * Username to register. This is the user name e.g. alice@mailchain.com would be alice. Usernames are case insensitive.
     * @type {string}
     * @memberof AccountRegisterFinalizeRequestBody
     */
    'username': string;
}
/**
 *
 * @export
 * @interface AccountRegisterFinalizeResponseBody
 */
interface AccountRegisterFinalizeResponseBody {
    /**
     *
     * @type {string}
     * @memberof AccountRegisterFinalizeResponseBody
     */
    'session': string;
}
/**
 *
 * @export
 * @interface AccountRegisterInitRequestBody
 */
interface AccountRegisterInitRequestBody {
    /**
     * Response from the proof of humanity challenge. Captcha\'s are used to prevent bots from registering accounts.
     * @type {string}
     * @memberof AccountRegisterInitRequestBody
     */
    'captchaResponse': string;
    /**
     * Primary public key to identify this account. Mailchain account keys are always based on the ed25519 elliptic curve.
     * @type {string}
     * @memberof AccountRegisterInitRequestBody
     */
    'identityKey': string;
    /**
     * Opaque registration request parameters.
     * @type {string}
     * @memberof AccountRegisterInitRequestBody
     */
    'registerInitParams': string;
    /**
     * Signature for registering reserved names
     * @type {string}
     * @memberof AccountRegisterInitRequestBody
     */
    'reservedNameSignature'?: string;
    /**
     * Signature proves the link between the account and identity key.
     * @type {string}
     * @memberof AccountRegisterInitRequestBody
     */
    'signature': string;
    /**
     * Username to register. This is the user name e.g. alice@mailchain.com would be alice. Usernames are case insensitive.
     * @type {string}
     * @memberof AccountRegisterInitRequestBody
     */
    'username': string;
}
/**
 *
 * @export
 * @interface AccountRegisterInitResponseBody
 */
interface AccountRegisterInitResponseBody {
    /**
     *
     * @type {string}
     * @memberof AccountRegisterInitResponseBody
     */
    'registrationResponse': string;
    /**
     * RegistrationSession is random set of bytes that is used to identify the registration session. This must be signed with the idenitity key and sent back to the server to finalize the registration. The resigsration session is used to prevent replay attacks and ensure that account is not changed later in the process.
     * @type {string}
     * @memberof AccountRegisterInitResponseBody
     */
    'registrationSession': string;
}
/**
 *
 * @export
 * @interface Address
 */
interface Address {
    /**
     * Encoding used to read address bytes
     * @type {string}
     * @memberof Address
     */
    'encoding': AddressEncodingEnum;
    /**
     * Network
     * @type {string}
     * @memberof Address
     */
    'network': string;
    /**
     * Protocol
     * @type {string}
     * @memberof Address
     */
    'protocol': string;
    /**
     * Encoded address bytes.
     * @type {string}
     * @memberof Address
     */
    'value': string;
}
declare const AddressEncodingEnum: {
    readonly Hex0xPrefix: "hex/0x-prefix";
    readonly HexPlain: "hex/plain";
    readonly TextUtf8: "text/utf-8";
    readonly Base58Plain: "base58/plain";
};
type AddressEncodingEnum = typeof AddressEncodingEnum[keyof typeof AddressEncodingEnum];
/**
 *
 * @export
 * @interface ContractCall
 */
interface ContractCall {
    /**
     *
     * @type {string}
     * @memberof ContractCall
     */
    'address': string;
    /**
     *
     * @type {string}
     * @memberof ContractCall
     */
    'body': string;
    /**
     *
     * @type {string}
     * @memberof ContractCall
     */
    'endpoint': string;
    /**
     * HTTP method used to call the contract, e.g. POST
     * @type {string}
     * @memberof ContractCall
     */
    'method': ContractCallMethodEnum;
    /**
     * Path of the end point
     * @type {string}
     * @memberof ContractCall
     */
    'path': string;
    /**
     *
     * @type {string}
     * @memberof ContractCall
     */
    'protocol': string;
}
declare const ContractCallMethodEnum: {
    readonly Post: "POST";
    readonly Get: "GET";
};
type ContractCallMethodEnum = typeof ContractCallMethodEnum[keyof typeof ContractCallMethodEnum];
/**
 *
 * @export
 * @interface DeliveryRequest
 */
interface DeliveryRequest {
    /**
     *
     * @type {string}
     * @memberof DeliveryRequest
     */
    'data': string;
    /**
     * Hash of delivery request that can be used to validate request
     * @type {string}
     * @memberof DeliveryRequest
     */
    'hash': string;
}
/**
 *
 * @export
 * @interface EncryptedAccountSecret
 */
interface EncryptedAccountSecret {
    /**
     * Encrypted account secret. Either entropy to create a mnemonic phrase or seed. Type of secret is indicated by `secretKind` field.
     * @type {string}
     * @memberof EncryptedAccountSecret
     */
    'encryptedAccountSecret': string;
    /**
     * Encryption type that was used to encrypt the account key
     * @type {string}
     * @memberof EncryptedAccountSecret
     */
    'encryptionKind': EncryptedAccountSecretEncryptionKindEnum;
    /**
     * What version of the encryption type was used. Versioning allows for backward compatablity.
     * @type {number}
     * @memberof EncryptedAccountSecret
     */
    'encryptionVersion': number;
    /**
     * Identifier to distinguish between different type of encrypted secrets.
     * @type {string}
     * @memberof EncryptedAccountSecret
     */
    'secretKind': EncryptedAccountSecretSecretKindEnum;
}
declare const EncryptedAccountSecretEncryptionKindEnum: {
    readonly Opaque: "opaque";
    readonly Metamask: "metamask";
};
type EncryptedAccountSecretEncryptionKindEnum = typeof EncryptedAccountSecretEncryptionKindEnum[keyof typeof EncryptedAccountSecretEncryptionKindEnum];
declare const EncryptedAccountSecretSecretKindEnum: {
    readonly Account: "account";
    readonly Mnemonic: "mnemonic";
};
type EncryptedAccountSecretSecretKindEnum = typeof EncryptedAccountSecretSecretKindEnum[keyof typeof EncryptedAccountSecretSecretKindEnum];
/**
 *
 * @export
 * @interface GetAddressMessagingKeyResponseBody
 */
interface GetAddressMessagingKeyResponseBody {
    /**
     *
     * @type {ContractCall}
     * @memberof GetAddressMessagingKeyResponseBody
     */
    'contractCall': ContractCall;
    /**
     *
     * @type {string}
     * @memberof GetAddressMessagingKeyResponseBody
     */
    'domainPart': string;
    /**
     *
     * @type {string}
     * @memberof GetAddressMessagingKeyResponseBody
     */
    'fullAddress': string;
    /**
     *
     * @type {PublicKey}
     * @memberof GetAddressMessagingKeyResponseBody
     */
    'identityKey'?: PublicKey;
    /**
     *
     * @type {string}
     * @memberof GetAddressMessagingKeyResponseBody
     */
    'localPart': string;
    /**
     *
     * @type {PublicKey}
     * @memberof GetAddressMessagingKeyResponseBody
     */
    'messagingKey': PublicKey;
    /**
     *
     * @type {string}
     * @memberof GetAddressMessagingKeyResponseBody
     */
    'protocol': string;
    /**
     *
     * @type {ProvidedKeyProof}
     * @memberof GetAddressMessagingKeyResponseBody
     */
    'providedKeyProof'?: ProvidedKeyProof;
    /**
     *
     * @type {RegisteredKeyProof}
     * @memberof GetAddressMessagingKeyResponseBody
     */
    'registeredKeyProof'?: RegisteredKeyProof;
    /**
     *
     * @type {string}
     * @memberof GetAddressMessagingKeyResponseBody
     */
    'rootDomain': string;
}
/**
 *
 * @export
 * @interface GetDeliveryRequestsResponseBody
 */
interface GetDeliveryRequestsResponseBody {
    /**
     * List of delivery requests
     * @type {Array<DeliveryRequest>}
     * @memberof GetDeliveryRequestsResponseBody
     */
    'deliveryRequests': Array<DeliveryRequest>;
}
/**
 *
 * @export
 * @interface GetIdentityKeyAddressesResponseBody
 */
interface GetIdentityKeyAddressesResponseBody {
    /**
     * Addresses that have been vended for the identity key.
     * @type {Array<Address>}
     * @memberof GetIdentityKeyAddressesResponseBody
     */
    'addresses': Array<Address>;
}
/**
 *
 * @export
 * @interface GetIdentityKeyNonceResponseBody
 */
interface GetIdentityKeyNonceResponseBody {
    /**
     *
     * @type {number}
     * @memberof GetIdentityKeyNonceResponseBody
     */
    'nonce': number;
}
/**
 *
 * @export
 * @interface GetIdentityKeyResolvableNamesResponseBody
 */
interface GetIdentityKeyResolvableNamesResponseBody {
    /**
     *
     * @type {Array<ResolvableName>}
     * @memberof GetIdentityKeyResolvableNamesResponseBody
     */
    'resolvableNames'?: Array<ResolvableName>;
}
/**
 *
 * @export
 * @interface GetIdentityKeyResponseBody
 */
interface GetIdentityKeyResponseBody {
    /**
     * Identity key in descriptive public key format.
     * @type {string}
     * @memberof GetIdentityKeyResponseBody
     */
    'identityKey': string;
    /**
     * Protocol this key was found on.
     * @type {string}
     * @memberof GetIdentityKeyResponseBody
     */
    'protocol': string;
}
/**
 *
 * @export
 * @interface GetLabelOverviewResponseBody
 */
interface GetLabelOverviewResponseBody {
    /**
     *
     * @type {string}
     * @memberof GetLabelOverviewResponseBody
     */
    'label': string;
    /**
     *
     * @type {number}
     * @memberof GetLabelOverviewResponseBody
     */
    'total': number;
    /**
     *
     * @type {number}
     * @memberof GetLabelOverviewResponseBody
     */
    'unread': number;
}
/**
 *
 * @export
 * @interface GetMailboxItemResponseBody
 */
interface GetMailboxItemResponseBody {
    /**
     *
     * @type {Array<GetLabelOverviewResponseBody>}
     * @memberof GetMailboxItemResponseBody
     */
    'labels': Array<GetLabelOverviewResponseBody>;
    /**
     *
     * @type {string}
     * @memberof GetMailboxItemResponseBody
     */
    'mailbox': string;
}
/**
 *
 * @export
 * @interface GetMailboxOverviewResponseBody
 */
interface GetMailboxOverviewResponseBody {
    /**
     *
     * @type {Array<GetMailboxItemResponseBody>}
     * @memberof GetMailboxOverviewResponseBody
     */
    'mailboxes': Array<GetMailboxItemResponseBody>;
}
/**
 *
 * @export
 * @interface GetMailchainPublicKeyResponseBody
 */
interface GetMailchainPublicKeyResponseBody {
    /**
     *
     * @type {PublicKey}
     * @memberof GetMailchainPublicKeyResponseBody
     */
    'key': PublicKey;
}
/**
 *
 * @export
 * @interface GetMessageResponseBody
 */
interface GetMessageResponseBody {
    /**
     *
     * @type {Message}
     * @memberof GetMessageResponseBody
     */
    'message': Message;
}
/**
 *
 * @export
 * @interface GetMessagesInViewResponseBody
 */
interface GetMessagesInViewResponseBody {
    /**
     *
     * @type {Array<Message>}
     * @memberof GetMessagesInViewResponseBody
     */
    'messages': Array<Message>;
}
/**
 *
 * @export
 * @interface GetMessagingKeyResponseBody
 */
interface GetMessagingKeyResponseBody {
    /**
     *
     * @type {PublicKey}
     * @memberof GetMessagingKeyResponseBody
     */
    'messagingKey': PublicKey;
    /**
     *
     * @type {ProvidedKeyProof}
     * @memberof GetMessagingKeyResponseBody
     */
    'proof': ProvidedKeyProof;
}
/**
 *
 * @export
 * @interface GetMsgKeyResponseBody
 */
interface GetMsgKeyResponseBody {
    /**
     *
     * @type {PublicKey}
     * @memberof GetMsgKeyResponseBody
     */
    'messagingKey': PublicKey;
    /**
     *
     * @type {RegisteredKeyProof}
     * @memberof GetMsgKeyResponseBody
     */
    'proof': RegisteredKeyProof;
}
/**
 *
 * @export
 * @interface GetProtocolAddressNonceResponseBody
 */
interface GetProtocolAddressNonceResponseBody {
    /**
     *
     * @type {ContractCall}
     * @memberof GetProtocolAddressNonceResponseBody
     */
    'contractCall': ContractCall;
}
/**
 *
 * @export
 * @interface GetSessionCookieResponseBody
 */
interface GetSessionCookieResponseBody {
    /**
     * Used by the client to encrypt contents locally.
     * @type {string}
     * @memberof GetSessionCookieResponseBody
     */
    'localStorageSessionKey': string;
}
/**
 *
 * @export
 * @interface GetStatusResponseBody
 */
interface GetStatusResponseBody {
    /**
     *
     * @type {string}
     * @memberof GetStatusResponseBody
     */
    'status': string;
}
/**
 *
 * @export
 * @interface GetUserIdentityKeyResponseBody
 */
interface GetUserIdentityKeyResponseBody {
    /**
     * Identity key in descriptive public key format.
     * @type {string}
     * @memberof GetUserIdentityKeyResponseBody
     */
    'identityKey'?: string;
    /**
     * Proof of the username represents the identity key.
     * @type {string}
     * @memberof GetUserIdentityKeyResponseBody
     */
    'proof'?: string;
}
/**
 *
 * @export
 * @interface GetUserMailboxesResponseBody
 */
interface GetUserMailboxesResponseBody {
    /**
     *
     * @type {Array<MailboxItem>}
     * @memberof GetUserMailboxesResponseBody
     */
    'mailboxes': Array<MailboxItem>;
}
/**
 *
 * @export
 * @interface GetUserSettingsResponseBody
 */
interface GetUserSettingsResponseBody {
    /**
     *
     * @type {Array<Setting>}
     * @memberof GetUserSettingsResponseBody
     */
    'settings': Array<Setting>;
}
/**
 *
 * @export
 * @interface GetUsernameAvailableResponseBody
 */
interface GetUsernameAvailableResponseBody {
    /**
     *
     * @type {boolean}
     * @memberof GetUsernameAvailableResponseBody
     */
    'isAvailable': boolean;
    /**
     *
     * @type {string}
     * @memberof GetUsernameAvailableResponseBody
     */
    'reason': GetUsernameAvailableResponseBodyReasonEnum;
}
declare const GetUsernameAvailableResponseBodyReasonEnum: {
    readonly Reserved: "reserved";
    readonly Invalid: "invalid";
    readonly Taken: "taken";
    readonly Available: "available";
    readonly Unavailable: "unavailable";
};
type GetUsernameAvailableResponseBodyReasonEnum = typeof GetUsernameAvailableResponseBodyReasonEnum[keyof typeof GetUsernameAvailableResponseBodyReasonEnum];
/**
 *
 * @export
 * @interface GetUsernameResponseBody
 */
interface GetUsernameResponseBody {
    /**
     * Mailchain address
     * @type {string}
     * @memberof GetUsernameResponseBody
     */
    'address': string;
    /**
     * Username
     * @type {string}
     * @memberof GetUsernameResponseBody
     */
    'username': string;
}
/**
 *
 * @export
 * @interface GetVendedPrivateMessagingKeyResponseBody
 */
interface GetVendedPrivateMessagingKeyResponseBody {
    /**
     *
     * @type {Address}
     * @memberof GetVendedPrivateMessagingKeyResponseBody
     */
    'address': Address;
    /**
     *
     * @type {PrivateKey}
     * @memberof GetVendedPrivateMessagingKeyResponseBody
     */
    'privateKey': PrivateKey;
}
/**
 * GetVersionResponseBody response
 * @export
 * @interface GetVersionResponseBody
 */
interface GetVersionResponseBody {
    /**
     * The resolved version commit
     * @type {string}
     * @memberof GetVersionResponseBody
     */
    'commit': string;
    /**
     * The resolved version release date
     * @type {string}
     * @memberof GetVersionResponseBody
     */
    'time': string;
}
/**
 *
 * @export
 * @interface Image
 */
interface Image {
    /**
     *
     * @type {string}
     * @memberof Image
     */
    'kind': ImageKindEnum;
    /**
     *
     * @type {Token}
     * @memberof Image
     */
    'token'?: Token;
    /**
     *
     * @type {string}
     * @memberof Image
     */
    'url': string;
}
declare const ImageKindEnum: {
    readonly Image: "image";
    readonly Token: "token";
};
type ImageKindEnum = typeof ImageKindEnum[keyof typeof ImageKindEnum];
/**
 *
 * @export
 * @interface MailboxItem
 */
interface MailboxItem {
    /**
     *
     * @type {string}
     * @memberof MailboxItem
     */
    'encryptedMailboxInformation': string;
    /**
     * ID of the mailbox to update, plain hex encoded.
     * @type {string}
     * @memberof MailboxItem
     */
    'mailboxId': string;
    /**
     *
     * @type {number}
     * @memberof MailboxItem
     */
    'version': number;
}
/**
 *
 * @export
 * @interface Message
 */
interface Message {
    /**
     * Encrypted preview of message base 64 encoded
     * @type {string}
     * @memberof Message
     */
    'encryptedPreview': string;
    /**
     * Kind of the message being retrieved.
     * @type {string}
     * @memberof Message
     */
    'kind': MessageKindEnum;
    /**
     * Message body resource id
     * @type {string}
     * @memberof Message
     */
    'messageBodyResourceId': string;
    /**
     * Unique identifier of the message. This used to perform actions on the message. Plain hex encoded string.
     * @type {string}
     * @memberof Message
     */
    'messageId': string;
    /**
     * Where message has been starred by the user
     * @type {boolean}
     * @memberof Message
     */
    'starred': boolean;
    /**
     * Mailchain labels
     * @type {Array<string>}
     * @memberof Message
     */
    'systemLabels': Array<string>;
    /**
     * Where message has been read by the user
     * @type {boolean}
     * @memberof Message
     */
    'unread': boolean;
    /**
     *
     * @type {number}
     * @memberof Message
     */
    'version': number;
}
declare const MessageKindEnum: {
    readonly Mail: "mail";
    readonly VcRequest: "vc-request";
};
type MessageKindEnum = typeof MessageKindEnum[keyof typeof MessageKindEnum];
/**
 *
 * @export
 * @interface MessagingKey
 */
interface MessagingKey {
    /**
     * Messaging key to use for this account.
     * @type {string}
     * @memberof MessagingKey
     */
    'key'?: string;
    /**
     * Signature that proves the messaging key is valid
     * @type {string}
     * @memberof MessagingKey
     */
    'signature'?: string;
}
/**
 *
 * @export
 * @interface Metadata
 */
interface Metadata {
    /**
     *
     * @type {string}
     * @memberof Metadata
     */
    'address': string;
    /**
     *
     * @type {Image}
     * @memberof Metadata
     */
    'image': Image;
    /**
     *
     * @type {string}
     * @memberof Metadata
     */
    'name'?: string;
}
/**
 *
 * @export
 * @interface PasswordResetCreateRequestBody
 */
interface PasswordResetCreateRequestBody {
    /**
     * Opaque authentication initialize parameters.
     * @type {string}
     * @memberof PasswordResetCreateRequestBody
     */
    'authInitParams': string;
    /**
     * Opaque registration finalize parameters.
     * @type {string}
     * @memberof PasswordResetCreateRequestBody
     */
    'registerFinalizeParams': string;
    /**
     * Username to reset password. This is the user name e.g. alice@mailchain.com would be alice. Usernames are case insensitive.
     * @type {string}
     * @memberof PasswordResetCreateRequestBody
     */
    'username': string;
}
/**
 *
 * @export
 * @interface PasswordResetCreateResponseBody
 */
interface PasswordResetCreateResponseBody {
    /**
     *
     * @type {string}
     * @memberof PasswordResetCreateResponseBody
     */
    'authStartResponse': string;
    /**
     *
     * @type {string}
     * @memberof PasswordResetCreateResponseBody
     */
    'state': string;
}
/**
 *
 * @export
 * @interface PasswordResetFinalizeRequestBody
 */
interface PasswordResetFinalizeRequestBody {
    /**
     * Opaque authentication finalize parameters.
     * @type {string}
     * @memberof PasswordResetFinalizeRequestBody
     */
    'authFinalizeParams': string;
    /**
     * Authentication state
     * @type {string}
     * @memberof PasswordResetFinalizeRequestBody
     */
    'authState': string;
    /**
     * EncryptedMnemonicEntropy contains mnemonic phrase converted to entropy this is encrypt by the client using opaque client secret key.
     * @type {string}
     * @memberof PasswordResetFinalizeRequestBody
     */
    'encryptedMnemonicEntropy': string;
    /**
     * Session generated by opaque client after login.finish is completed
     * @type {string}
     * @memberof PasswordResetFinalizeRequestBody
     */
    'session': string;
    /**
     * Reset session provided by the server in initial reset response is signed by the account key.
     * @type {string}
     * @memberof PasswordResetFinalizeRequestBody
     */
    'signedResetSession': string;
    /**
     * Username to reset. This is the user name e.g. alice@mailchain.com would be alice. Usernames are case insensitive.
     * @type {string}
     * @memberof PasswordResetFinalizeRequestBody
     */
    'username': string;
}
/**
 *
 * @export
 * @interface PasswordResetFinalizeResponseBody
 */
interface PasswordResetFinalizeResponseBody {
    /**
     *
     * @type {string}
     * @memberof PasswordResetFinalizeResponseBody
     */
    'session': string;
}
/**
 *
 * @export
 * @interface PasswordResetInitRequestBody
 */
interface PasswordResetInitRequestBody {
    /**
     * Response from the proof of humanity challenge. Captcha\'s are used to prevent bots from resetting passwords.
     * @type {string}
     * @memberof PasswordResetInitRequestBody
     */
    'captchaResponse': string;
    /**
     * Expires is the time the registration request expires.
     * @type {number}
     * @memberof PasswordResetInitRequestBody
     */
    'expires': number;
    /**
     * Primary public key to identify this account. Mailchain account keys are always based on the ed25519 elliptic curve.
     * @type {string}
     * @memberof PasswordResetInitRequestBody
     */
    'identityKey': string;
    /**
     * Opaque registration request parameters.
     * @type {string}
     * @memberof PasswordResetInitRequestBody
     */
    'registerInitParams': string;
    /**
     * Signature proves the link between the account and identity key.
     * @type {string}
     * @memberof PasswordResetInitRequestBody
     */
    'signature': string;
    /**
     * Username to reset password. This is the user name e.g. alice@mailchain.com would be alice. Usernames are case insensitive.
     * @type {string}
     * @memberof PasswordResetInitRequestBody
     */
    'username': string;
}
/**
 *
 * @export
 * @interface PasswordResetInitResponseBody
 */
interface PasswordResetInitResponseBody {
    /**
     *
     * @type {string}
     * @memberof PasswordResetInitResponseBody
     */
    'registrationResponse': string;
    /**
     * resetSession is random set of bytes that is used to identify the registration session. This must be signed with the identity key and sent back to the server to finalize the registration. The registration session is used to prevent replay attacks and ensure that account is not changed later in the process.
     * @type {string}
     * @memberof PasswordResetInitResponseBody
     */
    'resetSession': string;
}
/**
 *
 * @export
 * @interface PostDeliveryRequestRequestBody
 */
interface PostDeliveryRequestRequestBody {
    /**
     * Encrypted delivery request that contains the complete delivery request encrypted by the sender.
     * @type {string}
     * @memberof PostDeliveryRequestRequestBody
     */
    'encryptedDeliveryRequest': string;
    /**
     * Destination messaging key
     * @type {string}
     * @memberof PostDeliveryRequestRequestBody
     */
    'recipientMessagingKey': string;
}
/**
 *
 * @export
 * @interface PostDeliveryRequestResponseBody
 */
interface PostDeliveryRequestResponseBody {
    /**
     * Delivery request id. Used to look up delivery request status.
     * @type {string}
     * @memberof PostDeliveryRequestResponseBody
     */
    'deliveryRequestID': string;
}
/**
 *
 * @export
 * @interface PostPayloadResponseBody
 */
interface PostPayloadResponseBody {
    /**
     * Resource ID
     * @type {string}
     * @memberof PostPayloadResponseBody
     */
    'resourceId': string;
    /**
     * Where the response body is located
     * @type {string}
     * @memberof PostPayloadResponseBody
     */
    'uri': string;
}
/**
 *
 * @export
 * @interface PostUserMailboxRequestBody
 */
interface PostUserMailboxRequestBody {
    /**
     *
     * @type {string}
     * @memberof PostUserMailboxRequestBody
     */
    'encryptedMailboxInformation': string;
    /**
     *
     * @type {number}
     * @memberof PostUserMailboxRequestBody
     */
    'version': number;
}
/**
 *
 * @export
 * @interface PostUserMailboxResponseBody
 */
interface PostUserMailboxResponseBody {
    /**
     * Mailbox ID plain hex encoded.
     * @type {string}
     * @memberof PostUserMailboxResponseBody
     */
    'mailboxId': string;
}
/**
 *
 * @export
 * @interface PrivateKey
 */
interface PrivateKey {
    /**
     * Curve of private key
     * @type {string}
     * @memberof PrivateKey
     */
    'curve': PrivateKeyCurveEnum;
    /**
     * Encoding used to read private key bytes
     * @type {string}
     * @memberof PrivateKey
     */
    'encoding': PrivateKeyEncodingEnum;
    /**
     * Private key bytes encoded as specified by encoding field
     * @type {string}
     * @memberof PrivateKey
     */
    'value': string;
}
declare const PrivateKeyCurveEnum: {
    readonly Secp256k1: "secp256k1";
    readonly Ed25519: "ed25519";
    readonly Secp256r1: "secp256r1";
};
type PrivateKeyCurveEnum = typeof PrivateKeyCurveEnum[keyof typeof PrivateKeyCurveEnum];
declare const PrivateKeyEncodingEnum: {
    readonly _0xPrefix: "hex/0x-prefix";
    readonly Plain: "hex/plain";
};
type PrivateKeyEncodingEnum = typeof PrivateKeyEncodingEnum[keyof typeof PrivateKeyEncodingEnum];
/**
 *
 * @export
 * @interface ProvidedKeyProof
 */
interface ProvidedKeyProof {
    /**
     *
     * @type {string}
     * @memberof ProvidedKeyProof
     */
    'address'?: string;
    /**
     *
     * @type {string}
     * @memberof ProvidedKeyProof
     */
    'protocol'?: string;
    /**
     * Signature proving Mailchain provided the messaging key.
     * @type {string}
     * @memberof ProvidedKeyProof
     */
    'signature'?: string;
}
/**
 *
 * @export
 * @interface PublicKey
 */
interface PublicKey {
    /**
     * Curve of public key
     * @type {string}
     * @memberof PublicKey
     */
    'curve': PublicKeyCurveEnum;
    /**
     * Encoding used to read public key bytes
     * @type {string}
     * @memberof PublicKey
     */
    'encoding': PublicKeyEncodingEnum;
    /**
     * Public key bytes encoded as specified by encoding field
     * @type {string}
     * @memberof PublicKey
     */
    'value': string;
}
declare const PublicKeyCurveEnum: {
    readonly Secp256k1: "secp256k1";
    readonly Ed25519: "ed25519";
    readonly Secp256r1: "secp256r1";
};
type PublicKeyCurveEnum = typeof PublicKeyCurveEnum[keyof typeof PublicKeyCurveEnum];
declare const PublicKeyEncodingEnum: {
    readonly _0xPrefix: "hex/0x-prefix";
    readonly Plain: "hex/plain";
};
type PublicKeyEncodingEnum = typeof PublicKeyEncodingEnum[keyof typeof PublicKeyEncodingEnum];
/**
 *
 * @export
 * @interface PutDeliveryRequestConfirmationRequestBody
 */
interface PutDeliveryRequestConfirmationRequestBody {
    /**
     * Signature proving address proof is valid. Hex encoded
     * @type {string}
     * @memberof PutDeliveryRequestConfirmationRequestBody
     */
    'signature': string;
}
/**
 *
 * @export
 * @interface PutEncryptedMessageRequestBody
 */
interface PutEncryptedMessageRequestBody {
    /**
     * Date is not directly stored but rather an offset from the time of the message. The offset is derived from the users key ring making it unique and only knowable to the user.
     * @type {number}
     * @memberof PutEncryptedMessageRequestBody
     */
    'date': number;
    /**
     * Encrypted preview contains a summary of the message to support list views. User\'s client must encrypt the preview with their inbox private key.
     * @type {string}
     * @memberof PutEncryptedMessageRequestBody
     */
    'encryptedPreview': string;
    /**
     * Destination folder
     * @type {string}
     * @memberof PutEncryptedMessageRequestBody
     */
    'folder': PutEncryptedMessageRequestBodyFolderEnum;
    /**
     * Hashed messaging key of BCC recipient(s). User\'s client must hash each recipient identity key, address protocol, and their inbox public key. This will create a deterministic value that can be used for filtering but does not reveal who the message was sent to.
     * @type {Array<Array<number>>}
     * @memberof PutEncryptedMessageRequestBody
     */
    'hashedBcc'?: Array<Array<number>>;
    /**
     * Hashed messaging key of CC recipient(s). User\'s client must hash each recipient identity key, address protocol, and their inbox public key. This will create a deterministic value that can be used for filtering but does not reveal who the message was sent to.
     * @type {Array<Array<number>>}
     * @memberof PutEncryptedMessageRequestBody
     */
    'hashedCc'?: Array<Array<number>>;
    /**
     * Hashed messaging key of the sender. User\'s client must hash the sender identity key, address protocol, and their inbox public key. This will create a deterministic value that can be used for filtering but does not reveal the sender.
     * @type {Array<number>}
     * @memberof PutEncryptedMessageRequestBody
     */
    'hashedFrom': Array<number>;
    /**
     * Hashed owner of the mailbox message. User\'s client must hash the owner of the message. This distinguishes what address in the mailbox this message belongs to. This will create a deterministic value that can be used for filtering but does not reveal the sender.
     * @type {Array<number>}
     * @memberof PutEncryptedMessageRequestBody
     */
    'hashedOwner': Array<number>;
    /**
     * Hashed messaging key of each recipient. User\'s client must hash each recipient identity key, address protocol, and their inbox public key. This will create a deterministic value that can be used for filtering but does not reveal who the message was sent to.
     * @type {Array<Array<number>>}
     * @memberof PutEncryptedMessageRequestBody
     */
    'hashedTo': Array<Array<number>>;
    /**
     * Kind of the message being stored.
     * @type {string}
     * @memberof PutEncryptedMessageRequestBody
     */
    'kind': PutEncryptedMessageRequestBodyKindEnum;
    /**
     * Encrypted mailbox of the message. User\'s Mailbox public key is hashed before being sent.
     * @type {Array<number>}
     * @memberof PutEncryptedMessageRequestBody
     */
    'mailbox': Array<number>;
    /**
     * Resource ID of where message body is saved. This is only used when storing messages in the Mailchain inbox.
     * @type {string}
     * @memberof PutEncryptedMessageRequestBody
     */
    'messageBodyResourceId'?: string;
    /**
     *
     * @type {number}
     * @memberof PutEncryptedMessageRequestBody
     */
    'version': number;
}
declare const PutEncryptedMessageRequestBodyFolderEnum: {
    readonly Outbox: "outbox";
    readonly Inbox: "inbox";
};
type PutEncryptedMessageRequestBodyFolderEnum = typeof PutEncryptedMessageRequestBodyFolderEnum[keyof typeof PutEncryptedMessageRequestBodyFolderEnum];
declare const PutEncryptedMessageRequestBodyKindEnum: {
    readonly Mail: "mail";
    readonly VcRequest: "vc-request";
};
type PutEncryptedMessageRequestBodyKindEnum = typeof PutEncryptedMessageRequestBodyKindEnum[keyof typeof PutEncryptedMessageRequestBodyKindEnum];
/**
 *
 * @export
 * @interface PutMsgKeyByIDKeyRequestBody
 */
interface PutMsgKeyByIDKeyRequestBody {
    /**
     *
     * @type {Address}
     * @memberof PutMsgKeyByIDKeyRequestBody
     */
    'address': Address;
    /**
     * Registration message locale
     * @type {string}
     * @memberof PutMsgKeyByIDKeyRequestBody
     */
    'locale': string;
    /**
     * Message for to indicate what message format was used to sign the message.
     * @type {string}
     * @memberof PutMsgKeyByIDKeyRequestBody
     */
    'messageVariant': string;
    /**
     *
     * @type {PublicKey}
     * @memberof PutMsgKeyByIDKeyRequestBody
     */
    'messagingKey': PublicKey;
    /**
     * Nonce to confirm this is the most update proof and prevent replay attacks.
     * @type {number}
     * @memberof PutMsgKeyByIDKeyRequestBody
     */
    'nonce': number;
    /**
     * Signature proving address proof is valid. Hex encoded with 0x prefix
     * @type {string}
     * @memberof PutMsgKeyByIDKeyRequestBody
     */
    'signature': string;
    /**
     * What method was used to create the signature
     * @type {string}
     * @memberof PutMsgKeyByIDKeyRequestBody
     */
    'signatureMethod': string;
}
/**
 *
 * @export
 * @interface PutUserMailboxRequestBody
 */
interface PutUserMailboxRequestBody {
    /**
     *
     * @type {string}
     * @memberof PutUserMailboxRequestBody
     */
    'encryptedMailboxInformation': string;
    /**
     *
     * @type {number}
     * @memberof PutUserMailboxRequestBody
     */
    'version': number;
}
/**
 *
 * @export
 * @interface PutUserSettingRequestBody
 */
interface PutUserSettingRequestBody {
    /**
     * Group of setting.
     * @type {string}
     * @memberof PutUserSettingRequestBody
     */
    'group'?: PutUserSettingRequestBodyGroupEnum;
    /**
     * Kind of setting.
     * @type {string}
     * @memberof PutUserSettingRequestBody
     */
    'kind'?: PutUserSettingRequestBodyKindEnum;
    /**
     * Setting
     * @type {string}
     * @memberof PutUserSettingRequestBody
     */
    'value'?: string;
}
declare const PutUserSettingRequestBodyGroupEnum: {
    readonly Generic: "generic";
    readonly UserRules: "user-rules";
};
type PutUserSettingRequestBodyGroupEnum = typeof PutUserSettingRequestBodyGroupEnum[keyof typeof PutUserSettingRequestBodyGroupEnum];
declare const PutUserSettingRequestBodyKindEnum: {
    readonly String: "string";
    readonly Bool: "bool";
    readonly Encrypted: "encrypted";
};
type PutUserSettingRequestBodyKindEnum = typeof PutUserSettingRequestBodyKindEnum[keyof typeof PutUserSettingRequestBodyKindEnum];
/**
 *
 * @export
 * @interface RegisteredKeyProof
 */
interface RegisteredKeyProof {
    /**
     *
     * @type {Address}
     * @memberof RegisteredKeyProof
     */
    'address': Address;
    /**
     *
     * @type {PublicKey}
     * @memberof RegisteredKeyProof
     */
    'identityKey': PublicKey;
    /**
     *
     * @type {string}
     * @memberof RegisteredKeyProof
     */
    'locale': string;
    /**
     *
     * @type {string}
     * @memberof RegisteredKeyProof
     */
    'messagingKeyEncoding': string;
    /**
     *
     * @type {number}
     * @memberof RegisteredKeyProof
     */
    'nonce': number;
    /**
     * Signature that was signed by the identity key
     * @type {string}
     * @memberof RegisteredKeyProof
     */
    'signature': string;
    /**
     * Signing method used
     * @type {string}
     * @memberof RegisteredKeyProof
     */
    'signingMethod': RegisteredKeyProofSigningMethodEnum;
    /**
     *
     * @type {string}
     * @memberof RegisteredKeyProof
     */
    'variant': string;
}
declare const RegisteredKeyProofSigningMethodEnum: {
    readonly EthereumPersonalMessage: "ethereum_personal_message";
    readonly RawEd25519: "raw_ed25519";
    readonly TezosSignedMessageMicheline: "tezos_signed_message_micheline";
};
type RegisteredKeyProofSigningMethodEnum = typeof RegisteredKeyProofSigningMethodEnum[keyof typeof RegisteredKeyProofSigningMethodEnum];
/**
 *
 * @export
 * @interface ResolvableName
 */
interface ResolvableName {
    /**
     * Full address that can be resolved
     * @type {string}
     * @memberof ResolvableName
     */
    'fullAddress': string;
    /**
     * Kind of name that can be resolved, it can be token or name
     * @type {string}
     * @memberof ResolvableName
     */
    'kind': string;
    /**
     * Contains metadata if exists
     * @type {object}
     * @memberof ResolvableName
     */
    'metadata'?: object;
    /**
     * Name that can be resolved
     * @type {string}
     * @memberof ResolvableName
     */
    'name': string;
    /**
     * Resolver used to resolve name
     * @type {string}
     * @memberof ResolvableName
     */
    'resolver': string;
}
/**
 *
 * @export
 * @interface Setting
 */
interface Setting {
    /**
     * Group of the setting.
     * @type {string}
     * @memberof Setting
     */
    'group': SettingGroupEnum;
    /**
     *
     * @type {boolean}
     * @memberof Setting
     */
    'isSet': boolean;
    /**
     * Kind of setting.
     * @type {string}
     * @memberof Setting
     */
    'kind': SettingKindEnum;
    /**
     * ID of the setting.
     * @type {string}
     * @memberof Setting
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof Setting
     */
    'value'?: string;
}
declare const SettingGroupEnum: {
    readonly Generic: "generic";
    readonly UserRules: "user-rules";
};
type SettingGroupEnum = typeof SettingGroupEnum[keyof typeof SettingGroupEnum];
declare const SettingKindEnum: {
    readonly String: "string";
    readonly Encrypted: "encrypted";
};
type SettingKindEnum = typeof SettingKindEnum[keyof typeof SettingKindEnum];
/**
 *
 * @export
 * @interface Token
 */
interface Token {
    /**
     *
     * @type {string}
     * @memberof Token
     */
    'contractAddress': string;
    /**
     *
     * @type {string}
     * @memberof Token
     */
    'referenceUrl'?: string;
    /**
     *
     * @type {string}
     * @memberof Token
     */
    'tokenId': string;
}
/**
 * AddressesApi - axios parameter creator
 * @export
 */
declare const AddressesApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *
     * @summary Get identity for an address.
     * @param {string} address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
     * @param {number} [at] The time to query the messaging key at.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAddressIdentityKey: (address: string, at?: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get messaging key for an address.
     * @param {string} address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
     * @param {number} [at] The time to query the messaging key at.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAddressMessagingKey: (address: string, at?: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get status for messaging key for an address.
     * @param {string} address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
     * @param {number} [at] The time to query the messaging key at.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAddressMessagingKeyStatus: (address: string, at?: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get identity for an address.
     * @param {string} address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAddressMetadata: (address: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * AddressesApi - functional programming interface
 * @export
 */
declare const AddressesApiFp: (configuration?: Configuration) => {
    /**
     *
     * @summary Get identity for an address.
     * @param {string} address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
     * @param {number} [at] The time to query the messaging key at.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAddressIdentityKey(address: string, at?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetIdentityKeyResponseBody>>;
    /**
     *
     * @summary Get messaging key for an address.
     * @param {string} address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
     * @param {number} [at] The time to query the messaging key at.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAddressMessagingKey(address: string, at?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAddressMessagingKeyResponseBody>>;
    /**
     *
     * @summary Get status for messaging key for an address.
     * @param {string} address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
     * @param {number} [at] The time to query the messaging key at.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAddressMessagingKeyStatus(address: string, at?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStatusResponseBody>>;
    /**
     *
     * @summary Get identity for an address.
     * @param {string} address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAddressMetadata(address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Metadata>>;
};
/**
 * AddressesApi - factory interface
 * @export
 */
declare const AddressesApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *
     * @summary Get identity for an address.
     * @param {string} address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
     * @param {number} [at] The time to query the messaging key at.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAddressIdentityKey(address: string, at?: number, options?: any): AxiosPromise<GetIdentityKeyResponseBody>;
    /**
     *
     * @summary Get messaging key for an address.
     * @param {string} address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
     * @param {number} [at] The time to query the messaging key at.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAddressMessagingKey(address: string, at?: number, options?: any): AxiosPromise<GetAddressMessagingKeyResponseBody>;
    /**
     *
     * @summary Get status for messaging key for an address.
     * @param {string} address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
     * @param {number} [at] The time to query the messaging key at.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAddressMessagingKeyStatus(address: string, at?: number, options?: any): AxiosPromise<GetStatusResponseBody>;
    /**
     *
     * @summary Get identity for an address.
     * @param {string} address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAddressMetadata(address: string, options?: any): AxiosPromise<Metadata>;
};
/**
 * AddressesApi - interface
 * @export
 * @interface AddressesApi
 */
interface AddressesApiInterface {
    /**
     *
     * @summary Get identity for an address.
     * @param {string} address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
     * @param {number} [at] The time to query the messaging key at.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    getAddressIdentityKey(address: string, at?: number, options?: AxiosRequestConfig): AxiosPromise<GetIdentityKeyResponseBody>;
    /**
     *
     * @summary Get messaging key for an address.
     * @param {string} address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
     * @param {number} [at] The time to query the messaging key at.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    getAddressMessagingKey(address: string, at?: number, options?: AxiosRequestConfig): AxiosPromise<GetAddressMessagingKeyResponseBody>;
    /**
     *
     * @summary Get status for messaging key for an address.
     * @param {string} address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
     * @param {number} [at] The time to query the messaging key at.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    getAddressMessagingKeyStatus(address: string, at?: number, options?: AxiosRequestConfig): AxiosPromise<GetStatusResponseBody>;
    /**
     *
     * @summary Get identity for an address.
     * @param {string} address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    getAddressMetadata(address: string, options?: AxiosRequestConfig): AxiosPromise<Metadata>;
}
/**
 * AddressesApi - object-oriented interface
 * @export
 * @class AddressesApi
 * @extends {BaseAPI}
 */
declare class AddressesApi extends BaseAPI implements AddressesApiInterface {
    /**
     *
     * @summary Get identity for an address.
     * @param {string} address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
     * @param {number} [at] The time to query the messaging key at.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    getAddressIdentityKey(address: string, at?: number, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetIdentityKeyResponseBody, any>>;
    /**
     *
     * @summary Get messaging key for an address.
     * @param {string} address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
     * @param {number} [at] The time to query the messaging key at.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    getAddressMessagingKey(address: string, at?: number, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetAddressMessagingKeyResponseBody, any>>;
    /**
     *
     * @summary Get status for messaging key for an address.
     * @param {string} address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
     * @param {number} [at] The time to query the messaging key at.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    getAddressMessagingKeyStatus(address: string, at?: number, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetStatusResponseBody, any>>;
    /**
     *
     * @summary Get identity for an address.
     * @param {string} address Either a blockchain or Mailchain address. Blockchain address are encoded based on the protocol. Mailchain addresses are full addresses and contain @ symbol.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    getAddressMetadata(address: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<Metadata, any>>;
}
/**
 * AuthApi - axios parameter creator
 * @export
 */
declare const AuthApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *
     * @summary Finalize authentication.
     * @param {AccountAuthFinalizeRequestBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountAuthFinalize: (body?: AccountAuthFinalizeRequestBody, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Start authentication.
     * @param {AccountAuthInitRequestBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountAuthInit: (body?: AccountAuthInitRequestBody, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Complete opaque registration flow.
     * @param {AccountRegisterCreateRequestBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountRegisterCreate: (body?: AccountRegisterCreateRequestBody, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Finalize registration.
     * @param {AccountRegisterFinalizeRequestBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountRegisterFinalize: (body?: AccountRegisterFinalizeRequestBody, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Start registration process.
     * @param {AccountRegisterInitRequestBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountRegisterInit: (body?: AccountRegisterInitRequestBody, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Complete opaque reset flow.
     * @param {PasswordResetCreateRequestBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    passwordResetCreate: (body?: PasswordResetCreateRequestBody, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Finalize reset password.
     * @param {PasswordResetFinalizeRequestBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    passwordResetFinalize: (body?: PasswordResetFinalizeRequestBody, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Start reset password process.
     * @param {PasswordResetInitRequestBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    passwordResetInit: (body?: PasswordResetInitRequestBody, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * AuthApi - functional programming interface
 * @export
 */
declare const AuthApiFp: (configuration?: Configuration) => {
    /**
     *
     * @summary Finalize authentication.
     * @param {AccountAuthFinalizeRequestBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountAuthFinalize(body?: AccountAuthFinalizeRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountAuthFinalizeResponseBody>>;
    /**
     *
     * @summary Start authentication.
     * @param {AccountAuthInitRequestBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountAuthInit(body?: AccountAuthInitRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountAuthInitResponseBody>>;
    /**
     *
     * @summary Complete opaque registration flow.
     * @param {AccountRegisterCreateRequestBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountRegisterCreate(body?: AccountRegisterCreateRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountRegisterCreateResponseBody>>;
    /**
     *
     * @summary Finalize registration.
     * @param {AccountRegisterFinalizeRequestBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountRegisterFinalize(body?: AccountRegisterFinalizeRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountRegisterFinalizeResponseBody>>;
    /**
     *
     * @summary Start registration process.
     * @param {AccountRegisterInitRequestBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountRegisterInit(body?: AccountRegisterInitRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountRegisterInitResponseBody>>;
    /**
     *
     * @summary Complete opaque reset flow.
     * @param {PasswordResetCreateRequestBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    passwordResetCreate(body?: PasswordResetCreateRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordResetCreateResponseBody>>;
    /**
     *
     * @summary Finalize reset password.
     * @param {PasswordResetFinalizeRequestBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    passwordResetFinalize(body?: PasswordResetFinalizeRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordResetFinalizeResponseBody>>;
    /**
     *
     * @summary Start reset password process.
     * @param {PasswordResetInitRequestBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    passwordResetInit(body?: PasswordResetInitRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordResetInitResponseBody>>;
};
/**
 * AuthApi - factory interface
 * @export
 */
declare const AuthApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *
     * @summary Finalize authentication.
     * @param {AccountAuthFinalizeRequestBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountAuthFinalize(body?: AccountAuthFinalizeRequestBody, options?: any): AxiosPromise<AccountAuthFinalizeResponseBody>;
    /**
     *
     * @summary Start authentication.
     * @param {AccountAuthInitRequestBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountAuthInit(body?: AccountAuthInitRequestBody, options?: any): AxiosPromise<AccountAuthInitResponseBody>;
    /**
     *
     * @summary Complete opaque registration flow.
     * @param {AccountRegisterCreateRequestBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountRegisterCreate(body?: AccountRegisterCreateRequestBody, options?: any): AxiosPromise<AccountRegisterCreateResponseBody>;
    /**
     *
     * @summary Finalize registration.
     * @param {AccountRegisterFinalizeRequestBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountRegisterFinalize(body?: AccountRegisterFinalizeRequestBody, options?: any): AxiosPromise<AccountRegisterFinalizeResponseBody>;
    /**
     *
     * @summary Start registration process.
     * @param {AccountRegisterInitRequestBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    accountRegisterInit(body?: AccountRegisterInitRequestBody, options?: any): AxiosPromise<AccountRegisterInitResponseBody>;
    /**
     *
     * @summary Complete opaque reset flow.
     * @param {PasswordResetCreateRequestBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    passwordResetCreate(body?: PasswordResetCreateRequestBody, options?: any): AxiosPromise<PasswordResetCreateResponseBody>;
    /**
     *
     * @summary Finalize reset password.
     * @param {PasswordResetFinalizeRequestBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    passwordResetFinalize(body?: PasswordResetFinalizeRequestBody, options?: any): AxiosPromise<PasswordResetFinalizeResponseBody>;
    /**
     *
     * @summary Start reset password process.
     * @param {PasswordResetInitRequestBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    passwordResetInit(body?: PasswordResetInitRequestBody, options?: any): AxiosPromise<PasswordResetInitResponseBody>;
};
/**
 * AuthApi - interface
 * @export
 * @interface AuthApi
 */
interface AuthApiInterface {
    /**
     *
     * @summary Finalize authentication.
     * @param {AccountAuthFinalizeRequestBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    accountAuthFinalize(body?: AccountAuthFinalizeRequestBody, options?: AxiosRequestConfig): AxiosPromise<AccountAuthFinalizeResponseBody>;
    /**
     *
     * @summary Start authentication.
     * @param {AccountAuthInitRequestBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    accountAuthInit(body?: AccountAuthInitRequestBody, options?: AxiosRequestConfig): AxiosPromise<AccountAuthInitResponseBody>;
    /**
     *
     * @summary Complete opaque registration flow.
     * @param {AccountRegisterCreateRequestBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    accountRegisterCreate(body?: AccountRegisterCreateRequestBody, options?: AxiosRequestConfig): AxiosPromise<AccountRegisterCreateResponseBody>;
    /**
     *
     * @summary Finalize registration.
     * @param {AccountRegisterFinalizeRequestBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    accountRegisterFinalize(body?: AccountRegisterFinalizeRequestBody, options?: AxiosRequestConfig): AxiosPromise<AccountRegisterFinalizeResponseBody>;
    /**
     *
     * @summary Start registration process.
     * @param {AccountRegisterInitRequestBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    accountRegisterInit(body?: AccountRegisterInitRequestBody, options?: AxiosRequestConfig): AxiosPromise<AccountRegisterInitResponseBody>;
    /**
     *
     * @summary Complete opaque reset flow.
     * @param {PasswordResetCreateRequestBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    passwordResetCreate(body?: PasswordResetCreateRequestBody, options?: AxiosRequestConfig): AxiosPromise<PasswordResetCreateResponseBody>;
    /**
     *
     * @summary Finalize reset password.
     * @param {PasswordResetFinalizeRequestBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    passwordResetFinalize(body?: PasswordResetFinalizeRequestBody, options?: AxiosRequestConfig): AxiosPromise<PasswordResetFinalizeResponseBody>;
    /**
     *
     * @summary Start reset password process.
     * @param {PasswordResetInitRequestBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    passwordResetInit(body?: PasswordResetInitRequestBody, options?: AxiosRequestConfig): AxiosPromise<PasswordResetInitResponseBody>;
}
/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
declare class AuthApi extends BaseAPI implements AuthApiInterface {
    /**
     *
     * @summary Finalize authentication.
     * @param {AccountAuthFinalizeRequestBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    accountAuthFinalize(body?: AccountAuthFinalizeRequestBody, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<AccountAuthFinalizeResponseBody, any>>;
    /**
     *
     * @summary Start authentication.
     * @param {AccountAuthInitRequestBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    accountAuthInit(body?: AccountAuthInitRequestBody, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<AccountAuthInitResponseBody, any>>;
    /**
     *
     * @summary Complete opaque registration flow.
     * @param {AccountRegisterCreateRequestBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    accountRegisterCreate(body?: AccountRegisterCreateRequestBody, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<AccountRegisterCreateResponseBody, any>>;
    /**
     *
     * @summary Finalize registration.
     * @param {AccountRegisterFinalizeRequestBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    accountRegisterFinalize(body?: AccountRegisterFinalizeRequestBody, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<AccountRegisterFinalizeResponseBody, any>>;
    /**
     *
     * @summary Start registration process.
     * @param {AccountRegisterInitRequestBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    accountRegisterInit(body?: AccountRegisterInitRequestBody, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<AccountRegisterInitResponseBody, any>>;
    /**
     *
     * @summary Complete opaque reset flow.
     * @param {PasswordResetCreateRequestBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    passwordResetCreate(body?: PasswordResetCreateRequestBody, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<PasswordResetCreateResponseBody, any>>;
    /**
     *
     * @summary Finalize reset password.
     * @param {PasswordResetFinalizeRequestBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    passwordResetFinalize(body?: PasswordResetFinalizeRequestBody, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<PasswordResetFinalizeResponseBody, any>>;
    /**
     *
     * @summary Start reset password process.
     * @param {PasswordResetInitRequestBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    passwordResetInit(body?: PasswordResetInitRequestBody, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<PasswordResetInitResponseBody, any>>;
}
/**
 * IdentityKeysApi - axios parameter creator
 * @export
 */
declare const IdentityKeysApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * This method will get the identity key associated with a blockchain address. Protocols have different methods for retrieving or calculating a public key from an address.
     * @summary Identity key from blockchain address.
     * @param {string} address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana'} protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIdentityKey: (address: string, protocol: 'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana', options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Calculates all addresses for supported protocols. Then checks to see if vended messaging keys have been created. Only returns addresses that have vended messaging keys.
     * @summary Gets all for an address for an identity key.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIdentityKeyAddresses: (identityKey: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * This method will get take the identity key and look against each protocol where it could be present and check against supported name service resolvers. It will return all resolved names.
     * @summary Get all linked names for a resolver
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {Array<string>} [kind] Kind of reverse resolver to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIdentityKeyResolvableNames: (identityKey: string, kind?: Array<string>, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get a Mailchain messaging key.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {number} [at] The time to query the messaging key at.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMsgKey: (identityKey: string, at?: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Save the identity key for the given address. Identity keys are only saved for protocols where the key cannot be determined from the address.
     * @summary Store address identity key.
     * @param {string} address Address to look for encoded based on the protocol standard.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {string} protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putAddressIdentityKey: (address: string, identityKey: string, protocol: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Only address owners can change an address\'s messaging key. Owner\'s need to sign a message that includes the new messaging key and nonce.
     * @summary Upload a messaging key for an address\'s identity key.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {PutMsgKeyByIDKeyRequestBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putMsgKeyByIDKey: (identityKey: string, body: PutMsgKeyByIDKeyRequestBody, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * IdentityKeysApi - functional programming interface
 * @export
 */
declare const IdentityKeysApiFp: (configuration?: Configuration) => {
    /**
     * This method will get the identity key associated with a blockchain address. Protocols have different methods for retrieving or calculating a public key from an address.
     * @summary Identity key from blockchain address.
     * @param {string} address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana'} protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIdentityKey(address: string, protocol: 'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetIdentityKeyResponseBody>>;
    /**
     * Calculates all addresses for supported protocols. Then checks to see if vended messaging keys have been created. Only returns addresses that have vended messaging keys.
     * @summary Gets all for an address for an identity key.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIdentityKeyAddresses(identityKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetIdentityKeyAddressesResponseBody>>;
    /**
     * This method will get take the identity key and look against each protocol where it could be present and check against supported name service resolvers. It will return all resolved names.
     * @summary Get all linked names for a resolver
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {Array<string>} [kind] Kind of reverse resolver to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIdentityKeyResolvableNames(identityKey: string, kind?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetIdentityKeyResolvableNamesResponseBody>>;
    /**
     *
     * @summary Get a Mailchain messaging key.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {number} [at] The time to query the messaging key at.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMsgKey(identityKey: string, at?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMsgKeyResponseBody>>;
    /**
     * Save the identity key for the given address. Identity keys are only saved for protocols where the key cannot be determined from the address.
     * @summary Store address identity key.
     * @param {string} address Address to look for encoded based on the protocol standard.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {string} protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putAddressIdentityKey(address: string, identityKey: string, protocol: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Only address owners can change an address\'s messaging key. Owner\'s need to sign a message that includes the new messaging key and nonce.
     * @summary Upload a messaging key for an address\'s identity key.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {PutMsgKeyByIDKeyRequestBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putMsgKeyByIDKey(identityKey: string, body: PutMsgKeyByIDKeyRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * IdentityKeysApi - factory interface
 * @export
 */
declare const IdentityKeysApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * This method will get the identity key associated with a blockchain address. Protocols have different methods for retrieving or calculating a public key from an address.
     * @summary Identity key from blockchain address.
     * @param {string} address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana'} protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIdentityKey(address: string, protocol: 'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana', options?: any): AxiosPromise<GetIdentityKeyResponseBody>;
    /**
     * Calculates all addresses for supported protocols. Then checks to see if vended messaging keys have been created. Only returns addresses that have vended messaging keys.
     * @summary Gets all for an address for an identity key.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIdentityKeyAddresses(identityKey: string, options?: any): AxiosPromise<GetIdentityKeyAddressesResponseBody>;
    /**
     * This method will get take the identity key and look against each protocol where it could be present and check against supported name service resolvers. It will return all resolved names.
     * @summary Get all linked names for a resolver
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {Array<string>} [kind] Kind of reverse resolver to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIdentityKeyResolvableNames(identityKey: string, kind?: Array<string>, options?: any): AxiosPromise<GetIdentityKeyResolvableNamesResponseBody>;
    /**
     *
     * @summary Get a Mailchain messaging key.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {number} [at] The time to query the messaging key at.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMsgKey(identityKey: string, at?: number, options?: any): AxiosPromise<GetMsgKeyResponseBody>;
    /**
     * Save the identity key for the given address. Identity keys are only saved for protocols where the key cannot be determined from the address.
     * @summary Store address identity key.
     * @param {string} address Address to look for encoded based on the protocol standard.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {string} protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putAddressIdentityKey(address: string, identityKey: string, protocol: string, options?: any): AxiosPromise<void>;
    /**
     * Only address owners can change an address\'s messaging key. Owner\'s need to sign a message that includes the new messaging key and nonce.
     * @summary Upload a messaging key for an address\'s identity key.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {PutMsgKeyByIDKeyRequestBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putMsgKeyByIDKey(identityKey: string, body: PutMsgKeyByIDKeyRequestBody, options?: any): AxiosPromise<void>;
};
/**
 * IdentityKeysApi - interface
 * @export
 * @interface IdentityKeysApi
 */
interface IdentityKeysApiInterface {
    /**
     * This method will get the identity key associated with a blockchain address. Protocols have different methods for retrieving or calculating a public key from an address.
     * @summary Identity key from blockchain address.
     * @param {string} address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana'} protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityKeysApiInterface
     */
    getIdentityKey(address: string, protocol: 'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana', options?: AxiosRequestConfig): AxiosPromise<GetIdentityKeyResponseBody>;
    /**
     * Calculates all addresses for supported protocols. Then checks to see if vended messaging keys have been created. Only returns addresses that have vended messaging keys.
     * @summary Gets all for an address for an identity key.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityKeysApiInterface
     */
    getIdentityKeyAddresses(identityKey: string, options?: AxiosRequestConfig): AxiosPromise<GetIdentityKeyAddressesResponseBody>;
    /**
     * This method will get take the identity key and look against each protocol where it could be present and check against supported name service resolvers. It will return all resolved names.
     * @summary Get all linked names for a resolver
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {Array<string>} [kind] Kind of reverse resolver to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityKeysApiInterface
     */
    getIdentityKeyResolvableNames(identityKey: string, kind?: Array<string>, options?: AxiosRequestConfig): AxiosPromise<GetIdentityKeyResolvableNamesResponseBody>;
    /**
     *
     * @summary Get a Mailchain messaging key.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {number} [at] The time to query the messaging key at.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityKeysApiInterface
     */
    getMsgKey(identityKey: string, at?: number, options?: AxiosRequestConfig): AxiosPromise<GetMsgKeyResponseBody>;
    /**
     * Save the identity key for the given address. Identity keys are only saved for protocols where the key cannot be determined from the address.
     * @summary Store address identity key.
     * @param {string} address Address to look for encoded based on the protocol standard.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {string} protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityKeysApiInterface
     */
    putAddressIdentityKey(address: string, identityKey: string, protocol: string, options?: AxiosRequestConfig): AxiosPromise<void>;
    /**
     * Only address owners can change an address\'s messaging key. Owner\'s need to sign a message that includes the new messaging key and nonce.
     * @summary Upload a messaging key for an address\'s identity key.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {PutMsgKeyByIDKeyRequestBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityKeysApiInterface
     */
    putMsgKeyByIDKey(identityKey: string, body: PutMsgKeyByIDKeyRequestBody, options?: AxiosRequestConfig): AxiosPromise<void>;
}
/**
 * IdentityKeysApi - object-oriented interface
 * @export
 * @class IdentityKeysApi
 * @extends {BaseAPI}
 */
declare class IdentityKeysApi extends BaseAPI implements IdentityKeysApiInterface {
    /**
     * This method will get the identity key associated with a blockchain address. Protocols have different methods for retrieving or calculating a public key from an address.
     * @summary Identity key from blockchain address.
     * @param {string} address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana'} protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityKeysApi
     */
    getIdentityKey(address: string, protocol: 'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana', options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetIdentityKeyResponseBody, any>>;
    /**
     * Calculates all addresses for supported protocols. Then checks to see if vended messaging keys have been created. Only returns addresses that have vended messaging keys.
     * @summary Gets all for an address for an identity key.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityKeysApi
     */
    getIdentityKeyAddresses(identityKey: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetIdentityKeyAddressesResponseBody, any>>;
    /**
     * This method will get take the identity key and look against each protocol where it could be present and check against supported name service resolvers. It will return all resolved names.
     * @summary Get all linked names for a resolver
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {Array<string>} [kind] Kind of reverse resolver to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityKeysApi
     */
    getIdentityKeyResolvableNames(identityKey: string, kind?: Array<string>, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetIdentityKeyResolvableNamesResponseBody, any>>;
    /**
     *
     * @summary Get a Mailchain messaging key.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {number} [at] The time to query the messaging key at.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityKeysApi
     */
    getMsgKey(identityKey: string, at?: number, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetMsgKeyResponseBody, any>>;
    /**
     * Save the identity key for the given address. Identity keys are only saved for protocols where the key cannot be determined from the address.
     * @summary Store address identity key.
     * @param {string} address Address to look for encoded based on the protocol standard.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {string} protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityKeysApi
     */
    putAddressIdentityKey(address: string, identityKey: string, protocol: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<void, any>>;
    /**
     * Only address owners can change an address\'s messaging key. Owner\'s need to sign a message that includes the new messaging key and nonce.
     * @summary Upload a messaging key for an address\'s identity key.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {PutMsgKeyByIDKeyRequestBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityKeysApi
     */
    putMsgKeyByIDKey(identityKey: string, body: PutMsgKeyByIDKeyRequestBody, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<void, any>>;
}
/**
 * InboxApi - axios parameter creator
 * @export
 */
declare const InboxApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *
     * @summary Remove label from message.
     * @param {string} messageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
     * @param {string} label Label to add to the message.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMessageLabel: (messageId: string, label: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get encrypted payload message body
     * @param {string} messageId The message id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEncryptedMessageBody: (messageId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get message item
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMailboxOverview: (mailboxes?: Array<string>, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get message item
     * @param {string} messageId The message id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessage: (messageId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get messages that have been archived
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInArchivedView: (labels?: Array<string>, from?: string, to?: Array<string>, offset?: number, limit?: number, mailboxes?: Array<string>, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get messages in inbox
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInInboxView: (labels?: Array<string>, from?: string, to?: Array<string>, offset?: number, limit?: number, mailboxes?: Array<string>, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get messages that have not sent yet.
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInOutboxView: (labels?: Array<string>, from?: string, to?: Array<string>, offset?: number, limit?: number, mailboxes?: Array<string>, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get messages in sent folder
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInSentView: (labels?: Array<string>, from?: string, to?: Array<string>, offset?: number, limit?: number, mailboxes?: Array<string>, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get messages in spam folder
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInSpamView: (labels?: Array<string>, from?: string, to?: Array<string>, offset?: number, limit?: number, mailboxes?: Array<string>, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get messages marked as starred by the user.
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInStarredView: (labels?: Array<string>, from?: string, to?: Array<string>, offset?: number, limit?: number, mailboxes?: Array<string>, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get messages in trash folder
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInTrashView: (labels?: Array<string>, from?: string, to?: Array<string>, offset?: number, limit?: number, mailboxes?: Array<string>, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get messages that have not been read by the user.
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInUnreadView: (labels?: Array<string>, from?: string, to?: Array<string>, offset?: number, limit?: number, mailboxes?: Array<string>, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Store a message body for later retrieval
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postEncryptedMessageBody: (body: object, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * The message will be stored in the user\'s inbox. The inbox is private and all encryption happens on the clients machine. The client must keep track of what key was used to encrypt as it will be needed to decrypt later.  To support filtering, sorting and previews while revealing the minimum amount possible to the inbox the client must process the message before and populate the body.
     * @summary Add message to inbox.
     * @param {string} messageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
     * @param {PutEncryptedMessageRequestBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putEncryptedMessage: (messageId: string, body: PutEncryptedMessageRequestBody, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Add label to message.
     * @param {string} messageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
     * @param {string} label Label to add to the message.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putMessageLabel: (messageId: string, label: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * InboxApi - functional programming interface
 * @export
 */
declare const InboxApiFp: (configuration?: Configuration) => {
    /**
     *
     * @summary Remove label from message.
     * @param {string} messageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
     * @param {string} label Label to add to the message.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMessageLabel(messageId: string, label: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Get encrypted payload message body
     * @param {string} messageId The message id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEncryptedMessageBody(messageId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>>;
    /**
     * Get message item
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMailboxOverview(mailboxes?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMailboxOverviewResponseBody>>;
    /**
     * Get message item
     * @param {string} messageId The message id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessage(messageId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMessageResponseBody>>;
    /**
     * Get messages that have been archived
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInArchivedView(labels?: Array<string>, from?: string, to?: Array<string>, offset?: number, limit?: number, mailboxes?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMessagesInViewResponseBody>>;
    /**
     * Get messages in inbox
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInInboxView(labels?: Array<string>, from?: string, to?: Array<string>, offset?: number, limit?: number, mailboxes?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMessagesInViewResponseBody>>;
    /**
     *
     * @summary Get messages that have not sent yet.
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInOutboxView(labels?: Array<string>, from?: string, to?: Array<string>, offset?: number, limit?: number, mailboxes?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMessagesInViewResponseBody>>;
    /**
     * Get messages in sent folder
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInSentView(labels?: Array<string>, from?: string, to?: Array<string>, offset?: number, limit?: number, mailboxes?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMessagesInViewResponseBody>>;
    /**
     * Get messages in spam folder
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInSpamView(labels?: Array<string>, from?: string, to?: Array<string>, offset?: number, limit?: number, mailboxes?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMessagesInViewResponseBody>>;
    /**
     *
     * @summary Get messages marked as starred by the user.
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInStarredView(labels?: Array<string>, from?: string, to?: Array<string>, offset?: number, limit?: number, mailboxes?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMessagesInViewResponseBody>>;
    /**
     * Get messages in trash folder
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInTrashView(labels?: Array<string>, from?: string, to?: Array<string>, offset?: number, limit?: number, mailboxes?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMessagesInViewResponseBody>>;
    /**
     *
     * @summary Get messages that have not been read by the user.
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInUnreadView(labels?: Array<string>, from?: string, to?: Array<string>, offset?: number, limit?: number, mailboxes?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMessagesInViewResponseBody>>;
    /**
     * Store a message body for later retrieval
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postEncryptedMessageBody(body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostPayloadResponseBody>>;
    /**
     * The message will be stored in the user\'s inbox. The inbox is private and all encryption happens on the clients machine. The client must keep track of what key was used to encrypt as it will be needed to decrypt later.  To support filtering, sorting and previews while revealing the minimum amount possible to the inbox the client must process the message before and populate the body.
     * @summary Add message to inbox.
     * @param {string} messageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
     * @param {PutEncryptedMessageRequestBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putEncryptedMessage(messageId: string, body: PutEncryptedMessageRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Add label to message.
     * @param {string} messageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
     * @param {string} label Label to add to the message.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putMessageLabel(messageId: string, label: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * InboxApi - factory interface
 * @export
 */
declare const InboxApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *
     * @summary Remove label from message.
     * @param {string} messageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
     * @param {string} label Label to add to the message.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMessageLabel(messageId: string, label: string, options?: any): AxiosPromise<void>;
    /**
     * Get encrypted payload message body
     * @param {string} messageId The message id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEncryptedMessageBody(messageId: string, options?: any): AxiosPromise<object>;
    /**
     * Get message item
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMailboxOverview(mailboxes?: Array<string>, options?: any): AxiosPromise<GetMailboxOverviewResponseBody>;
    /**
     * Get message item
     * @param {string} messageId The message id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessage(messageId: string, options?: any): AxiosPromise<GetMessageResponseBody>;
    /**
     * Get messages that have been archived
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInArchivedView(labels?: Array<string>, from?: string, to?: Array<string>, offset?: number, limit?: number, mailboxes?: Array<string>, options?: any): AxiosPromise<GetMessagesInViewResponseBody>;
    /**
     * Get messages in inbox
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInInboxView(labels?: Array<string>, from?: string, to?: Array<string>, offset?: number, limit?: number, mailboxes?: Array<string>, options?: any): AxiosPromise<GetMessagesInViewResponseBody>;
    /**
     *
     * @summary Get messages that have not sent yet.
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInOutboxView(labels?: Array<string>, from?: string, to?: Array<string>, offset?: number, limit?: number, mailboxes?: Array<string>, options?: any): AxiosPromise<GetMessagesInViewResponseBody>;
    /**
     * Get messages in sent folder
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInSentView(labels?: Array<string>, from?: string, to?: Array<string>, offset?: number, limit?: number, mailboxes?: Array<string>, options?: any): AxiosPromise<GetMessagesInViewResponseBody>;
    /**
     * Get messages in spam folder
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInSpamView(labels?: Array<string>, from?: string, to?: Array<string>, offset?: number, limit?: number, mailboxes?: Array<string>, options?: any): AxiosPromise<GetMessagesInViewResponseBody>;
    /**
     *
     * @summary Get messages marked as starred by the user.
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInStarredView(labels?: Array<string>, from?: string, to?: Array<string>, offset?: number, limit?: number, mailboxes?: Array<string>, options?: any): AxiosPromise<GetMessagesInViewResponseBody>;
    /**
     * Get messages in trash folder
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInTrashView(labels?: Array<string>, from?: string, to?: Array<string>, offset?: number, limit?: number, mailboxes?: Array<string>, options?: any): AxiosPromise<GetMessagesInViewResponseBody>;
    /**
     *
     * @summary Get messages that have not been read by the user.
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMessagesInUnreadView(labels?: Array<string>, from?: string, to?: Array<string>, offset?: number, limit?: number, mailboxes?: Array<string>, options?: any): AxiosPromise<GetMessagesInViewResponseBody>;
    /**
     * Store a message body for later retrieval
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postEncryptedMessageBody(body: object, options?: any): AxiosPromise<PostPayloadResponseBody>;
    /**
     * The message will be stored in the user\'s inbox. The inbox is private and all encryption happens on the clients machine. The client must keep track of what key was used to encrypt as it will be needed to decrypt later.  To support filtering, sorting and previews while revealing the minimum amount possible to the inbox the client must process the message before and populate the body.
     * @summary Add message to inbox.
     * @param {string} messageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
     * @param {PutEncryptedMessageRequestBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putEncryptedMessage(messageId: string, body: PutEncryptedMessageRequestBody, options?: any): AxiosPromise<void>;
    /**
     *
     * @summary Add label to message.
     * @param {string} messageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
     * @param {string} label Label to add to the message.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putMessageLabel(messageId: string, label: string, options?: any): AxiosPromise<void>;
};
/**
 * InboxApi - interface
 * @export
 * @interface InboxApi
 */
interface InboxApiInterface {
    /**
     *
     * @summary Remove label from message.
     * @param {string} messageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
     * @param {string} label Label to add to the message.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApiInterface
     */
    deleteMessageLabel(messageId: string, label: string, options?: AxiosRequestConfig): AxiosPromise<void>;
    /**
     * Get encrypted payload message body
     * @param {string} messageId The message id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApiInterface
     */
    getEncryptedMessageBody(messageId: string, options?: AxiosRequestConfig): AxiosPromise<object>;
    /**
     * Get message item
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApiInterface
     */
    getMailboxOverview(mailboxes?: Array<string>, options?: AxiosRequestConfig): AxiosPromise<GetMailboxOverviewResponseBody>;
    /**
     * Get message item
     * @param {string} messageId The message id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApiInterface
     */
    getMessage(messageId: string, options?: AxiosRequestConfig): AxiosPromise<GetMessageResponseBody>;
    /**
     * Get messages that have been archived
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApiInterface
     */
    getMessagesInArchivedView(labels?: Array<string>, from?: string, to?: Array<string>, offset?: number, limit?: number, mailboxes?: Array<string>, options?: AxiosRequestConfig): AxiosPromise<GetMessagesInViewResponseBody>;
    /**
     * Get messages in inbox
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApiInterface
     */
    getMessagesInInboxView(labels?: Array<string>, from?: string, to?: Array<string>, offset?: number, limit?: number, mailboxes?: Array<string>, options?: AxiosRequestConfig): AxiosPromise<GetMessagesInViewResponseBody>;
    /**
     *
     * @summary Get messages that have not sent yet.
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApiInterface
     */
    getMessagesInOutboxView(labels?: Array<string>, from?: string, to?: Array<string>, offset?: number, limit?: number, mailboxes?: Array<string>, options?: AxiosRequestConfig): AxiosPromise<GetMessagesInViewResponseBody>;
    /**
     * Get messages in sent folder
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApiInterface
     */
    getMessagesInSentView(labels?: Array<string>, from?: string, to?: Array<string>, offset?: number, limit?: number, mailboxes?: Array<string>, options?: AxiosRequestConfig): AxiosPromise<GetMessagesInViewResponseBody>;
    /**
     * Get messages in spam folder
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApiInterface
     */
    getMessagesInSpamView(labels?: Array<string>, from?: string, to?: Array<string>, offset?: number, limit?: number, mailboxes?: Array<string>, options?: AxiosRequestConfig): AxiosPromise<GetMessagesInViewResponseBody>;
    /**
     *
     * @summary Get messages marked as starred by the user.
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApiInterface
     */
    getMessagesInStarredView(labels?: Array<string>, from?: string, to?: Array<string>, offset?: number, limit?: number, mailboxes?: Array<string>, options?: AxiosRequestConfig): AxiosPromise<GetMessagesInViewResponseBody>;
    /**
     * Get messages in trash folder
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApiInterface
     */
    getMessagesInTrashView(labels?: Array<string>, from?: string, to?: Array<string>, offset?: number, limit?: number, mailboxes?: Array<string>, options?: AxiosRequestConfig): AxiosPromise<GetMessagesInViewResponseBody>;
    /**
     *
     * @summary Get messages that have not been read by the user.
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApiInterface
     */
    getMessagesInUnreadView(labels?: Array<string>, from?: string, to?: Array<string>, offset?: number, limit?: number, mailboxes?: Array<string>, options?: AxiosRequestConfig): AxiosPromise<GetMessagesInViewResponseBody>;
    /**
     * Store a message body for later retrieval
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApiInterface
     */
    postEncryptedMessageBody(body: object, options?: AxiosRequestConfig): AxiosPromise<PostPayloadResponseBody>;
    /**
     * The message will be stored in the user\'s inbox. The inbox is private and all encryption happens on the clients machine. The client must keep track of what key was used to encrypt as it will be needed to decrypt later.  To support filtering, sorting and previews while revealing the minimum amount possible to the inbox the client must process the message before and populate the body.
     * @summary Add message to inbox.
     * @param {string} messageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
     * @param {PutEncryptedMessageRequestBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApiInterface
     */
    putEncryptedMessage(messageId: string, body: PutEncryptedMessageRequestBody, options?: AxiosRequestConfig): AxiosPromise<void>;
    /**
     *
     * @summary Add label to message.
     * @param {string} messageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
     * @param {string} label Label to add to the message.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApiInterface
     */
    putMessageLabel(messageId: string, label: string, options?: AxiosRequestConfig): AxiosPromise<void>;
}
/**
 * InboxApi - object-oriented interface
 * @export
 * @class InboxApi
 * @extends {BaseAPI}
 */
declare class InboxApi extends BaseAPI implements InboxApiInterface {
    /**
     *
     * @summary Remove label from message.
     * @param {string} messageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
     * @param {string} label Label to add to the message.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApi
     */
    deleteMessageLabel(messageId: string, label: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<void, any>>;
    /**
     * Get encrypted payload message body
     * @param {string} messageId The message id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApi
     */
    getEncryptedMessageBody(messageId: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<object, any>>;
    /**
     * Get message item
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApi
     */
    getMailboxOverview(mailboxes?: Array<string>, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetMailboxOverviewResponseBody, any>>;
    /**
     * Get message item
     * @param {string} messageId The message id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApi
     */
    getMessage(messageId: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetMessageResponseBody, any>>;
    /**
     * Get messages that have been archived
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApi
     */
    getMessagesInArchivedView(labels?: Array<string>, from?: string, to?: Array<string>, offset?: number, limit?: number, mailboxes?: Array<string>, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetMessagesInViewResponseBody, any>>;
    /**
     * Get messages in inbox
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApi
     */
    getMessagesInInboxView(labels?: Array<string>, from?: string, to?: Array<string>, offset?: number, limit?: number, mailboxes?: Array<string>, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetMessagesInViewResponseBody, any>>;
    /**
     *
     * @summary Get messages that have not sent yet.
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApi
     */
    getMessagesInOutboxView(labels?: Array<string>, from?: string, to?: Array<string>, offset?: number, limit?: number, mailboxes?: Array<string>, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetMessagesInViewResponseBody, any>>;
    /**
     * Get messages in sent folder
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApi
     */
    getMessagesInSentView(labels?: Array<string>, from?: string, to?: Array<string>, offset?: number, limit?: number, mailboxes?: Array<string>, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetMessagesInViewResponseBody, any>>;
    /**
     * Get messages in spam folder
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApi
     */
    getMessagesInSpamView(labels?: Array<string>, from?: string, to?: Array<string>, offset?: number, limit?: number, mailboxes?: Array<string>, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetMessagesInViewResponseBody, any>>;
    /**
     *
     * @summary Get messages marked as starred by the user.
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApi
     */
    getMessagesInStarredView(labels?: Array<string>, from?: string, to?: Array<string>, offset?: number, limit?: number, mailboxes?: Array<string>, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetMessagesInViewResponseBody, any>>;
    /**
     * Get messages in trash folder
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApi
     */
    getMessagesInTrashView(labels?: Array<string>, from?: string, to?: Array<string>, offset?: number, limit?: number, mailboxes?: Array<string>, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetMessagesInViewResponseBody, any>>;
    /**
     *
     * @summary Get messages that have not been read by the user.
     * @param {Array<string>} [labels] Labels to additionally search for
     * @param {string} [from] Messages from. Rather than the address the identity key is hashed and searched for.
     * @param {Array<string>} [to] Messages to. Rather than the address the identity key is hashed and searched for.
     * @param {number} [offset] Messages offset. Starting point of paginated messages.
     * @param {number} [limit] Messages limit. Message count in each page.
     * @param {Array<string>} [mailboxes] Filter overview by mailbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApi
     */
    getMessagesInUnreadView(labels?: Array<string>, from?: string, to?: Array<string>, offset?: number, limit?: number, mailboxes?: Array<string>, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetMessagesInViewResponseBody, any>>;
    /**
     * Store a message body for later retrieval
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApi
     */
    postEncryptedMessageBody(body: object, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<PostPayloadResponseBody, any>>;
    /**
     * The message will be stored in the user\'s inbox. The inbox is private and all encryption happens on the clients machine. The client must keep track of what key was used to encrypt as it will be needed to decrypt later.  To support filtering, sorting and previews while revealing the minimum amount possible to the inbox the client must process the message before and populate the body.
     * @summary Add message to inbox.
     * @param {string} messageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
     * @param {PutEncryptedMessageRequestBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApi
     */
    putEncryptedMessage(messageId: string, body: PutEncryptedMessageRequestBody, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<void, any>>;
    /**
     *
     * @summary Add label to message.
     * @param {string} messageId MessageID uniquely identifies the message, created deterministically by the client based on the message body contents.
     * @param {string} label Label to add to the message.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApi
     */
    putMessageLabel(messageId: string, label: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<void, any>>;
}
/**
 * MessagingKeysApi - axios parameter creator
 * @export
 */
declare const MessagingKeysApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Calculates all addresses for supported protocols. Then checks to see if vended messaging keys have been created. Only returns addresses that have vended messaging keys.
     * @summary Gets all for an address for an identity key.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIdentityKeyAddresses: (identityKey: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get identity key nonce
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIdentityKeyNonce: (identityKey: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get\'s the public to used to verify Mailchain provided messaging keys.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMailchainPublicKey: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get a Mailchain messaging key.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {number} [at] The time to query the messaging key at.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMsgKey: (identityKey: string, at?: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get protocol address nonce
     * @param {string} address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana'} protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProtocolAddressNonce: (address: string, protocol: 'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana', options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * First it looks up the identity key for the address to see if a user has registered a messaging key for the blockchain address. If a key is not registered it will return a Mailchain vended messaging key. Note: this will only return the vended messaging for owners of the address.
     * @summary Get\'s the private messaging key for a blockchain address.
     * @param {string} address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana'} protocol Protocol where address is looked up.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVendedPrivateMessagingKey: (address: string, protocol: 'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana', identityKey: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * First it looks up the identity key for the address to see if a user has registered that the public key. In this case it will vend messaging key for the identity key. Otherwise it will vend a messaging key for the blockchain address.
     * @summary Get\'s the public messaging key for a blockchain address.
     * @param {string} address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana'} protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVendedPublicMessagingKey: (address: string, protocol: 'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana', options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Only address owners can change an address\'s messaging key. Owner\'s need to sign a message that includes the new messaging key and nonce.
     * @summary Upload a messaging key for an address\'s identity key.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {PutMsgKeyByIDKeyRequestBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putMsgKeyByIDKey: (identityKey: string, body: PutMsgKeyByIDKeyRequestBody, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * MessagingKeysApi - functional programming interface
 * @export
 */
declare const MessagingKeysApiFp: (configuration?: Configuration) => {
    /**
     * Calculates all addresses for supported protocols. Then checks to see if vended messaging keys have been created. Only returns addresses that have vended messaging keys.
     * @summary Gets all for an address for an identity key.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIdentityKeyAddresses(identityKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetIdentityKeyAddressesResponseBody>>;
    /**
     * Get identity key nonce
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIdentityKeyNonce(identityKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetIdentityKeyNonceResponseBody>>;
    /**
     *
     * @summary Get\'s the public to used to verify Mailchain provided messaging keys.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMailchainPublicKey(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMailchainPublicKeyResponseBody>>;
    /**
     *
     * @summary Get a Mailchain messaging key.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {number} [at] The time to query the messaging key at.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMsgKey(identityKey: string, at?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMsgKeyResponseBody>>;
    /**
     * Get protocol address nonce
     * @param {string} address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana'} protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProtocolAddressNonce(address: string, protocol: 'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProtocolAddressNonceResponseBody>>;
    /**
     * First it looks up the identity key for the address to see if a user has registered a messaging key for the blockchain address. If a key is not registered it will return a Mailchain vended messaging key. Note: this will only return the vended messaging for owners of the address.
     * @summary Get\'s the private messaging key for a blockchain address.
     * @param {string} address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana'} protocol Protocol where address is looked up.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVendedPrivateMessagingKey(address: string, protocol: 'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana', identityKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetVendedPrivateMessagingKeyResponseBody>>;
    /**
     * First it looks up the identity key for the address to see if a user has registered that the public key. In this case it will vend messaging key for the identity key. Otherwise it will vend a messaging key for the blockchain address.
     * @summary Get\'s the public messaging key for a blockchain address.
     * @param {string} address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana'} protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVendedPublicMessagingKey(address: string, protocol: 'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMessagingKeyResponseBody>>;
    /**
     * Only address owners can change an address\'s messaging key. Owner\'s need to sign a message that includes the new messaging key and nonce.
     * @summary Upload a messaging key for an address\'s identity key.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {PutMsgKeyByIDKeyRequestBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putMsgKeyByIDKey(identityKey: string, body: PutMsgKeyByIDKeyRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * MessagingKeysApi - factory interface
 * @export
 */
declare const MessagingKeysApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Calculates all addresses for supported protocols. Then checks to see if vended messaging keys have been created. Only returns addresses that have vended messaging keys.
     * @summary Gets all for an address for an identity key.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIdentityKeyAddresses(identityKey: string, options?: any): AxiosPromise<GetIdentityKeyAddressesResponseBody>;
    /**
     * Get identity key nonce
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIdentityKeyNonce(identityKey: string, options?: any): AxiosPromise<GetIdentityKeyNonceResponseBody>;
    /**
     *
     * @summary Get\'s the public to used to verify Mailchain provided messaging keys.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMailchainPublicKey(options?: any): AxiosPromise<GetMailchainPublicKeyResponseBody>;
    /**
     *
     * @summary Get a Mailchain messaging key.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {number} [at] The time to query the messaging key at.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMsgKey(identityKey: string, at?: number, options?: any): AxiosPromise<GetMsgKeyResponseBody>;
    /**
     * Get protocol address nonce
     * @param {string} address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana'} protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProtocolAddressNonce(address: string, protocol: 'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana', options?: any): AxiosPromise<GetProtocolAddressNonceResponseBody>;
    /**
     * First it looks up the identity key for the address to see if a user has registered a messaging key for the blockchain address. If a key is not registered it will return a Mailchain vended messaging key. Note: this will only return the vended messaging for owners of the address.
     * @summary Get\'s the private messaging key for a blockchain address.
     * @param {string} address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana'} protocol Protocol where address is looked up.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVendedPrivateMessagingKey(address: string, protocol: 'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana', identityKey: string, options?: any): AxiosPromise<GetVendedPrivateMessagingKeyResponseBody>;
    /**
     * First it looks up the identity key for the address to see if a user has registered that the public key. In this case it will vend messaging key for the identity key. Otherwise it will vend a messaging key for the blockchain address.
     * @summary Get\'s the public messaging key for a blockchain address.
     * @param {string} address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana'} protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVendedPublicMessagingKey(address: string, protocol: 'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana', options?: any): AxiosPromise<GetMessagingKeyResponseBody>;
    /**
     * Only address owners can change an address\'s messaging key. Owner\'s need to sign a message that includes the new messaging key and nonce.
     * @summary Upload a messaging key for an address\'s identity key.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {PutMsgKeyByIDKeyRequestBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putMsgKeyByIDKey(identityKey: string, body: PutMsgKeyByIDKeyRequestBody, options?: any): AxiosPromise<void>;
};
/**
 * MessagingKeysApi - interface
 * @export
 * @interface MessagingKeysApi
 */
interface MessagingKeysApiInterface {
    /**
     * Calculates all addresses for supported protocols. Then checks to see if vended messaging keys have been created. Only returns addresses that have vended messaging keys.
     * @summary Gets all for an address for an identity key.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingKeysApiInterface
     */
    getIdentityKeyAddresses(identityKey: string, options?: AxiosRequestConfig): AxiosPromise<GetIdentityKeyAddressesResponseBody>;
    /**
     * Get identity key nonce
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingKeysApiInterface
     */
    getIdentityKeyNonce(identityKey: string, options?: AxiosRequestConfig): AxiosPromise<GetIdentityKeyNonceResponseBody>;
    /**
     *
     * @summary Get\'s the public to used to verify Mailchain provided messaging keys.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingKeysApiInterface
     */
    getMailchainPublicKey(options?: AxiosRequestConfig): AxiosPromise<GetMailchainPublicKeyResponseBody>;
    /**
     *
     * @summary Get a Mailchain messaging key.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {number} [at] The time to query the messaging key at.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingKeysApiInterface
     */
    getMsgKey(identityKey: string, at?: number, options?: AxiosRequestConfig): AxiosPromise<GetMsgKeyResponseBody>;
    /**
     * Get protocol address nonce
     * @param {string} address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana'} protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingKeysApiInterface
     */
    getProtocolAddressNonce(address: string, protocol: 'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana', options?: AxiosRequestConfig): AxiosPromise<GetProtocolAddressNonceResponseBody>;
    /**
     * First it looks up the identity key for the address to see if a user has registered a messaging key for the blockchain address. If a key is not registered it will return a Mailchain vended messaging key. Note: this will only return the vended messaging for owners of the address.
     * @summary Get\'s the private messaging key for a blockchain address.
     * @param {string} address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana'} protocol Protocol where address is looked up.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingKeysApiInterface
     */
    getVendedPrivateMessagingKey(address: string, protocol: 'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana', identityKey: string, options?: AxiosRequestConfig): AxiosPromise<GetVendedPrivateMessagingKeyResponseBody>;
    /**
     * First it looks up the identity key for the address to see if a user has registered that the public key. In this case it will vend messaging key for the identity key. Otherwise it will vend a messaging key for the blockchain address.
     * @summary Get\'s the public messaging key for a blockchain address.
     * @param {string} address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana'} protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingKeysApiInterface
     */
    getVendedPublicMessagingKey(address: string, protocol: 'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana', options?: AxiosRequestConfig): AxiosPromise<GetMessagingKeyResponseBody>;
    /**
     * Only address owners can change an address\'s messaging key. Owner\'s need to sign a message that includes the new messaging key and nonce.
     * @summary Upload a messaging key for an address\'s identity key.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {PutMsgKeyByIDKeyRequestBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingKeysApiInterface
     */
    putMsgKeyByIDKey(identityKey: string, body: PutMsgKeyByIDKeyRequestBody, options?: AxiosRequestConfig): AxiosPromise<void>;
}
/**
 * MessagingKeysApi - object-oriented interface
 * @export
 * @class MessagingKeysApi
 * @extends {BaseAPI}
 */
declare class MessagingKeysApi extends BaseAPI implements MessagingKeysApiInterface {
    /**
     * Calculates all addresses for supported protocols. Then checks to see if vended messaging keys have been created. Only returns addresses that have vended messaging keys.
     * @summary Gets all for an address for an identity key.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingKeysApi
     */
    getIdentityKeyAddresses(identityKey: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetIdentityKeyAddressesResponseBody, any>>;
    /**
     * Get identity key nonce
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingKeysApi
     */
    getIdentityKeyNonce(identityKey: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetIdentityKeyNonceResponseBody, any>>;
    /**
     *
     * @summary Get\'s the public to used to verify Mailchain provided messaging keys.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingKeysApi
     */
    getMailchainPublicKey(options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetMailchainPublicKeyResponseBody, any>>;
    /**
     *
     * @summary Get a Mailchain messaging key.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {number} [at] The time to query the messaging key at.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingKeysApi
     */
    getMsgKey(identityKey: string, at?: number, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetMsgKeyResponseBody, any>>;
    /**
     * Get protocol address nonce
     * @param {string} address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana'} protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingKeysApi
     */
    getProtocolAddressNonce(address: string, protocol: 'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana', options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetProtocolAddressNonceResponseBody, any>>;
    /**
     * First it looks up the identity key for the address to see if a user has registered a messaging key for the blockchain address. If a key is not registered it will return a Mailchain vended messaging key. Note: this will only return the vended messaging for owners of the address.
     * @summary Get\'s the private messaging key for a blockchain address.
     * @param {string} address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana'} protocol Protocol where address is looked up.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingKeysApi
     */
    getVendedPrivateMessagingKey(address: string, protocol: 'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana', identityKey: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetVendedPrivateMessagingKeyResponseBody, any>>;
    /**
     * First it looks up the identity key for the address to see if a user has registered that the public key. In this case it will vend messaging key for the identity key. Otherwise it will vend a messaging key for the blockchain address.
     * @summary Get\'s the public messaging key for a blockchain address.
     * @param {string} address Address to look for encoded based on the protocol standard.
     * @param {'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana'} protocol Protocol where address is looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingKeysApi
     */
    getVendedPublicMessagingKey(address: string, protocol: 'ethereum' | 'near' | 'tezos' | 'filecoin' | 'solana', options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetMessagingKeyResponseBody, any>>;
    /**
     * Only address owners can change an address\'s messaging key. Owner\'s need to sign a message that includes the new messaging key and nonce.
     * @summary Upload a messaging key for an address\'s identity key.
     * @param {string} identityKey Blockchain identity key encoded as a descriptive public key.
     * @param {PutMsgKeyByIDKeyRequestBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagingKeysApi
     */
    putMsgKeyByIDKey(identityKey: string, body: PutMsgKeyByIDKeyRequestBody, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<void, any>>;
}
/**
 * TransportApi - axios parameter creator
 * @export
 */
declare const TransportApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Get unconfirmed delivery requests for a recipient
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDeliveryRequests: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get encrypted payload message body
     * @param {string} payloadId The payload id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEncryptedPayload: (payloadId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Create a new request that delivers a message to the intended address.
     * @summary Add a delivery request
     * @param {PostDeliveryRequestRequestBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postDeliveryRequest: (body: PostDeliveryRequestRequestBody, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Store a payload for later delivery
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postEncryptedPayload: (body: object, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Put delivery request confirmation
     * @param {string} deliveryRequestHash Hash of delivery request. Hex encoded with 0x prefix.
     * @param {PutDeliveryRequestConfirmationRequestBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putDeliveryRequestConfirmation: (deliveryRequestHash: string, body: PutDeliveryRequestConfirmationRequestBody, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * TransportApi - functional programming interface
 * @export
 */
declare const TransportApiFp: (configuration?: Configuration) => {
    /**
     * Get unconfirmed delivery requests for a recipient
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDeliveryRequests(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDeliveryRequestsResponseBody>>;
    /**
     * Get encrypted payload message body
     * @param {string} payloadId The payload id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEncryptedPayload(payloadId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>>;
    /**
     * Create a new request that delivers a message to the intended address.
     * @summary Add a delivery request
     * @param {PostDeliveryRequestRequestBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postDeliveryRequest(body: PostDeliveryRequestRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostDeliveryRequestResponseBody>>;
    /**
     * Store a payload for later delivery
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postEncryptedPayload(body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostPayloadResponseBody>>;
    /**
     * Put delivery request confirmation
     * @param {string} deliveryRequestHash Hash of delivery request. Hex encoded with 0x prefix.
     * @param {PutDeliveryRequestConfirmationRequestBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putDeliveryRequestConfirmation(deliveryRequestHash: string, body: PutDeliveryRequestConfirmationRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * TransportApi - factory interface
 * @export
 */
declare const TransportApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Get unconfirmed delivery requests for a recipient
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDeliveryRequests(options?: any): AxiosPromise<GetDeliveryRequestsResponseBody>;
    /**
     * Get encrypted payload message body
     * @param {string} payloadId The payload id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEncryptedPayload(payloadId: string, options?: any): AxiosPromise<object>;
    /**
     * Create a new request that delivers a message to the intended address.
     * @summary Add a delivery request
     * @param {PostDeliveryRequestRequestBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postDeliveryRequest(body: PostDeliveryRequestRequestBody, options?: any): AxiosPromise<PostDeliveryRequestResponseBody>;
    /**
     * Store a payload for later delivery
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postEncryptedPayload(body: object, options?: any): AxiosPromise<PostPayloadResponseBody>;
    /**
     * Put delivery request confirmation
     * @param {string} deliveryRequestHash Hash of delivery request. Hex encoded with 0x prefix.
     * @param {PutDeliveryRequestConfirmationRequestBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putDeliveryRequestConfirmation(deliveryRequestHash: string, body: PutDeliveryRequestConfirmationRequestBody, options?: any): AxiosPromise<void>;
};
/**
 * TransportApi - interface
 * @export
 * @interface TransportApi
 */
interface TransportApiInterface {
    /**
     * Get unconfirmed delivery requests for a recipient
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransportApiInterface
     */
    getDeliveryRequests(options?: AxiosRequestConfig): AxiosPromise<GetDeliveryRequestsResponseBody>;
    /**
     * Get encrypted payload message body
     * @param {string} payloadId The payload id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransportApiInterface
     */
    getEncryptedPayload(payloadId: string, options?: AxiosRequestConfig): AxiosPromise<object>;
    /**
     * Create a new request that delivers a message to the intended address.
     * @summary Add a delivery request
     * @param {PostDeliveryRequestRequestBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransportApiInterface
     */
    postDeliveryRequest(body: PostDeliveryRequestRequestBody, options?: AxiosRequestConfig): AxiosPromise<PostDeliveryRequestResponseBody>;
    /**
     * Store a payload for later delivery
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransportApiInterface
     */
    postEncryptedPayload(body: object, options?: AxiosRequestConfig): AxiosPromise<PostPayloadResponseBody>;
    /**
     * Put delivery request confirmation
     * @param {string} deliveryRequestHash Hash of delivery request. Hex encoded with 0x prefix.
     * @param {PutDeliveryRequestConfirmationRequestBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransportApiInterface
     */
    putDeliveryRequestConfirmation(deliveryRequestHash: string, body: PutDeliveryRequestConfirmationRequestBody, options?: AxiosRequestConfig): AxiosPromise<void>;
}
/**
 * TransportApi - object-oriented interface
 * @export
 * @class TransportApi
 * @extends {BaseAPI}
 */
declare class TransportApi extends BaseAPI implements TransportApiInterface {
    /**
     * Get unconfirmed delivery requests for a recipient
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransportApi
     */
    getDeliveryRequests(options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetDeliveryRequestsResponseBody, any>>;
    /**
     * Get encrypted payload message body
     * @param {string} payloadId The payload id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransportApi
     */
    getEncryptedPayload(payloadId: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<object, any>>;
    /**
     * Create a new request that delivers a message to the intended address.
     * @summary Add a delivery request
     * @param {PostDeliveryRequestRequestBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransportApi
     */
    postDeliveryRequest(body: PostDeliveryRequestRequestBody, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<PostDeliveryRequestResponseBody, any>>;
    /**
     * Store a payload for later delivery
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransportApi
     */
    postEncryptedPayload(body: object, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<PostPayloadResponseBody, any>>;
    /**
     * Put delivery request confirmation
     * @param {string} deliveryRequestHash Hash of delivery request. Hex encoded with 0x prefix.
     * @param {PutDeliveryRequestConfirmationRequestBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransportApi
     */
    putDeliveryRequestConfirmation(deliveryRequestHash: string, body: PutDeliveryRequestConfirmationRequestBody, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<void, any>>;
}
/**
 * UserApi - axios parameter creator
 * @export
 */
declare const UserApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *
     * @summary Deletes an mailbox from the account.
     * @param {string} mailboxId ID of the mailbox to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserMailbox: (mailboxId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Deletes a user setting.
     * @param {string} setting Setting to looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserSetting: (setting: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * This method will get the user session. Incoming cookie will be checked too see if it\'s expired or invalidated
     * @summary Session cookie.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSessionCookie: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get mailboxes registered with Mailchain account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserMailboxes: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get a Mailchain settings by setting id.
     * @param {string} setting Setting to looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserSetting: (setting: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Get a Mailchain settings.
     * @param {string} [group] Group of setting to looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserSettings: (group?: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get username for currently authenticated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsername: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Adds an mailboxes to an account.
     * @param {PostUserMailboxRequestBody} body Encrypted list of mailboxes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUserMailbox: (body: PostUserMailboxRequestBody, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Updates a previous stored mailbox for an account.
     * @param {string} mailboxId ID of the mailbox to update
     * @param {PutUserMailboxRequestBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putUserMailbox: (mailboxId: string, body: PutUserMailboxRequestBody, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Sets a user setting.
     * @param {string} setting Name of the setting to store
     * @param {PutUserSettingRequestBody} body Encrypted private key to store
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putUserSetting: (setting: string, body: PutUserSettingRequestBody, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * UserApi - functional programming interface
 * @export
 */
declare const UserApiFp: (configuration?: Configuration) => {
    /**
     *
     * @summary Deletes an mailbox from the account.
     * @param {string} mailboxId ID of the mailbox to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserMailbox(mailboxId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Deletes a user setting.
     * @param {string} setting Setting to looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserSetting(setting: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * This method will get the user session. Incoming cookie will be checked too see if it\'s expired or invalidated
     * @summary Session cookie.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSessionCookie(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSessionCookieResponseBody>>;
    /**
     *
     * @summary Get mailboxes registered with Mailchain account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserMailboxes(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserMailboxesResponseBody>>;
    /**
     *
     * @summary Get a Mailchain settings by setting id.
     * @param {string} setting Setting to looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserSetting(setting: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Setting>>;
    /**
     *
     * @summary Get a Mailchain settings.
     * @param {string} [group] Group of setting to looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserSettings(group?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserSettingsResponseBody>>;
    /**
     * Get username for currently authenticated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsername(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUsernameResponseBody>>;
    /**
     *
     * @summary Adds an mailboxes to an account.
     * @param {PostUserMailboxRequestBody} body Encrypted list of mailboxes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUserMailbox(body: PostUserMailboxRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostUserMailboxResponseBody>>;
    /**
     *
     * @summary Updates a previous stored mailbox for an account.
     * @param {string} mailboxId ID of the mailbox to update
     * @param {PutUserMailboxRequestBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putUserMailbox(mailboxId: string, body: PutUserMailboxRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     *
     * @summary Sets a user setting.
     * @param {string} setting Name of the setting to store
     * @param {PutUserSettingRequestBody} body Encrypted private key to store
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putUserSetting(setting: string, body: PutUserSettingRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * UserApi - factory interface
 * @export
 */
declare const UserApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *
     * @summary Deletes an mailbox from the account.
     * @param {string} mailboxId ID of the mailbox to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserMailbox(mailboxId: string, options?: any): AxiosPromise<void>;
    /**
     *
     * @summary Deletes a user setting.
     * @param {string} setting Setting to looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserSetting(setting: string, options?: any): AxiosPromise<void>;
    /**
     * This method will get the user session. Incoming cookie will be checked too see if it\'s expired or invalidated
     * @summary Session cookie.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSessionCookie(options?: any): AxiosPromise<GetSessionCookieResponseBody>;
    /**
     *
     * @summary Get mailboxes registered with Mailchain account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserMailboxes(options?: any): AxiosPromise<GetUserMailboxesResponseBody>;
    /**
     *
     * @summary Get a Mailchain settings by setting id.
     * @param {string} setting Setting to looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserSetting(setting: string, options?: any): AxiosPromise<Setting>;
    /**
     *
     * @summary Get a Mailchain settings.
     * @param {string} [group] Group of setting to looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserSettings(group?: string, options?: any): AxiosPromise<GetUserSettingsResponseBody>;
    /**
     * Get username for currently authenticated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsername(options?: any): AxiosPromise<GetUsernameResponseBody>;
    /**
     *
     * @summary Adds an mailboxes to an account.
     * @param {PostUserMailboxRequestBody} body Encrypted list of mailboxes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUserMailbox(body: PostUserMailboxRequestBody, options?: any): AxiosPromise<PostUserMailboxResponseBody>;
    /**
     *
     * @summary Updates a previous stored mailbox for an account.
     * @param {string} mailboxId ID of the mailbox to update
     * @param {PutUserMailboxRequestBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putUserMailbox(mailboxId: string, body: PutUserMailboxRequestBody, options?: any): AxiosPromise<void>;
    /**
     *
     * @summary Sets a user setting.
     * @param {string} setting Name of the setting to store
     * @param {PutUserSettingRequestBody} body Encrypted private key to store
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putUserSetting(setting: string, body: PutUserSettingRequestBody, options?: any): AxiosPromise<void>;
};
/**
 * UserApi - interface
 * @export
 * @interface UserApi
 */
interface UserApiInterface {
    /**
     *
     * @summary Deletes an mailbox from the account.
     * @param {string} mailboxId ID of the mailbox to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    deleteUserMailbox(mailboxId: string, options?: AxiosRequestConfig): AxiosPromise<void>;
    /**
     *
     * @summary Deletes a user setting.
     * @param {string} setting Setting to looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    deleteUserSetting(setting: string, options?: AxiosRequestConfig): AxiosPromise<void>;
    /**
     * This method will get the user session. Incoming cookie will be checked too see if it\'s expired or invalidated
     * @summary Session cookie.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getSessionCookie(options?: AxiosRequestConfig): AxiosPromise<GetSessionCookieResponseBody>;
    /**
     *
     * @summary Get mailboxes registered with Mailchain account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getUserMailboxes(options?: AxiosRequestConfig): AxiosPromise<GetUserMailboxesResponseBody>;
    /**
     *
     * @summary Get a Mailchain settings by setting id.
     * @param {string} setting Setting to looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getUserSetting(setting: string, options?: AxiosRequestConfig): AxiosPromise<Setting>;
    /**
     *
     * @summary Get a Mailchain settings.
     * @param {string} [group] Group of setting to looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getUserSettings(group?: string, options?: AxiosRequestConfig): AxiosPromise<GetUserSettingsResponseBody>;
    /**
     * Get username for currently authenticated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getUsername(options?: AxiosRequestConfig): AxiosPromise<GetUsernameResponseBody>;
    /**
     *
     * @summary Adds an mailboxes to an account.
     * @param {PostUserMailboxRequestBody} body Encrypted list of mailboxes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    postUserMailbox(body: PostUserMailboxRequestBody, options?: AxiosRequestConfig): AxiosPromise<PostUserMailboxResponseBody>;
    /**
     *
     * @summary Updates a previous stored mailbox for an account.
     * @param {string} mailboxId ID of the mailbox to update
     * @param {PutUserMailboxRequestBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    putUserMailbox(mailboxId: string, body: PutUserMailboxRequestBody, options?: AxiosRequestConfig): AxiosPromise<void>;
    /**
     *
     * @summary Sets a user setting.
     * @param {string} setting Name of the setting to store
     * @param {PutUserSettingRequestBody} body Encrypted private key to store
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    putUserSetting(setting: string, body: PutUserSettingRequestBody, options?: AxiosRequestConfig): AxiosPromise<void>;
}
/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
declare class UserApi extends BaseAPI implements UserApiInterface {
    /**
     *
     * @summary Deletes an mailbox from the account.
     * @param {string} mailboxId ID of the mailbox to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    deleteUserMailbox(mailboxId: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<void, any>>;
    /**
     *
     * @summary Deletes a user setting.
     * @param {string} setting Setting to looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    deleteUserSetting(setting: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<void, any>>;
    /**
     * This method will get the user session. Incoming cookie will be checked too see if it\'s expired or invalidated
     * @summary Session cookie.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getSessionCookie(options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetSessionCookieResponseBody, any>>;
    /**
     *
     * @summary Get mailboxes registered with Mailchain account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUserMailboxes(options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetUserMailboxesResponseBody, any>>;
    /**
     *
     * @summary Get a Mailchain settings by setting id.
     * @param {string} setting Setting to looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUserSetting(setting: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<Setting, any>>;
    /**
     *
     * @summary Get a Mailchain settings.
     * @param {string} [group] Group of setting to looked up.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUserSettings(group?: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetUserSettingsResponseBody, any>>;
    /**
     * Get username for currently authenticated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUsername(options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetUsernameResponseBody, any>>;
    /**
     *
     * @summary Adds an mailboxes to an account.
     * @param {PostUserMailboxRequestBody} body Encrypted list of mailboxes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    postUserMailbox(body: PostUserMailboxRequestBody, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<PostUserMailboxResponseBody, any>>;
    /**
     *
     * @summary Updates a previous stored mailbox for an account.
     * @param {string} mailboxId ID of the mailbox to update
     * @param {PutUserMailboxRequestBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    putUserMailbox(mailboxId: string, body: PutUserMailboxRequestBody, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<void, any>>;
    /**
     *
     * @summary Sets a user setting.
     * @param {string} setting Name of the setting to store
     * @param {PutUserSettingRequestBody} body Encrypted private key to store
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    putUserSetting(setting: string, body: PutUserSettingRequestBody, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<void, any>>;
}
/**
 * UsersApi - axios parameter creator
 * @export
 */
declare const UsersApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * This method will get the identity key associated with the Mailchain username.
     * @summary Identity key from blockchain address.
     * @param {string} username Username to get identity key for. This is the user name e.g. alice@mailchain.com would be alice. Usernames are case insensitive.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserIdentityKey: (username: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     *
     * @summary Used to check if an username exists.
     * @param {string} username Username to search for. This is the user name e.g. alice@mailchain.com would be alice. Usernames are case insensitive.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsernameAvailable: (username: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * UsersApi - functional programming interface
 * @export
 */
declare const UsersApiFp: (configuration?: Configuration) => {
    /**
     * This method will get the identity key associated with the Mailchain username.
     * @summary Identity key from blockchain address.
     * @param {string} username Username to get identity key for. This is the user name e.g. alice@mailchain.com would be alice. Usernames are case insensitive.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserIdentityKey(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserIdentityKeyResponseBody>>;
    /**
     *
     * @summary Used to check if an username exists.
     * @param {string} username Username to search for. This is the user name e.g. alice@mailchain.com would be alice. Usernames are case insensitive.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsernameAvailable(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUsernameAvailableResponseBody>>;
};
/**
 * UsersApi - factory interface
 * @export
 */
declare const UsersApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * This method will get the identity key associated with the Mailchain username.
     * @summary Identity key from blockchain address.
     * @param {string} username Username to get identity key for. This is the user name e.g. alice@mailchain.com would be alice. Usernames are case insensitive.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserIdentityKey(username: string, options?: any): AxiosPromise<GetUserIdentityKeyResponseBody>;
    /**
     *
     * @summary Used to check if an username exists.
     * @param {string} username Username to search for. This is the user name e.g. alice@mailchain.com would be alice. Usernames are case insensitive.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsernameAvailable(username: string, options?: any): AxiosPromise<GetUsernameAvailableResponseBody>;
};
/**
 * UsersApi - interface
 * @export
 * @interface UsersApi
 */
interface UsersApiInterface {
    /**
     * This method will get the identity key associated with the Mailchain username.
     * @summary Identity key from blockchain address.
     * @param {string} username Username to get identity key for. This is the user name e.g. alice@mailchain.com would be alice. Usernames are case insensitive.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    getUserIdentityKey(username: string, options?: AxiosRequestConfig): AxiosPromise<GetUserIdentityKeyResponseBody>;
    /**
     *
     * @summary Used to check if an username exists.
     * @param {string} username Username to search for. This is the user name e.g. alice@mailchain.com would be alice. Usernames are case insensitive.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiInterface
     */
    getUsernameAvailable(username: string, options?: AxiosRequestConfig): AxiosPromise<GetUsernameAvailableResponseBody>;
}
/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
declare class UsersApi extends BaseAPI implements UsersApiInterface {
    /**
     * This method will get the identity key associated with the Mailchain username.
     * @summary Identity key from blockchain address.
     * @param {string} username Username to get identity key for. This is the user name e.g. alice@mailchain.com would be alice. Usernames are case insensitive.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUserIdentityKey(username: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetUserIdentityKeyResponseBody, any>>;
    /**
     *
     * @summary Used to check if an username exists.
     * @param {string} username Username to search for. This is the user name e.g. alice@mailchain.com would be alice. Usernames are case insensitive.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUsernameAvailable(username: string, options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetUsernameAvailableResponseBody, any>>;
}
/**
 * VersionApi - axios parameter creator
 * @export
 */
declare const VersionApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Get version of the running mailchain client application and API. This method be used to determine what version of the API and client is being used and what functionality.
     * @summary Get version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVersion: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * VersionApi - functional programming interface
 * @export
 */
declare const VersionApiFp: (configuration?: Configuration) => {
    /**
     * Get version of the running mailchain client application and API. This method be used to determine what version of the API and client is being used and what functionality.
     * @summary Get version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVersion(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetVersionResponseBody>>;
};
/**
 * VersionApi - factory interface
 * @export
 */
declare const VersionApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Get version of the running mailchain client application and API. This method be used to determine what version of the API and client is being used and what functionality.
     * @summary Get version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVersion(options?: any): AxiosPromise<GetVersionResponseBody>;
};
/**
 * VersionApi - interface
 * @export
 * @interface VersionApi
 */
interface VersionApiInterface {
    /**
     * Get version of the running mailchain client application and API. This method be used to determine what version of the API and client is being used and what functionality.
     * @summary Get version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionApiInterface
     */
    getVersion(options?: AxiosRequestConfig): AxiosPromise<GetVersionResponseBody>;
}
/**
 * VersionApi - object-oriented interface
 * @export
 * @class VersionApi
 * @extends {BaseAPI}
 */
declare class VersionApi extends BaseAPI implements VersionApiInterface {
    /**
     * Get version of the running mailchain client application and API. This method be used to determine what version of the API and client is being used and what functionality.
     * @summary Get version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionApi
     */
    getVersion(options?: AxiosRequestConfig): Promise<axios.AxiosResponse<GetVersionResponseBody, any>>;
}

export { AccountAuthFinalizeRequestBody, AccountAuthFinalizeResponseBody, AccountAuthInitRequestBody, AccountAuthInitResponseBody, AccountRegisterCreateRequestBody, AccountRegisterCreateResponseBody, AccountRegisterFinalizeRequestBody, AccountRegisterFinalizeResponseBody, AccountRegisterInitRequestBody, AccountRegisterInitResponseBody, Address, AddressEncodingEnum, AddressesApi, AddressesApiAxiosParamCreator, AddressesApiFactory, AddressesApiFp, AddressesApiInterface, AuthApi, AuthApiAxiosParamCreator, AuthApiFactory, AuthApiFp, AuthApiInterface, ContractCall, ContractCallMethodEnum, DeliveryRequest, EncryptedAccountSecret, EncryptedAccountSecretEncryptionKindEnum, EncryptedAccountSecretSecretKindEnum, GetAddressMessagingKeyResponseBody, GetDeliveryRequestsResponseBody, GetIdentityKeyAddressesResponseBody, GetIdentityKeyNonceResponseBody, GetIdentityKeyResolvableNamesResponseBody, GetIdentityKeyResponseBody, GetLabelOverviewResponseBody, GetMailboxItemResponseBody, GetMailboxOverviewResponseBody, GetMailchainPublicKeyResponseBody, GetMessageResponseBody, GetMessagesInViewResponseBody, GetMessagingKeyResponseBody, GetMsgKeyResponseBody, GetProtocolAddressNonceResponseBody, GetSessionCookieResponseBody, GetStatusResponseBody, GetUserIdentityKeyResponseBody, GetUserMailboxesResponseBody, GetUserSettingsResponseBody, GetUsernameAvailableResponseBody, GetUsernameAvailableResponseBodyReasonEnum, GetUsernameResponseBody, GetVendedPrivateMessagingKeyResponseBody, GetVersionResponseBody, IdentityKeysApi, IdentityKeysApiAxiosParamCreator, IdentityKeysApiFactory, IdentityKeysApiFp, IdentityKeysApiInterface, Image, ImageKindEnum, InboxApi, InboxApiAxiosParamCreator, InboxApiFactory, InboxApiFp, InboxApiInterface, MailboxItem, Message, MessageKindEnum, MessagingKey, MessagingKeysApi, MessagingKeysApiAxiosParamCreator, MessagingKeysApiFactory, MessagingKeysApiFp, MessagingKeysApiInterface, Metadata, PasswordResetCreateRequestBody, PasswordResetCreateResponseBody, PasswordResetFinalizeRequestBody, PasswordResetFinalizeResponseBody, PasswordResetInitRequestBody, PasswordResetInitResponseBody, PostDeliveryRequestRequestBody, PostDeliveryRequestResponseBody, PostPayloadResponseBody, PostUserMailboxRequestBody, PostUserMailboxResponseBody, PrivateKey, PrivateKeyCurveEnum, PrivateKeyEncodingEnum, ProvidedKeyProof, PublicKey, PublicKeyCurveEnum, PublicKeyEncodingEnum, PutDeliveryRequestConfirmationRequestBody, PutEncryptedMessageRequestBody, PutEncryptedMessageRequestBodyFolderEnum, PutEncryptedMessageRequestBodyKindEnum, PutMsgKeyByIDKeyRequestBody, PutUserMailboxRequestBody, PutUserSettingRequestBody, PutUserSettingRequestBodyGroupEnum, PutUserSettingRequestBodyKindEnum, RegisteredKeyProof, RegisteredKeyProofSigningMethodEnum, ResolvableName, Setting, SettingGroupEnum, SettingKindEnum, Token, TransportApi, TransportApiAxiosParamCreator, TransportApiFactory, TransportApiFp, TransportApiInterface, UserApi, UserApiAxiosParamCreator, UserApiFactory, UserApiFp, UserApiInterface, UsersApi, UsersApiAxiosParamCreator, UsersApiFactory, UsersApiFp, UsersApiInterface, VersionApi, VersionApiAxiosParamCreator, VersionApiFactory, VersionApiFp, VersionApiInterface };
