"use strict";Object.defineProperty(exports, "__esModule", {value: true});

var _chunk4Y7ZB3S4js = require('./chunk-4Y7ZB3S4.js');



var _chunk3R6QMA72js = require('./chunk-3R6QMA72.js');

// src/helpers/cryptoKeyToApiKey.ts
var _crypto = require('@mailchain/crypto');
var _encoding = require('@mailchain/encoding');
function convertPublic(key) {
  switch (key.curve) {
    case _crypto.KindED25519:
      return { curve: _chunk3R6QMA72js.PublicKeyCurveEnum.Ed25519, value: _encoding.encodeHexZeroX.call(void 0, key.bytes), encoding: "hex/0x-prefix" };
    case _crypto.KindSECP256K1:
      return { curve: _chunk3R6QMA72js.PublicKeyCurveEnum.Secp256k1, value: _encoding.encodeHexZeroX.call(void 0, key.bytes), encoding: "hex/0x-prefix" };
    case _crypto.KindSECP256R1:
      return { curve: _chunk3R6QMA72js.PublicKeyCurveEnum.Secp256r1, value: _encoding.encodeHexZeroX.call(void 0, key.bytes), encoding: "hex/0x-prefix" };
    default:
      throw new (0, _chunk4Y7ZB3S4js.ErrorUnsupportedKey)(key.curve);
  }
}
function convertPrivate(key) {
  switch (key.curve) {
    case _crypto.KindED25519:
      return { curve: _chunk3R6QMA72js.PrivateKeyCurveEnum.Ed25519, value: _encoding.encodeHexZeroX.call(void 0, key.bytes), encoding: "hex/0x-prefix" };
    case _crypto.KindSECP256K1:
      return {
        curve: _chunk3R6QMA72js.PrivateKeyCurveEnum.Secp256k1,
        value: _encoding.encodeHexZeroX.call(void 0, key.bytes),
        encoding: "hex/0x-prefix"
      };
    case _crypto.KindSECP256R1:
      return {
        curve: _chunk3R6QMA72js.PrivateKeyCurveEnum.Secp256r1,
        value: _encoding.encodeHexZeroX.call(void 0, key.bytes),
        encoding: "hex/0x-prefix"
      };
    default:
      throw new (0, _chunk4Y7ZB3S4js.ErrorUnsupportedKey)(key.curve);
  }
}




exports.convertPublic = convertPublic; exports.convertPrivate = convertPrivate;
