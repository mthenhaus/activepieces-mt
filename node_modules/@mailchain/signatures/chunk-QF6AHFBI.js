"use strict";Object.defineProperty(exports, "__esModule", {value: true});



var _chunkWVJPHFO2js = require('./chunk-WVJPHFO2.js');

// src/mailchain_msgkey.ts
var _encoding = require('@mailchain/encoding');
var _crypto = require('@mailchain/crypto');
function mailchainProvidedMessagingKeyMessage(msgKey, address, protocol) {
  if (address.length === 0)
    throw new (0, _chunkWVJPHFO2js.AddressIsEmptyError)();
  if (protocol.length === 0)
    throw new (0, _chunkWVJPHFO2js.ProtocolIsEmptyError)();
  if (address.includes("@")) {
    throw new (0, _chunkWVJPHFO2js.AddressMustBeProtocolAddressError)();
  }
  switch (msgKey.curve) {
    case _crypto.KindED25519:
      const encodedKey = _encoding.encodeHexZeroX.call(void 0, _crypto.publicKeyToBytes.call(void 0, msgKey));
      return new Uint8Array(
        Buffer.from(
          `Mailchain provided messaging key:
Address:${address}
Protocol:${protocol}
Key:${encodedKey}`
        )
      );
    default:
      throw new (0, _crypto.ErrorUnsupportedKey)(msgKey.curve);
  }
}
function signMailchainProvidedMessagingKey(key, msgKey, address, protocol) {
  switch (key.curve) {
    case _crypto.KindED25519:
      const msg = mailchainProvidedMessagingKeyMessage(msgKey, address, protocol);
      return key.sign(msg);
    default:
      throw new (0, _crypto.ErrorUnsupportedKey)(key.curve);
  }
}
function verifyMailchainProvidedMessagingKey(key, msgKey, signature, address, protocol) {
  switch (key.curve) {
    case _crypto.KindED25519:
      const msg = mailchainProvidedMessagingKeyMessage(msgKey, address, protocol);
      return key.verify(msg, signature);
    default:
      throw new (0, _crypto.ErrorUnsupportedKey)(key.curve);
  }
}





exports.mailchainProvidedMessagingKeyMessage = mailchainProvidedMessagingKeyMessage; exports.signMailchainProvidedMessagingKey = signMailchainProvidedMessagingKey; exports.verifyMailchainProvidedMessagingKey = verifyMailchainProvidedMessagingKey;
