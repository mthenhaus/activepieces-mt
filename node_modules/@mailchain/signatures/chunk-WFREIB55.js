"use strict";Object.defineProperty(exports, "__esModule", {value: true});// src/tezos_micheline.ts





var _crypto = require('@mailchain/crypto');
var _encoding = require('@mailchain/encoding');
var _blake2b = require('@noble/hashes/blake2b');
async function signTezosMessage(key, msg) {
  const messagePayload = createTezosSignedMessagePayload(msg);
  return signTezosRaw(key, messagePayload);
}
async function signTezosRaw(key, payload) {
  const bytesHash = _blake2b.blake2b.call(void 0, payload, { dkLen: 256 / 8 });
  switch (key.curve) {
    case _crypto.KindED25519:
    case _crypto.KindSECP256R1:
      return key.sign(bytesHash);
    case _crypto.KindSECP256K1:
      const sigObj = await key.sign(bytesHash);
      return sigObj.slice(0, 64);
    default:
      throw new (0, _crypto.ErrorUnsupportedKey)(key.curve);
  }
}
async function verifyTezosSignedMessage(key, msg, signature) {
  const messagePayload = createTezosSignedMessagePayload(msg);
  const bytesHash = _blake2b.blake2b.call(void 0, messagePayload, { dkLen: 256 / 8 });
  switch (key.curve) {
    case _crypto.KindED25519:
    case _crypto.KindSECP256R1:
    case _crypto.KindSECP256K1:
      return key.verify(bytesHash, signature);
    default:
      throw new (0, _crypto.ErrorUnsupportedKey)(key.curve);
  }
}
function createTezosSignedMessagePayload(msg) {
  return formatAsTezosMicheline(_encoding.decodeUtf8.call(void 0, `Tezos Signed Message: ${msg}`));
}
function formatAsTezosMicheline(payload) {
  const bytesLength = payload.length.toString(16);
  const addPadding = `00000000${bytesLength}`;
  const paddedBytesLength = addPadding.slice(addPadding.length - 8);
  return _encoding.decodeHex.call(void 0, "0501" + paddedBytesLength + _encoding.encodeHex.call(void 0, payload));
}






exports.signTezosMessage = signTezosMessage; exports.signTezosRaw = signTezosRaw; exports.verifyTezosSignedMessage = verifyTezosSignedMessage; exports.createTezosSignedMessagePayload = createTezosSignedMessagePayload;
