"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _chunkKFIDTBEMjs = require('./chunk-KFIDTBEM.js');

// src/publickey/ethereum.ts
var _crypto = require('@mailchain/crypto');
var _encoding = require('@mailchain/encoding');
var _isEqualjs = require('lodash/isEqual.js'); var _isEqualjs2 = _interopRequireDefault(_isEqualjs);
var _addressing = require('@mailchain/addressing');
async function ethereumPublicKeyFromSignature(message, signature, expectedAddress) {
  const messageHash = await _chunkKFIDTBEMjs.getMessageHash.call(void 0, message);
  const publicKey = await _crypto.SECP256K1PublicKey.fromSignature(messageHash, signature);
  const address = await _addressing.addressFromPublicKey.call(void 0, publicKey, _addressing.ETHEREUM);
  if (!_isEqualjs2.default.call(void 0, address, expectedAddress)) {
    throw new Error(
      `inconsistent public key calculated, expected address "${_encoding.encodeHex.call(void 0, 
        expectedAddress
      )}" but actual is "${_encoding.encodeHex.call(void 0, address)} (both hex encoded)"`
    );
  }
  return publicKey;
}



exports.ethereumPublicKeyFromSignature = ethereumPublicKeyFromSignature;
