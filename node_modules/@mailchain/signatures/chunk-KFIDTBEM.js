"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } }// src/eth_personal.ts
var _crypto = require('@mailchain/crypto');
var _encoding = require('@mailchain/encoding');
async function verifyEthereumPersonalMessage(key, message, signature) {
  switch (key.curve) {
    case _crypto.KindSECP256K1:
      const messageHash = await getMessageHash(message);
      return key.verify(messageHash, signature);
    default:
      throw new (0, _crypto.ErrorUnsupportedKey)(key.curve);
  }
}
async function signEthereumPersonalMessage(key, message) {
  switch (key.curve) {
    case _crypto.KindSECP256K1:
      const messageHash = await getMessageHash(message);
      return key.sign(messageHash);
    default:
      throw new (0, _crypto.ErrorUnsupportedKey)(key.curve);
  }
}
async function getMessageHash(message) {
  const { hashMessage } = await Promise.resolve().then(() => _interopRequireWildcard(require("@ethersproject/hash")));
  return _encoding.decodeHexZeroX.call(void 0, hashMessage(message));
}





exports.verifyEthereumPersonalMessage = verifyEthereumPersonalMessage; exports.signEthereumPersonalMessage = signEthereumPersonalMessage; exports.getMessageHash = getMessageHash;
