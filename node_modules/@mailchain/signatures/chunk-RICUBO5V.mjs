// src/tezos_micheline.ts
import {
  ErrorUnsupportedKey,
  KindSECP256K1,
  KindED25519,
  KindSECP256R1
} from "@mailchain/crypto";
import { encodeHex, decodeHex, decodeUtf8 } from "@mailchain/encoding";
import { blake2b } from "@noble/hashes/blake2b";
async function signTezosMessage(key, msg) {
  const messagePayload = createTezosSignedMessagePayload(msg);
  return signTezosRaw(key, messagePayload);
}
async function signTezosRaw(key, payload) {
  const bytesHash = blake2b(payload, { dkLen: 256 / 8 });
  switch (key.curve) {
    case KindED25519:
    case KindSECP256R1:
      return key.sign(bytesHash);
    case KindSECP256K1:
      const sigObj = await key.sign(bytesHash);
      return sigObj.slice(0, 64);
    default:
      throw new ErrorUnsupportedKey(key.curve);
  }
}
async function verifyTezosSignedMessage(key, msg, signature) {
  const messagePayload = createTezosSignedMessagePayload(msg);
  const bytesHash = blake2b(messagePayload, { dkLen: 256 / 8 });
  switch (key.curve) {
    case KindED25519:
    case KindSECP256R1:
    case KindSECP256K1:
      return key.verify(bytesHash, signature);
    default:
      throw new ErrorUnsupportedKey(key.curve);
  }
}
function createTezosSignedMessagePayload(msg) {
  return formatAsTezosMicheline(decodeUtf8(`Tezos Signed Message: ${msg}`));
}
function formatAsTezosMicheline(payload) {
  const bytesLength = payload.length.toString(16);
  const addPadding = `00000000${bytesLength}`;
  const paddedBytesLength = addPadding.slice(addPadding.length - 8);
  return decodeHex("0501" + paddedBytesLength + encodeHex(payload));
}

export {
  signTezosMessage,
  signTezosRaw,
  verifyTezosSignedMessage,
  createTezosSignedMessagePayload
};
