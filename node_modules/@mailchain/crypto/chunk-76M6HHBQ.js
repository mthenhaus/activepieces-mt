"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _chunk22KUFCBVjs = require('./chunk-22KUFCBV.js');


var _chunkEMN3YRZAjs = require('./chunk-EMN3YRZA.js');


var _chunkBSMIECIGjs = require('./chunk-BSMIECIG.js');


var _chunkXXPGZHWZjs = require('./chunk-XXPGZHWZ.js');

// src/secp256k1/private.ts
var _secp256k1 = require('secp256k1'); var _secp256k12 = _interopRequireDefault(_secp256k1);
var PrivateKeyLen = 32;
var { privateKeyVerify, publicKeyCreate, ecdsaSign } = _secp256k12.default;
var SECP256K1PrivateKey = class {
  constructor(bytes) {
    _chunkXXPGZHWZjs.__publicField.call(void 0, this, "bytes");
    _chunkXXPGZHWZjs.__publicField.call(void 0, this, "publicKey");
    _chunkXXPGZHWZjs.__publicField.call(void 0, this, "curve", _chunkBSMIECIGjs.KindSECP256K1);
    this.bytes = bytes;
    if (!privateKeyVerify(this.bytes)) {
      throw RangeError("bytes are not a i9valid ECDSA private key");
    }
    this.publicKey = new (0, _chunk22KUFCBVjs.SECP256K1PublicKey)(publicKeyCreate(this.bytes));
  }
  static generate(rand = _chunkEMN3YRZAjs.secureRandom) {
    return new this(rand(PrivateKeyLen));
  }
  async sign(message) {
    const sigObj = ecdsaSign(message, this.bytes);
    const ret = new Uint8Array(65);
    ret.set(sigObj.signature, 0);
    ret.set(new Uint8Array([sigObj.recid]), 64);
    return ret;
  }
};




exports.PrivateKeyLen = PrivateKeyLen; exports.SECP256K1PrivateKey = SECP256K1PrivateKey;
