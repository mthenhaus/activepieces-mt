import {
  idFromPublicKey
} from "./chunk-UL3UBN3O.mjs";
import {
  SECP256K1PublicKey
} from "./chunk-ULGLISTA.mjs";
import {
  NACLECDH,
  NACLSK
} from "./chunk-YC5OYWDE.mjs";
import {
  ED25519PublicKey,
  ED25519PublicKeyLen
} from "./chunk-5SHWDSQB.mjs";
import {
  IdED25519,
  IdNonSpecified,
  IdSECP256K1,
  IdSR25519
} from "./chunk-6E4UZ7KY.mjs";

// src/cipher/nacl/serialization.ts
function serializePublicKeyEncryptedContent(sealedBox, pubKey) {
  const out = new Uint8Array(sealedBox.length + pubKey.bytes.length + 2);
  out.set(new Uint8Array([NACLECDH]), 0);
  out.set(new Uint8Array([idFromPublicKey(pubKey)]), 1);
  out.set(pubKey.bytes, 2);
  out.set(sealedBox, 2 + pubKey.bytes.length);
  return out;
}
function serializePrivateKeyEncryptedContent(sealedBox, keyId) {
  const out = new Uint8Array(sealedBox.length + 2);
  out.set(new Uint8Array([NACLSK]), 0);
  out.set(new Uint8Array([keyId]), 1);
  out.set(sealedBox, 2);
  return out;
}
function deserializePublicKeyEncryptedContent(input) {
  if (input[0] !== NACLECDH) {
    throw new Error("can not deserialize NaCl ECDH encrypted content");
  }
  if (input.length < 35) {
    throw new RangeError("cipher is too short");
  }
  const start = 2;
  let pubKeyEnd = 0;
  switch (input[1]) {
    case IdSECP256K1:
      pubKeyEnd = start + 33;
      return {
        pubKey: new SECP256K1PublicKey(input.slice(start, pubKeyEnd)),
        encryptedContent: input.slice(pubKeyEnd)
      };
    case IdED25519:
      pubKeyEnd = start + ED25519PublicKeyLen;
      return {
        pubKey: new ED25519PublicKey(input.slice(start, pubKeyEnd)),
        encryptedContent: input.slice(pubKeyEnd)
      };
    default:
      throw Error("unrecognized pubKeyID");
  }
}
function deserializePrivateKeyEncryptedContent(input) {
  if (input[0] !== NACLSK) {
    throw new Error("can not deserialize NaCl secret key encrypted content");
  }
  if (input.length < 3) {
    throw new RangeError("cipher is too short");
  }
  if (![IdSECP256K1, IdSR25519, IdED25519, IdNonSpecified].includes(input[1])) {
    throw new RangeError("unknown key type");
  }
  return { encryptedContent: input.slice(2), keyId: input[1] };
}

export {
  serializePublicKeyEncryptedContent,
  serializePrivateKeyEncryptedContent,
  deserializePublicKeyEncryptedContent,
  deserializePrivateKeyEncryptedContent
};
