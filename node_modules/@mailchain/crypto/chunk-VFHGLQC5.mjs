import {
  SECP256K1PublicKey
} from "./chunk-ULGLISTA.mjs";
import {
  secureRandom
} from "./chunk-37TN3OTP.mjs";
import {
  KindSECP256K1
} from "./chunk-6E4UZ7KY.mjs";
import {
  __publicField
} from "./chunk-NHABU752.mjs";

// src/secp256k1/private.ts
import secp256k1 from "secp256k1";
var PrivateKeyLen = 32;
var { privateKeyVerify, publicKeyCreate, ecdsaSign } = secp256k1;
var SECP256K1PrivateKey = class {
  constructor(bytes) {
    __publicField(this, "bytes");
    __publicField(this, "publicKey");
    __publicField(this, "curve", KindSECP256K1);
    this.bytes = bytes;
    if (!privateKeyVerify(this.bytes)) {
      throw RangeError("bytes are not a i9valid ECDSA private key");
    }
    this.publicKey = new SECP256K1PublicKey(publicKeyCreate(this.bytes));
  }
  static generate(rand = secureRandom) {
    return new this(rand(PrivateKeyLen));
  }
  async sign(message) {
    const sigObj = ecdsaSign(message, this.bytes);
    const ret = new Uint8Array(65);
    ret.set(sigObj.signature, 0);
    ret.set(new Uint8Array([sigObj.recid]), 64);
    return ret;
  }
};

export {
  PrivateKeyLen,
  SECP256K1PrivateKey
};
