import {
  KindSECP256K1
} from "./chunk-6E4UZ7KY.mjs";
import {
  __publicField
} from "./chunk-NHABU752.mjs";

// src/secp256k1/public.ts
import secp256k1 from "secp256k1";
var { publicKeyVerify, publicKeyConvert, ecdsaVerify } = secp256k1;
var SECP256K1PublicKeyLength = 33;
var SECP256K1PublicKey = class {
  constructor(bytes) {
    __publicField(this, "bytes");
    __publicField(this, "curve", KindSECP256K1);
    this.bytes = new Uint8Array();
    switch (bytes.length) {
      case 65:
        this.bytes = publicKeyConvert(bytes, true);
        break;
      case SECP256K1PublicKeyLength:
        this.bytes = bytes;
        break;
      default:
        throw RangeError("invalid public key length");
    }
    if (!publicKeyVerify(this.bytes)) {
      throw RangeError("bytes are not a valid ECDSA public key");
    }
  }
  /**
   * fromSignature will return a public key from the message and signature. The returned key
   * will validate the hash. Meaning message and signature pairs will return a public key.
   * Additionally checks should be performed to ensure the public key is as expected.
   * @param message
   * @param signature
   * @returns
   */
  static async fromSignature(message, signature) {
    if (signature.length !== 65) {
      throw Error("signature is missing recovery id");
    }
    const { recoverPublicKey } = await import("@ethersproject/signing-key");
    const recoveredKeyBytes = recoverPublicKey(message, signature);
    const pubKey = new SECP256K1PublicKey(Uint8Array.from(Buffer.from(recoveredKeyBytes.replace("0x", ""), "hex")));
    return pubKey;
  }
  async verify(message, sig) {
    if (sig.length === 65) {
      sig = sig.slice(0, -1);
    }
    return ecdsaVerify(sig, message, this.bytes);
  }
};

export {
  SECP256K1PublicKeyLength,
  SECP256K1PublicKey
};
