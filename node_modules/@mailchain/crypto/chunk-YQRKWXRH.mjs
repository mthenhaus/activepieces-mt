import {
  SECP256R1PublicKey
} from "./chunk-XSRU2W5H.mjs";
import {
  secureRandom
} from "./chunk-37TN3OTP.mjs";
import {
  KindSECP256R1
} from "./chunk-6E4UZ7KY.mjs";
import {
  __publicField
} from "./chunk-NHABU752.mjs";

// src/secp256r1/private.ts
import { secp256r1 } from "@noble/curves/p256";
var SECP256R1PrivateKeyLen = 32;
var SECP256R1PrivateKey = class {
  constructor(bytes, rand = secureRandom) {
    this.bytes = bytes;
    this.rand = rand;
    __publicField(this, "publicKey");
    __publicField(this, "curve", KindSECP256R1);
    if (this.bytes.length !== SECP256R1PrivateKeyLen || !secp256r1.utils.isValidPrivateKey(this.bytes)) {
      throw RangeError("bytes are not a valid secp256r1 private key");
    }
    this.publicKey = new SECP256R1PublicKey(secp256r1.getPublicKey(this.bytes));
    this.curve = KindSECP256R1;
  }
  static generate(rand = secureRandom) {
    return new SECP256R1PrivateKey(rand(), rand);
  }
  async sign(message) {
    const sig = secp256r1.sign(message, this.bytes, { lowS: true, extraEntropy: this.rand() });
    return sig.toCompactRawBytes();
  }
};

export {
  SECP256R1PrivateKeyLen,
  SECP256R1PrivateKey
};
