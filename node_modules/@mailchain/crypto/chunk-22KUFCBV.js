"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _chunkBSMIECIGjs = require('./chunk-BSMIECIG.js');


var _chunkXXPGZHWZjs = require('./chunk-XXPGZHWZ.js');

// src/secp256k1/public.ts
var _secp256k1 = require('secp256k1'); var _secp256k12 = _interopRequireDefault(_secp256k1);
var { publicKeyVerify, publicKeyConvert, ecdsaVerify } = _secp256k12.default;
var SECP256K1PublicKeyLength = 33;
var SECP256K1PublicKey = class {
  constructor(bytes) {
    _chunkXXPGZHWZjs.__publicField.call(void 0, this, "bytes");
    _chunkXXPGZHWZjs.__publicField.call(void 0, this, "curve", _chunkBSMIECIGjs.KindSECP256K1);
    this.bytes = new Uint8Array();
    switch (bytes.length) {
      case 65:
        this.bytes = publicKeyConvert(bytes, true);
        break;
      case SECP256K1PublicKeyLength:
        this.bytes = bytes;
        break;
      default:
        throw RangeError("invalid public key length");
    }
    if (!publicKeyVerify(this.bytes)) {
      throw RangeError("bytes are not a valid ECDSA public key");
    }
  }
  /**
   * fromSignature will return a public key from the message and signature. The returned key
   * will validate the hash. Meaning message and signature pairs will return a public key.
   * Additionally checks should be performed to ensure the public key is as expected.
   * @param message
   * @param signature
   * @returns
   */
  static async fromSignature(message, signature) {
    if (signature.length !== 65) {
      throw Error("signature is missing recovery id");
    }
    const { recoverPublicKey } = await Promise.resolve().then(() => _interopRequireWildcard(require("@ethersproject/signing-key")));
    const recoveredKeyBytes = recoverPublicKey(message, signature);
    const pubKey = new SECP256K1PublicKey(Uint8Array.from(Buffer.from(recoveredKeyBytes.replace("0x", ""), "hex")));
    return pubKey;
  }
  async verify(message, sig) {
    if (sig.length === 65) {
      sig = sig.slice(0, -1);
    }
    return ecdsaVerify(sig, message, this.bytes);
  }
};




exports.SECP256K1PublicKeyLength = SECP256K1PublicKeyLength; exports.SECP256K1PublicKey = SECP256K1PublicKey;
