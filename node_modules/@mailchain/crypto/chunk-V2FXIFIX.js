"use strict";Object.defineProperty(exports, "__esModule", {value: true});

var _chunkCAC4ESOMjs = require('./chunk-CAC4ESOM.js');


var _chunkEMN3YRZAjs = require('./chunk-EMN3YRZA.js');


var _chunkBSMIECIGjs = require('./chunk-BSMIECIG.js');


var _chunkXXPGZHWZjs = require('./chunk-XXPGZHWZ.js');

// src/secp256r1/private.ts
var _p256 = require('@noble/curves/p256');
var SECP256R1PrivateKeyLen = 32;
var SECP256R1PrivateKey = class {
  constructor(bytes, rand = _chunkEMN3YRZAjs.secureRandom) {
    this.bytes = bytes;
    this.rand = rand;
    _chunkXXPGZHWZjs.__publicField.call(void 0, this, "publicKey");
    _chunkXXPGZHWZjs.__publicField.call(void 0, this, "curve", _chunkBSMIECIGjs.KindSECP256R1);
    if (this.bytes.length !== SECP256R1PrivateKeyLen || !_p256.secp256r1.utils.isValidPrivateKey(this.bytes)) {
      throw RangeError("bytes are not a valid secp256r1 private key");
    }
    this.publicKey = new (0, _chunkCAC4ESOMjs.SECP256R1PublicKey)(_p256.secp256r1.getPublicKey(this.bytes));
    this.curve = _chunkBSMIECIGjs.KindSECP256R1;
  }
  static generate(rand = _chunkEMN3YRZAjs.secureRandom) {
    return new SECP256R1PrivateKey(rand(), rand);
  }
  async sign(message) {
    const sig = _p256.secp256r1.sign(message, this.bytes, { lowS: true, extraEntropy: this.rand() });
    return sig.toCompactRawBytes();
  }
};




exports.SECP256R1PrivateKeyLen = SECP256R1PrivateKeyLen; exports.SECP256R1PrivateKey = SECP256R1PrivateKey;
