import {
  ED25519PrivateKey,
  asED25519PrivateKey
} from "./chunk-474QFQJC.mjs";
import {
  secureRandom
} from "./chunk-37TN3OTP.mjs";
import {
  __publicField
} from "./chunk-NHABU752.mjs";

// src/cipher/ecdh/ed25519.ts
import nacl from "tweetnacl";
import ed2curve from "ed2curve";
var ED25519KeyExchange = class {
  constructor(randomFunc = secureRandom) {
    __publicField(this, "randomFunc");
    this.randomFunc = randomFunc;
  }
  async EphemeralKey() {
    return ED25519PrivateKey.generate(this.randomFunc);
  }
  async SharedSecret(privateKey, publicKey) {
    if (privateKey.publicKey.bytes.toString() === publicKey.bytes.toString()) {
      throw new Error("public key can not be from private key");
    }
    const publicKeyBytes = ED25519KeyExchange.publicKeyToCurve25519(publicKey);
    const privateKeyBytes = ED25519KeyExchange.privateKeyToCurve25519(asED25519PrivateKey(privateKey));
    return nacl.scalarMult(privateKeyBytes, publicKeyBytes);
  }
  static privateKeyToCurve25519(privateKey) {
    return ed2curve.convertSecretKey(privateKey.bytes);
  }
  static publicKeyToCurve25519(publicKey) {
    const output = ed2curve.convertPublicKey(publicKey.bytes);
    if (output === null) {
      throw new Error("invalid public key");
    }
    return output;
  }
};

export {
  ED25519KeyExchange
};
