"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } }

var _chunkIVL2NS6Rjs = require('./chunk-IVL2NS6R.js');


var _chunk43Q3KKH7js = require('./chunk-43Q3KKH7.js');


var _chunkIIMDPWPQjs = require('./chunk-IIMDPWPQ.js');



var _chunkX4UF3TJQjs = require('./chunk-X4UF3TJQ.js');


var _chunk7ODPDFK4js = require('./chunk-7ODPDFK4.js');


var _chunkAFNVAIH6js = require('./chunk-AFNVAIH6.js');


var _chunkGU522C63js = require('./chunk-GU522C63.js');


var _chunkISNWKD6Kjs = require('./chunk-ISNWKD6K.js');



var _chunkYLOVGC5Gjs = require('./chunk-YLOVGC5G.js');


var _chunkXXPGZHWZjs = require('./chunk-XXPGZHWZ.js');

// src/messageComposer.ts
var MessageComposer = class {
  constructor(_ctx) {
    this._ctx = _ctx;
    _chunkXXPGZHWZjs.__publicField.call(void 0, this, "_headers", /* @__PURE__ */ new Map());
    _chunkXXPGZHWZjs.__publicField.call(void 0, this, "_overrideHeaders", /* @__PURE__ */ new Map());
    _chunkXXPGZHWZjs.__publicField.call(void 0, this, "_messages", /* @__PURE__ */ new Map());
    _chunkXXPGZHWZjs.__publicField.call(void 0, this, "_attachments", []);
  }
  /** Set the `Message-ID` field for the message. If not set, random one would be generated. */
  id(value) {
    this._headers.set(_chunkYLOVGC5Gjs.HEADER_LABELS.MessageId, _chunkX4UF3TJQjs.createMessageIdHeader.call(void 0, _chunkYLOVGC5Gjs.HEADER_LABELS.MessageId, [value]));
    return this;
  }
  /** Set the `Subject` filed for the message. If it consists of non US-ASCII characters, it will get encoded. */
  subject(value) {
    this._headers.set(_chunkYLOVGC5Gjs.HEADER_LABELS.Subject, _chunkX4UF3TJQjs.createHeader.call(void 0, _chunkYLOVGC5Gjs.HEADER_LABELS.Subject, value));
    return this;
  }
  /** Set the `From` filed for the message. This is required field and must be set. */
  from(from) {
    this._headers.set(_chunkYLOVGC5Gjs.HEADER_LABELS.From, _chunkX4UF3TJQjs.createHeader.call(void 0, _chunkYLOVGC5Gjs.HEADER_LABELS.From, [from]));
    return this;
  }
  /**
   * Set the recipients for the message based on the `type` parameter.
   *
   * Note: will override any pre-existing recipients for the given `type` when reinvoked with the same `type`.
   */
  recipients(type, ...recipients) {
    this._headers.set(type, _chunkX4UF3TJQjs.createHeader.call(void 0, type, [...recipients]));
    return this;
  }
  /**
   * Set the address that the reply message should be sent to when you want the reply to go to an address that is different than the `From:` address.
   */
  replyTo(address) {
    this._headers.set(_chunkYLOVGC5Gjs.HEADER_LABELS.ReplyTo, _chunkX4UF3TJQjs.createHeader.call(void 0, _chunkYLOVGC5Gjs.HEADER_LABELS.ReplyTo, [address]));
    return this;
  }
  /** Set the Date field for the message. If not set, timestamp of the time invoking `build` will set. */
  date(value) {
    this._headers.set(_chunkYLOVGC5Gjs.HEADER_LABELS.Date, _chunkX4UF3TJQjs.createHeader.call(void 0, _chunkYLOVGC5Gjs.HEADER_LABELS.Date, value));
    return this;
  }
  /**
   * Set your own header with its own value.
   *
   * @param label the label for the header, can be any string containing just US-ASCII printable characters (without white space characters).
   * @param value the value for the header, can be any `string` or {@link Date} or {@link Address} array. Providing other type values will fail.
   * @param attrs custom set of attributes that will be applied to the header.
   */
  customHeader(label, value, ...attrs) {
    return this.internalCustomHeader(this._headers, label, value, ...attrs);
  }
  /**
   * Set (override any existing) custom header that will be applied to the message of the referenced `address`. The bcc recipient is provided via {@link MessageComposer.recipients}.
   *
   * This method is useful if there are custom header private value that only the Bcc recipient should be able to access.
   *
   * @param address the {@link Address.address} of the `Bcc` recipient
   * @param label see `label` docs in {@link MessageComposer.customHeader}.
   * @param value see `value` docs in {@link MessageComposer.customHeader}.
   * @param attrs see `attrs` docs in {@link MessageComposer.customHeader}.
   */
  overrideBccHeader(address, label, value, ...attrs) {
    if (!this._overrideHeaders.has(address)) {
      this._overrideHeaders.set(address, /* @__PURE__ */ new Map());
    }
    return this.internalCustomHeader(this._overrideHeaders.get(address), label, value, ...attrs);
  }
  /**
   * Set (override any existing) custom header that will be applied to the message of the sender {@link ComposedMessage.forSender}.
   *
   * This method is useful if there is some header value only meant for the sender of the message.
   *
   * @param label see `label` docs in {@link MessageComposer.customHeader}.
   * @param value see `value` docs in {@link MessageComposer.customHeader}.
   * @param attrs see `attrs` docs in {@link MessageComposer.customHeader}.
   */
  overrideSenderHeader(label, value, ...attrs) {
    if (!this._overrideHeaders.has(_chunkYLOVGC5Gjs.HEADER_LABELS.From)) {
      this._overrideHeaders.set(_chunkYLOVGC5Gjs.HEADER_LABELS.From, /* @__PURE__ */ new Map());
    }
    return this.internalCustomHeader(this._overrideHeaders.get(_chunkYLOVGC5Gjs.HEADER_LABELS.From), label, value, ...attrs);
  }
  internalCustomHeader(headerStore, label, value, ...attrs) {
    if (!_chunkGU522C63js.hasOnlyPrintableUsAscii.call(void 0, label, false)) {
      throw new Error(
        `invalid header label [${label}]. Header label should be composed only of printable US-ASCII characters without WSC.`
      );
    }
    headerStore.set(`custom-${label}`, _chunkX4UF3TJQjs.createHeader.call(void 0, label, value, ...attrs));
    return this;
  }
  /**
   * Set the content of the message for the defined type.
   *
   * @param type `"html"` will set the content for `text/html` and `"plain"` for `text/plain`
   * @param content the content of the message. If `string` is provided, it needs to be already base64 encoded. If it is {@link Buffer} it will be encoded by the library.
   */
  message(type, content) {
    this._messages.set(type, {
      headers: [
        _chunkX4UF3TJQjs.createHeader.call(void 0, _chunkYLOVGC5Gjs.HEADER_LABELS.ContentType, `text/${type}`, ["charset", "UTF-8"]),
        _chunkX4UF3TJQjs.createHeader.call(void 0, _chunkYLOVGC5Gjs.HEADER_LABELS.ContentTransferEncoding, `base64`)
      ],
      content
    });
    return this;
  }
  /**
   * Add new attachment to the message.
   */
  attachment(attachment) {
    this._attachments.push({
      headers: [
        _chunkX4UF3TJQjs.createHeader.call(void 0, _chunkYLOVGC5Gjs.HEADER_LABELS.ContentType, attachment.contentType),
        _chunkX4UF3TJQjs.createHeader.call(void 0, _chunkYLOVGC5Gjs.HEADER_LABELS.ContentDisposition, "attachment", ["filename", attachment.filename]),
        _chunkX4UF3TJQjs.createHeader.call(void 0, _chunkYLOVGC5Gjs.HEADER_LABELS.ContentTransferEncoding, "base64"),
        _chunkX4UF3TJQjs.createHeader.call(void 0, _chunkYLOVGC5Gjs.HEADER_LABELS.ContentId, `<${attachment.cid}>`)
      ],
      content: attachment.content
    });
    return this;
  }
  /**
   * Build the MIME message of the composed message.
   */
  async build() {
    const finalHeaders = await _chunkIIMDPWPQjs.concludeHeaders.call(void 0, this._headers, this._ctx);
    const contentPart = await _chunk43Q3KKH7js.buildMessageAndAttachments.call(void 0, 
      [...this._messages.values()],
      this._attachments,
      this._ctx
    );
    if (typeof contentPart !== "string") {
      finalHeaders.set(_chunkYLOVGC5Gjs.HEADER_LABELS.ContentType, contentPart.boundaryHeader);
    }
    const finalHeadersForSender = new Map(finalHeaders);
    if (this._overrideHeaders.has(_chunkYLOVGC5Gjs.HEADER_LABELS.From)) {
      const overrideHeaders = this._overrideHeaders.get(_chunkYLOVGC5Gjs.HEADER_LABELS.From);
      overrideHeaders.forEach((value, key) => finalHeadersForSender.set(key, value));
    }
    const builtHeadersForSender = await _chunk7ODPDFK4js.buildHeaders.call(void 0, 
      [...finalHeadersForSender.values()].sort(_chunkISNWKD6Kjs.byHeaderOrder),
      this._ctx
    );
    const finalHeadersVisibleRecipients = new Map(finalHeaders);
    finalHeadersVisibleRecipients.delete(_chunkYLOVGC5Gjs.HEADER_LABELS.Bcc);
    const builtHeadersForToAndCc = await _chunk7ODPDFK4js.buildHeaders.call(void 0, 
      [...finalHeadersVisibleRecipients.values()].sort(_chunkISNWKD6Kjs.byHeaderOrder),
      this._ctx
    );
    const builtHeadersForBcc = [];
    const bccHeader = finalHeaders.get(_chunkYLOVGC5Gjs.HEADER_LABELS.Bcc);
    if (bccHeader && _chunkAFNVAIH6js.isAddressHeader.call(void 0, bccHeader)) {
      for (const bccAddress of bccHeader.value) {
        const finalBccHeaders = new Map(finalHeaders);
        if (this._overrideHeaders.has(bccAddress.address)) {
          const overrideHeaders = this._overrideHeaders.get(bccAddress.address);
          overrideHeaders.forEach((value, key) => finalBccHeaders.set(key, value));
        }
        finalBccHeaders.set(_chunkYLOVGC5Gjs.HEADER_LABELS.Bcc, _chunkX4UF3TJQjs.createHeader.call(void 0, _chunkYLOVGC5Gjs.HEADER_LABELS.Bcc, [bccAddress]));
        const builtHeaders = await _chunk7ODPDFK4js.buildHeaders.call(void 0, [...finalBccHeaders.values()].sort(_chunkISNWKD6Kjs.byHeaderOrder), this._ctx);
        builtHeadersForBcc.push([bccAddress, concatParts(builtHeaders, contentPart)]);
      }
    }
    return {
      forSender: concatParts(builtHeadersForSender, contentPart),
      forVisibleRecipients: concatParts(builtHeadersForToAndCc, contentPart),
      forBlindedRecipients: builtHeadersForBcc
    };
  }
};
function concatParts(headers, contents) {
  return headers + _chunkYLOVGC5Gjs.CRLF + (typeof contents === "string" ? contents : _chunkYLOVGC5Gjs.CRLF + contents.content);
}
function createMessageComposer(customCtx) {
  return new MessageComposer(_nullishCoalesce(customCtx, () => ( _chunkIVL2NS6Rjs.defaultMessageComposerContext.call(void 0, ))));
}




exports.MessageComposer = MessageComposer; exports.createMessageComposer = createMessageComposer;
