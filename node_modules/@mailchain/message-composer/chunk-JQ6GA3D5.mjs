import {
  CRLF,
  HTAB
} from "./chunk-EF46CNMI.mjs";

// src/folding.ts
function simpleHardFold(str, opts) {
  let finalContentLength = opts.lineLength - (opts.prefix?.length ?? 0) - (opts.suffix?.length ?? 0);
  finalContentLength = opts.encodingConsideration === "base64" ? Math.floor(finalContentLength / 4) * 4 : finalContentLength;
  const numFoldedLines = Math.ceil(str.length / finalContentLength);
  let folded = "";
  for (let i = 0; i < numFoldedLines; i++) {
    if (opts.padNewLines && i > 0)
      folded += HTAB;
    const foldPart = str.substring(i * finalContentLength, (i + 1) * finalContentLength);
    folded += `${opts.prefix ?? ""}${foldPart}${opts.suffix ?? ""}`;
    if (i + 1 < numFoldedLines) {
      folded += CRLF;
    }
  }
  return folded;
}
function semanticLineFold(str, lineLength, afterSpace) {
  let pos = 0, result = "", line, match;
  while (pos < str.length) {
    line = str.substring(pos, pos + lineLength);
    if (line.length < lineLength) {
      result += line;
      break;
    }
    if (match = line.match(/^[^\n\r]*(\r?\n|\r)/)) {
      line = match[0];
      result += line;
      pos += line.length;
      continue;
    } else if ((match = line.match(/(\s+)[^\s]*$/)) && match[0].length - (afterSpace ? (match[1] || "").length : 0) < line.length) {
      line = line.substring(0, line.length - (match[0].length - (afterSpace ? (match[1] || "").length : 0)));
    } else if (match = str.substring(pos + line.length).match(/^[^\s]+(\s*)/)) {
      line = line + match[0].substring(0, match[0].length - (!afterSpace ? (match[1] || "").length : 0));
    }
    result += line;
    pos += line.length;
    if (pos < str.length) {
      result += CRLF;
    }
  }
  return result;
}
function contentAppendWithFolding(content, appendParts, lineLength) {
  const contentLines = content.split(CRLF);
  for (const part of appendParts) {
    const lastLine = contentLines[contentLines.length - 1];
    if (lastLine.length === 0 || lastLine.length + part.length < lineLength) {
      const resultLine = lastLine + (lastLine.length > 0 ? "; " : "") + part;
      contentLines[contentLines.length - 1] = resultLine;
    } else {
      contentLines[contentLines.length - 1] = lastLine + ";";
      contentLines.push(HTAB + part);
    }
  }
  return contentLines.join(CRLF);
}

export {
  simpleHardFold,
  semanticLineFold,
  contentAppendWithFolding
};
