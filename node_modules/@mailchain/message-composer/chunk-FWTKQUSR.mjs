import {
  contentTypeBoundaryHeader
} from "./chunk-4XYGRSE6.mjs";
import {
  buildHeaders,
  exportHeader
} from "./chunk-KNVM47YA.mjs";
import {
  simpleHardFold
} from "./chunk-JQ6GA3D5.mjs";
import {
  byHeaderOrder
} from "./chunk-TOAAKKDG.mjs";
import {
  CRLF,
  LINE_LENGTH_FOLD
} from "./chunk-EF46CNMI.mjs";

// src/contentHandler.ts
async function buildMessageAndAttachments(messageParts, attachmentParts, ctx) {
  const builtMessageParts = await buildContentParts(messageParts, false, ctx);
  if (attachmentParts.length === 0) {
    if (typeof builtMessageParts === "string")
      return builtMessageParts;
    return {
      boundaryHeader: contentTypeBoundaryHeader("alternative", builtMessageParts.boundary),
      content: builtMessageParts.parts
    };
  }
  const builtAttachmentParts = await buildContentParts(attachmentParts, true, ctx);
  const mixedBoundaryLine = `--${builtAttachmentParts.boundary}`;
  let content = mixedBoundaryLine + CRLF;
  if (typeof builtMessageParts === "string") {
    content += builtMessageParts + CRLF;
  } else {
    const altHeader = contentTypeBoundaryHeader("alternative", builtMessageParts.boundary);
    content += await exportHeader(altHeader, ctx) + CRLF + CRLF;
    content += builtMessageParts.parts + CRLF;
  }
  content += builtAttachmentParts.parts;
  return { boundaryHeader: contentTypeBoundaryHeader("mixed", builtAttachmentParts.boundary), content };
}
async function buildContentParts(parts, forceMultipart, ctx) {
  const builtParts = await Promise.all(parts.map((p) => buildContentPart(p, ctx)));
  if (builtParts.length === 1 && !forceMultipart)
    return builtParts[0];
  const boundary = (await ctx.encodeBase64(await ctx.random(9))).toUpperCase();
  const boundaryLine = `--${boundary}`;
  const builtPartsStr = builtParts.reduce((acc, curr, i) => {
    acc += boundaryLine + CRLF;
    acc += curr + CRLF;
    if (i === builtParts.length - 1) {
      acc += boundaryLine;
    }
    return acc;
  }, "");
  return {
    boundary,
    parts: builtPartsStr
  };
}
async function buildContentPart({ content, headers }, ctx) {
  let result = await buildHeaders(headers.sort(byHeaderOrder), ctx);
  result += CRLF + CRLF;
  const encodedContent = typeof content === "string" ? content : await ctx.encodeBase64(Uint8Array.from(content));
  result += simpleHardFold(encodedContent, { lineLength: LINE_LENGTH_FOLD, encodingConsideration: "base64" });
  return result;
}

export {
  buildMessageAndAttachments,
  buildContentParts,
  buildContentPart
};
