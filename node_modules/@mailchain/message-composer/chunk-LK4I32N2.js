"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }


var _chunkYLOVGC5Gjs = require('./chunk-YLOVGC5G.js');

// src/folding.ts
function simpleHardFold(str, opts) {
  let finalContentLength = opts.lineLength - (_nullishCoalesce(_optionalChain([opts, 'access', _ => _.prefix, 'optionalAccess', _2 => _2.length]), () => ( 0))) - (_nullishCoalesce(_optionalChain([opts, 'access', _3 => _3.suffix, 'optionalAccess', _4 => _4.length]), () => ( 0)));
  finalContentLength = opts.encodingConsideration === "base64" ? Math.floor(finalContentLength / 4) * 4 : finalContentLength;
  const numFoldedLines = Math.ceil(str.length / finalContentLength);
  let folded = "";
  for (let i = 0; i < numFoldedLines; i++) {
    if (opts.padNewLines && i > 0)
      folded += _chunkYLOVGC5Gjs.HTAB;
    const foldPart = str.substring(i * finalContentLength, (i + 1) * finalContentLength);
    folded += `${_nullishCoalesce(opts.prefix, () => ( ""))}${foldPart}${_nullishCoalesce(opts.suffix, () => ( ""))}`;
    if (i + 1 < numFoldedLines) {
      folded += _chunkYLOVGC5Gjs.CRLF;
    }
  }
  return folded;
}
function semanticLineFold(str, lineLength, afterSpace) {
  let pos = 0, result = "", line, match;
  while (pos < str.length) {
    line = str.substring(pos, pos + lineLength);
    if (line.length < lineLength) {
      result += line;
      break;
    }
    if (match = line.match(/^[^\n\r]*(\r?\n|\r)/)) {
      line = match[0];
      result += line;
      pos += line.length;
      continue;
    } else if ((match = line.match(/(\s+)[^\s]*$/)) && match[0].length - (afterSpace ? (match[1] || "").length : 0) < line.length) {
      line = line.substring(0, line.length - (match[0].length - (afterSpace ? (match[1] || "").length : 0)));
    } else if (match = str.substring(pos + line.length).match(/^[^\s]+(\s*)/)) {
      line = line + match[0].substring(0, match[0].length - (!afterSpace ? (match[1] || "").length : 0));
    }
    result += line;
    pos += line.length;
    if (pos < str.length) {
      result += _chunkYLOVGC5Gjs.CRLF;
    }
  }
  return result;
}
function contentAppendWithFolding(content, appendParts, lineLength) {
  const contentLines = content.split(_chunkYLOVGC5Gjs.CRLF);
  for (const part of appendParts) {
    const lastLine = contentLines[contentLines.length - 1];
    if (lastLine.length === 0 || lastLine.length + part.length < lineLength) {
      const resultLine = lastLine + (lastLine.length > 0 ? "; " : "") + part;
      contentLines[contentLines.length - 1] = resultLine;
    } else {
      contentLines[contentLines.length - 1] = lastLine + ";";
      contentLines.push(_chunkYLOVGC5Gjs.HTAB + part);
    }
  }
  return contentLines.join(_chunkYLOVGC5Gjs.CRLF);
}





exports.simpleHardFold = simpleHardFold; exports.semanticLineFold = semanticLineFold; exports.contentAppendWithFolding = contentAppendWithFolding;
