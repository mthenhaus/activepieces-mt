import {
  defaultMessageComposerContext
} from "./chunk-DS54NT6M.mjs";
import {
  buildMessageAndAttachments
} from "./chunk-FWTKQUSR.mjs";
import {
  concludeHeaders
} from "./chunk-BXLUNISN.mjs";
import {
  createHeader,
  createMessageIdHeader
} from "./chunk-4XYGRSE6.mjs";
import {
  buildHeaders
} from "./chunk-KNVM47YA.mjs";
import {
  isAddressHeader
} from "./chunk-6T2ZNT7O.mjs";
import {
  hasOnlyPrintableUsAscii
} from "./chunk-LCWAGF7N.mjs";
import {
  byHeaderOrder
} from "./chunk-TOAAKKDG.mjs";
import {
  CRLF,
  HEADER_LABELS
} from "./chunk-EF46CNMI.mjs";
import {
  __publicField
} from "./chunk-NHABU752.mjs";

// src/messageComposer.ts
var MessageComposer = class {
  constructor(_ctx) {
    this._ctx = _ctx;
    __publicField(this, "_headers", /* @__PURE__ */ new Map());
    __publicField(this, "_overrideHeaders", /* @__PURE__ */ new Map());
    __publicField(this, "_messages", /* @__PURE__ */ new Map());
    __publicField(this, "_attachments", []);
  }
  /** Set the `Message-ID` field for the message. If not set, random one would be generated. */
  id(value) {
    this._headers.set(HEADER_LABELS.MessageId, createMessageIdHeader(HEADER_LABELS.MessageId, [value]));
    return this;
  }
  /** Set the `Subject` filed for the message. If it consists of non US-ASCII characters, it will get encoded. */
  subject(value) {
    this._headers.set(HEADER_LABELS.Subject, createHeader(HEADER_LABELS.Subject, value));
    return this;
  }
  /** Set the `From` filed for the message. This is required field and must be set. */
  from(from) {
    this._headers.set(HEADER_LABELS.From, createHeader(HEADER_LABELS.From, [from]));
    return this;
  }
  /**
   * Set the recipients for the message based on the `type` parameter.
   *
   * Note: will override any pre-existing recipients for the given `type` when reinvoked with the same `type`.
   */
  recipients(type, ...recipients) {
    this._headers.set(type, createHeader(type, [...recipients]));
    return this;
  }
  /**
   * Set the address that the reply message should be sent to when you want the reply to go to an address that is different than the `From:` address.
   */
  replyTo(address) {
    this._headers.set(HEADER_LABELS.ReplyTo, createHeader(HEADER_LABELS.ReplyTo, [address]));
    return this;
  }
  /** Set the Date field for the message. If not set, timestamp of the time invoking `build` will set. */
  date(value) {
    this._headers.set(HEADER_LABELS.Date, createHeader(HEADER_LABELS.Date, value));
    return this;
  }
  /**
   * Set your own header with its own value.
   *
   * @param label the label for the header, can be any string containing just US-ASCII printable characters (without white space characters).
   * @param value the value for the header, can be any `string` or {@link Date} or {@link Address} array. Providing other type values will fail.
   * @param attrs custom set of attributes that will be applied to the header.
   */
  customHeader(label, value, ...attrs) {
    return this.internalCustomHeader(this._headers, label, value, ...attrs);
  }
  /**
   * Set (override any existing) custom header that will be applied to the message of the referenced `address`. The bcc recipient is provided via {@link MessageComposer.recipients}.
   *
   * This method is useful if there are custom header private value that only the Bcc recipient should be able to access.
   *
   * @param address the {@link Address.address} of the `Bcc` recipient
   * @param label see `label` docs in {@link MessageComposer.customHeader}.
   * @param value see `value` docs in {@link MessageComposer.customHeader}.
   * @param attrs see `attrs` docs in {@link MessageComposer.customHeader}.
   */
  overrideBccHeader(address, label, value, ...attrs) {
    if (!this._overrideHeaders.has(address)) {
      this._overrideHeaders.set(address, /* @__PURE__ */ new Map());
    }
    return this.internalCustomHeader(this._overrideHeaders.get(address), label, value, ...attrs);
  }
  /**
   * Set (override any existing) custom header that will be applied to the message of the sender {@link ComposedMessage.forSender}.
   *
   * This method is useful if there is some header value only meant for the sender of the message.
   *
   * @param label see `label` docs in {@link MessageComposer.customHeader}.
   * @param value see `value` docs in {@link MessageComposer.customHeader}.
   * @param attrs see `attrs` docs in {@link MessageComposer.customHeader}.
   */
  overrideSenderHeader(label, value, ...attrs) {
    if (!this._overrideHeaders.has(HEADER_LABELS.From)) {
      this._overrideHeaders.set(HEADER_LABELS.From, /* @__PURE__ */ new Map());
    }
    return this.internalCustomHeader(this._overrideHeaders.get(HEADER_LABELS.From), label, value, ...attrs);
  }
  internalCustomHeader(headerStore, label, value, ...attrs) {
    if (!hasOnlyPrintableUsAscii(label, false)) {
      throw new Error(
        `invalid header label [${label}]. Header label should be composed only of printable US-ASCII characters without WSC.`
      );
    }
    headerStore.set(`custom-${label}`, createHeader(label, value, ...attrs));
    return this;
  }
  /**
   * Set the content of the message for the defined type.
   *
   * @param type `"html"` will set the content for `text/html` and `"plain"` for `text/plain`
   * @param content the content of the message. If `string` is provided, it needs to be already base64 encoded. If it is {@link Buffer} it will be encoded by the library.
   */
  message(type, content) {
    this._messages.set(type, {
      headers: [
        createHeader(HEADER_LABELS.ContentType, `text/${type}`, ["charset", "UTF-8"]),
        createHeader(HEADER_LABELS.ContentTransferEncoding, `base64`)
      ],
      content
    });
    return this;
  }
  /**
   * Add new attachment to the message.
   */
  attachment(attachment) {
    this._attachments.push({
      headers: [
        createHeader(HEADER_LABELS.ContentType, attachment.contentType),
        createHeader(HEADER_LABELS.ContentDisposition, "attachment", ["filename", attachment.filename]),
        createHeader(HEADER_LABELS.ContentTransferEncoding, "base64"),
        createHeader(HEADER_LABELS.ContentId, `<${attachment.cid}>`)
      ],
      content: attachment.content
    });
    return this;
  }
  /**
   * Build the MIME message of the composed message.
   */
  async build() {
    const finalHeaders = await concludeHeaders(this._headers, this._ctx);
    const contentPart = await buildMessageAndAttachments(
      [...this._messages.values()],
      this._attachments,
      this._ctx
    );
    if (typeof contentPart !== "string") {
      finalHeaders.set(HEADER_LABELS.ContentType, contentPart.boundaryHeader);
    }
    const finalHeadersForSender = new Map(finalHeaders);
    if (this._overrideHeaders.has(HEADER_LABELS.From)) {
      const overrideHeaders = this._overrideHeaders.get(HEADER_LABELS.From);
      overrideHeaders.forEach((value, key) => finalHeadersForSender.set(key, value));
    }
    const builtHeadersForSender = await buildHeaders(
      [...finalHeadersForSender.values()].sort(byHeaderOrder),
      this._ctx
    );
    const finalHeadersVisibleRecipients = new Map(finalHeaders);
    finalHeadersVisibleRecipients.delete(HEADER_LABELS.Bcc);
    const builtHeadersForToAndCc = await buildHeaders(
      [...finalHeadersVisibleRecipients.values()].sort(byHeaderOrder),
      this._ctx
    );
    const builtHeadersForBcc = [];
    const bccHeader = finalHeaders.get(HEADER_LABELS.Bcc);
    if (bccHeader && isAddressHeader(bccHeader)) {
      for (const bccAddress of bccHeader.value) {
        const finalBccHeaders = new Map(finalHeaders);
        if (this._overrideHeaders.has(bccAddress.address)) {
          const overrideHeaders = this._overrideHeaders.get(bccAddress.address);
          overrideHeaders.forEach((value, key) => finalBccHeaders.set(key, value));
        }
        finalBccHeaders.set(HEADER_LABELS.Bcc, createHeader(HEADER_LABELS.Bcc, [bccAddress]));
        const builtHeaders = await buildHeaders([...finalBccHeaders.values()].sort(byHeaderOrder), this._ctx);
        builtHeadersForBcc.push([bccAddress, concatParts(builtHeaders, contentPart)]);
      }
    }
    return {
      forSender: concatParts(builtHeadersForSender, contentPart),
      forVisibleRecipients: concatParts(builtHeadersForToAndCc, contentPart),
      forBlindedRecipients: builtHeadersForBcc
    };
  }
};
function concatParts(headers, contents) {
  return headers + CRLF + (typeof contents === "string" ? contents : CRLF + contents.content);
}
function createMessageComposer(customCtx) {
  return new MessageComposer(customCtx ?? defaultMessageComposerContext());
}

export {
  MessageComposer,
  createMessageComposer
};
