import {
  isAddressHeader,
  isDateHeader,
  isMessageIdHeader,
  isStringHeader
} from "./chunk-6T2ZNT7O.mjs";
import {
  contentAppendWithFolding,
  semanticLineFold,
  simpleHardFold
} from "./chunk-JQ6GA3D5.mjs";
import {
  hasOnlyPrintableUsAscii
} from "./chunk-LCWAGF7N.mjs";
import {
  CRLF,
  HTAB,
  LINE_LENGTH_FOLD
} from "./chunk-EF46CNMI.mjs";

// src/headerHandler.ts
import formatDate from "date-fns/format/index.js";
import enUS from "date-fns/locale/en-US/index.js";
async function buildHeaders(headers, ctx) {
  const exportedHeaders = new Array();
  for (const header of headers) {
    const exportedHeader = await exportHeader(header, ctx);
    exportedHeaders.push(exportedHeader);
  }
  return exportedHeaders.join(CRLF);
}
async function exportHeader(header, ctx) {
  const headerValue = await exportHeaderValue(header, ctx);
  if (header.attrs == null || header.attrs.length === 0)
    return `${header.label}: ${headerValue}`;
  const headerAttrs = await exportHeaderAttributes(header.attrs, ctx);
  return `${header.label}: ${contentAppendWithFolding(headerValue, headerAttrs, LINE_LENGTH_FOLD)}`;
}
async function exportHeaderValue(header, ctx) {
  if (isStringHeader(header))
    return exportStringHeader(header, ctx);
  if (isDateHeader(header))
    return exportDateHeader(header, ctx);
  if (isAddressHeader(header))
    return exportAddressHeader(header, ctx);
  if (isMessageIdHeader(header))
    return exportMessageIdHeader(header, ctx);
  throw new Error(`cannot export value for header [${header.label}]`);
}
async function exportHeaderAttributes(attrs, ctx) {
  return await Promise.all(
    attrs.map(async ([attrKey, attrValue]) => {
      const value = hasOnlyPrintableUsAscii(attrValue) ? attrValue : `=?UTF-8?B?${await ctx.encodeBase64(await ctx.decodeUtf8(attrValue))}?=`;
      if (attrKey != null)
        return `${attrKey}="${value}"`;
      return `"${value}"`;
    })
  );
}
async function exportStringHeader(header, ctx) {
  if (hasOnlyPrintableUsAscii(header.value)) {
    return semanticLineFold(header.value, LINE_LENGTH_FOLD);
  }
  const utf8Array = await ctx.decodeUtf8(header.value);
  const base64Encoded = await ctx.encodeBase64(utf8Array);
  return simpleHardFold(base64Encoded, {
    lineLength: LINE_LENGTH_FOLD,
    prefix: "=?UTF-8?B?",
    suffix: "?=",
    padNewLines: true,
    encodingConsideration: "base64"
  });
}
async function exportDateHeader(header, _ctx) {
  return formatDate(header.value, "EEE, dd MMM yyyy HH:mm:ss xxxx", { locale: enUS });
}
async function exportAddressHeader(header, _ctx) {
  return header.value.map((r) => {
    return r.name?.length ? `"${r.name}" <${r.address}>` : `<${r.address}>`;
  }).join(`,${CRLF}${HTAB}`);
}
async function exportMessageIdHeader(header, _ctx) {
  return header.value.ids.map((id) => id.startsWith("<") && id.endsWith(">") ? id : `<${id}>`).join(`${CRLF}${HTAB}`);
}

export {
  buildHeaders,
  exportHeader,
  exportHeaderValue,
  exportHeaderAttributes,
  exportStringHeader,
  exportDateHeader,
  exportAddressHeader,
  exportMessageIdHeader
};
