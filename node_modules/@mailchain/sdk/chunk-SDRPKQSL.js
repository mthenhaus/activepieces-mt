"use strict";Object.defineProperty(exports, "__esModule", {value: true});

var _chunkXXPGZHWZjs = require('./chunk-XXPGZHWZ.js');

// src/mailchain.ts
var _keyring = require('@mailchain/keyring');
var _crypto = require('@mailchain/crypto');
var _encoding = require('@mailchain/encoding');
var _mail = require('@mailchain/internal/sending/mail');
var _messagingKeys = require('@mailchain/internal/messagingKeys');
var _convertSendMailParams = require('@mailchain/internal/sending/mail/convertSendMailParams');
var _user = require('@mailchain/internal/user');
var _mailbox = require('@mailchain/internal/mailbox');
var _configuration = require('@mailchain/internal/configuration');
var _sending = require('@mailchain/internal/sending');
var Mailchain = class {
  constructor(keyRing, config) {
    this.keyRing = keyRing;
    this.config = config;
    _chunkXXPGZHWZjs.__publicField.call(void 0, this, "_userProfile");
    _chunkXXPGZHWZjs.__publicField.call(void 0, this, "_mailboxOperations");
    this._userProfile = _user.MailchainUserProfile.create(
      config,
      keyRing.accountIdentityKey(),
      keyRing.userMailboxCrypto(),
      keyRing.userSettingsCrypto()
    );
    this._mailboxOperations = _mailbox.MailchainMailboxOperations.create(config, keyRing, null);
  }
  static fromAccountSeed(seed, config = _configuration.defaultConfiguration) {
    const identityKey = _crypto.ED25519PrivateKey.fromSeed(_encoding.ensureDecoded.call(void 0, seed, _encoding.EncodingTypes.HexAny));
    const keyRing = _keyring.KeyRing.fromPrivateKey(identityKey);
    return Mailchain.fromKeyRing(keyRing, config);
  }
  /**
   * Use your Secret Recovery Phrase to authenticate with the SDK.
   * You can get your Secret Recovery Phrases when registering an account or via the [settings page](https://app.mailchain.com/settings) in the application.
   * @param secretRecoveryPhrase a 24 word [BIP 39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki) compatible mnemonic phrase.
   * @returns an authenticated {@link Mailchain} SDK. Use {@link Mailchain.user()} to get the currently authenticate used details
   */
  static fromSecretRecoveryPhrase(secretRecoveryPhrase, password, config = _configuration.defaultConfiguration) {
    const keyRing = _keyring.KeyRing.fromSecretRecoveryPhrase(secretRecoveryPhrase, password);
    return Mailchain.fromKeyRing(keyRing, config);
  }
  /**
   * @deprecated use {@link fromSecretRecoveryPhrase} instead.
   */
  static fromMnemonicPhrase(mnemonic, password, config = _configuration.defaultConfiguration) {
    return Mailchain.fromSecretRecoveryPhrase(mnemonic, password, config);
  }
  static fromKeyRing(keyRing, config = _configuration.defaultConfiguration) {
    return new this(keyRing, config);
  }
  /**
   * Send a mail to any blockchain or Mailchain address using any wallet registered in your Mailchain account.
   *
   * @param params {@link SendMailParams} information about message to send.
   * Required:
   * - `from` the address that the mail is being sent from.
   * - At least one of `to`, `cc`, or `bcc`, who will receive the mail.
   * - `subject` of the mail.
   * - `content` both `html` and `text`.
   * @param options {@link SendMailOptions} additional options for sending mail.
   *
   * @example
   * import { Mailchain } from '@mailchain/sdk';
   *
   * const secretRecoveryPhrase = process.env.SECRET_RECOVERY_PHRASE!; // 24 word mnemonicPhrase
   *
   * const mailchain = Mailchain.fromSecretRecoveryPhrase(secretRecoveryPhrase);
   *
   * const result = await mailchain.sendMail({
   * 		from: `yoursername@mailchain.com`, // sender address
   * 		to: [`0xbb56FbD7A2caC3e4C17936027102344127b7a112@ethereum.mailchain.com`], // list of recipients (blockchain or mailchain addresses)
   * 		subject: 'My first message', // subject line
   * 		content: {
   * 			text: 'Hello Mailchain ðŸ‘‹', // plain text body
   * 			html: '<p>Hello Mailchain ðŸ‘‹</p>', // html body
   * 		},
   * });
   *
   * if (error) {
   *   // handle error
   *   console.warn('Mailchain error', error);
   *   return;
   * }
   * // handle success send mail result
   * console.log(data);
   *
   * @returns Status of the messaging sending request. {@link SentMail} contains different data
   * depending on the status of the request.
   */
  async sendMail(params, options = defaultSendMailOptions) {
    const senderMailbox = await this.getSenderMailbox(params.from, {
      messagingKeys: _messagingKeys.MessagingKeys.create(this.config),
      userProfile: this._userProfile
    });
    const senderMessagingKey = this.keyRing.addressBytesMessagingKey(
      senderMailbox.messagingKeyParams.address,
      senderMailbox.messagingKeyParams.protocol,
      senderMailbox.messagingKeyParams.nonce
    );
    const preparer = _mail.MailPreparer.create(this.config);
    const mailData = _convertSendMailParams.toMailData.call(void 0, params);
    const { data: preparedMail, error: preparedMailError } = await preparer.prepareMail({
      message: mailData,
      payloadPluginHeaders: params.payloadPluginHeaders,
      senderMessagingKey
    });
    if (preparedMailError) {
      return { error: preparedMailError };
    }
    const savedMessageId = await this.saveSentMessage(
      senderMailbox,
      preparedMail.message,
      mailData,
      options.saveToSentFolder
    );
    const distributor = _sending.PayloadDistributor.create(this.config, senderMessagingKey);
    const { data: distributedMail, error: distributedMailError } = await distributor.distributePayload({
      distributions: preparedMail.distributions,
      resolvedAddresses: preparedMail.resolvedAddresses
    });
    if (distributedMailError) {
      return { error: distributedMailError };
    }
    if (options.saveToSentFolder && savedMessageId) {
      await this._mailboxOperations.markOutboxMessageAsSent(savedMessageId);
    }
    return {
      data: {
        savedMessageId,
        sentMailDeliveryRequests: distributedMail
      }
    };
  }
  /**
   * Gets the username and mail address corresponding to the authenticated user.
   *
   * @throws a {@link UserNotFoundError} error if the mnemonic phrase or seed does not have a user registered.
   * A user must be registered via {@link https://app.mailchain.com/register}.
   * Check the mnemonic phrase or seed is correct.
   *
   * @returns a promise containing the username and the mail address of the logged in user.
   *
   * @example
   *
   * import { Mailchain } from "@mailchain/sdk";
   *
   * const secretRecoveryPhrase = process.env.SECRET_RECOVERY_PHRASE!; // 24 word mnemonicPhrase
   *
   * const mailchain = Mailchain.fromSecretRecoveryPhrase(secretRecoveryPhrase);
   *
   * const user = await mailchain.user();
   *
   * console.log(`username: ${user.username}, address: ${user.address}`);
   * // username: alice, address: alice@mailchain.com
   */
  async user() {
    return this._userProfile.getUsername();
  }
  async getSenderMailbox(fromAddress, config) {
    const mailboxes = await config.userProfile.mailboxes();
    const { data, error } = await config.messagingKeys.resolve(fromAddress);
    if (error) {
      throw error;
    }
    const { identityKey } = data;
    if (identityKey == null) {
      throw Error(`${fromAddress} is not registered with Mailchain services`);
    }
    const foundMailbox = mailboxes.find((mailbox) => {
      return _crypto.isPublicKeyEqual.call(void 0, mailbox.identityKey, identityKey);
    });
    if (foundMailbox == null) {
      throw Error(`${fromAddress} is not registered by this account`);
    }
    return foundMailbox;
  }
  async saveSentMessage(senderMailbox, payload, content, saveToSentFolder) {
    if (saveToSentFolder) {
      const { messageId } = await this._mailboxOperations.saveSentMessage({
        userMailbox: senderMailbox,
        payload,
        content
      });
      return messageId;
    }
    return;
  }
};
var defaultSendMailOptions = {
  saveToSentFolder: true
};



exports.Mailchain = Mailchain;
