{
  "version": 3,
  "sources": ["../../../../@sinclair/typebox/build/esm/value/transform/decode.mjs", "../../../../@sinclair/typebox/build/esm/value/transform/encode.mjs", "../../../../@sinclair/typebox/build/esm/value/transform/has.mjs", "../../../../@sinclair/typebox/build/esm/compiler/compiler.mjs"],
  "sourcesContent": ["import { TypeSystemPolicy } from '../../system/policy.mjs';\nimport { Kind, TransformKind } from '../../type/symbols/index.mjs';\nimport { TypeBoxError } from '../../type/error/index.mjs';\nimport { KeyOfPropertyKeys, KeyOfPropertyEntries } from '../../type/keyof/index.mjs';\nimport { Deref, Pushref } from '../deref/index.mjs';\nimport { Check } from '../check/index.mjs';\n// ------------------------------------------------------------------\n// ValueGuard\n// ------------------------------------------------------------------\nimport { HasPropertyKey, IsObject, IsArray, IsValueType, IsUndefined as IsUndefinedValue } from '../guard/index.mjs';\n// ------------------------------------------------------------------\n// KindGuard\n// ------------------------------------------------------------------\nimport { IsTransform, IsSchema, IsUndefined } from '../../type/guard/kind.mjs';\n// ------------------------------------------------------------------\n// Errors\n// ------------------------------------------------------------------\n// thrown externally\n// prettier-ignore\nexport class TransformDecodeCheckError extends TypeBoxError {\n    constructor(schema, value, error) {\n        super(`Unable to decode value as it does not match the expected schema`);\n        this.schema = schema;\n        this.value = value;\n        this.error = error;\n    }\n}\n// prettier-ignore\nexport class TransformDecodeError extends TypeBoxError {\n    constructor(schema, path, value, error) {\n        super(error instanceof Error ? error.message : 'Unknown error');\n        this.schema = schema;\n        this.path = path;\n        this.value = value;\n        this.error = error;\n    }\n}\n// ------------------------------------------------------------------\n// Decode\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction Default(schema, path, value) {\n    try {\n        return IsTransform(schema) ? schema[TransformKind].Decode(value) : value;\n    }\n    catch (error) {\n        throw new TransformDecodeError(schema, path, value, error);\n    }\n}\n// prettier-ignore\nfunction FromArray(schema, references, path, value) {\n    return (IsArray(value))\n        ? Default(schema, path, value.map((value, index) => Visit(schema.items, references, `${path}/${index}`, value)))\n        : Default(schema, path, value);\n}\n// prettier-ignore\nfunction FromIntersect(schema, references, path, value) {\n    if (!IsObject(value) || IsValueType(value))\n        return Default(schema, path, value);\n    const knownEntries = KeyOfPropertyEntries(schema);\n    const knownKeys = knownEntries.map(entry => entry[0]);\n    const knownProperties = { ...value };\n    for (const [knownKey, knownSchema] of knownEntries)\n        if (knownKey in knownProperties) {\n            knownProperties[knownKey] = Visit(knownSchema, references, `${path}/${knownKey}`, knownProperties[knownKey]);\n        }\n    if (!IsTransform(schema.unevaluatedProperties)) {\n        return Default(schema, path, knownProperties);\n    }\n    const unknownKeys = Object.getOwnPropertyNames(knownProperties);\n    const unevaluatedProperties = schema.unevaluatedProperties;\n    const unknownProperties = { ...knownProperties };\n    for (const key of unknownKeys)\n        if (!knownKeys.includes(key)) {\n            unknownProperties[key] = Default(unevaluatedProperties, `${path}/${key}`, unknownProperties[key]);\n        }\n    return Default(schema, path, unknownProperties);\n}\n// prettier-ignore\nfunction FromImport(schema, references, path, value) {\n    const definitions = globalThis.Object.values(schema.$defs);\n    const target = schema.$defs[schema.$ref];\n    const transform = schema[TransformKind];\n    // Note: we need to re-spec the target as TSchema + [TransformKind]\n    const transformTarget = { [TransformKind]: transform, ...target };\n    return Visit(transformTarget, [...references, ...definitions], path, value);\n}\nfunction FromNot(schema, references, path, value) {\n    return Default(schema, path, Visit(schema.not, references, path, value));\n}\n// prettier-ignore\nfunction FromObject(schema, references, path, value) {\n    if (!IsObject(value))\n        return Default(schema, path, value);\n    const knownKeys = KeyOfPropertyKeys(schema);\n    const knownProperties = { ...value };\n    for (const key of knownKeys) {\n        if (!HasPropertyKey(knownProperties, key))\n            continue;\n        // if the property value is undefined, but the target is not, nor does it satisfy exact optional \n        // property policy, then we need to continue. This is a special case for optional property handling \n        // where a transforms wrapped in a optional modifiers should not run.\n        if (IsUndefinedValue(knownProperties[key]) && (!IsUndefined(schema.properties[key]) ||\n            TypeSystemPolicy.IsExactOptionalProperty(knownProperties, key)))\n            continue;\n        // decode property\n        knownProperties[key] = Visit(schema.properties[key], references, `${path}/${key}`, knownProperties[key]);\n    }\n    if (!IsSchema(schema.additionalProperties)) {\n        return Default(schema, path, knownProperties);\n    }\n    const unknownKeys = Object.getOwnPropertyNames(knownProperties);\n    const additionalProperties = schema.additionalProperties;\n    const unknownProperties = { ...knownProperties };\n    for (const key of unknownKeys)\n        if (!knownKeys.includes(key)) {\n            unknownProperties[key] = Default(additionalProperties, `${path}/${key}`, unknownProperties[key]);\n        }\n    return Default(schema, path, unknownProperties);\n}\n// prettier-ignore\nfunction FromRecord(schema, references, path, value) {\n    if (!IsObject(value))\n        return Default(schema, path, value);\n    const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];\n    const knownKeys = new RegExp(pattern);\n    const knownProperties = { ...value };\n    for (const key of Object.getOwnPropertyNames(value))\n        if (knownKeys.test(key)) {\n            knownProperties[key] = Visit(schema.patternProperties[pattern], references, `${path}/${key}`, knownProperties[key]);\n        }\n    if (!IsSchema(schema.additionalProperties)) {\n        return Default(schema, path, knownProperties);\n    }\n    const unknownKeys = Object.getOwnPropertyNames(knownProperties);\n    const additionalProperties = schema.additionalProperties;\n    const unknownProperties = { ...knownProperties };\n    for (const key of unknownKeys)\n        if (!knownKeys.test(key)) {\n            unknownProperties[key] = Default(additionalProperties, `${path}/${key}`, unknownProperties[key]);\n        }\n    return Default(schema, path, unknownProperties);\n}\n// prettier-ignore\nfunction FromRef(schema, references, path, value) {\n    const target = Deref(schema, references);\n    return Default(schema, path, Visit(target, references, path, value));\n}\n// prettier-ignore\nfunction FromThis(schema, references, path, value) {\n    const target = Deref(schema, references);\n    return Default(schema, path, Visit(target, references, path, value));\n}\n// prettier-ignore\nfunction FromTuple(schema, references, path, value) {\n    return (IsArray(value) && IsArray(schema.items))\n        ? Default(schema, path, schema.items.map((schema, index) => Visit(schema, references, `${path}/${index}`, value[index])))\n        : Default(schema, path, value);\n}\n// prettier-ignore\nfunction FromUnion(schema, references, path, value) {\n    for (const subschema of schema.anyOf) {\n        if (!Check(subschema, references, value))\n            continue;\n        // note: ensure interior is decoded first\n        const decoded = Visit(subschema, references, path, value);\n        return Default(schema, path, decoded);\n    }\n    return Default(schema, path, value);\n}\n// prettier-ignore\nfunction Visit(schema, references, path, value) {\n    const references_ = Pushref(schema, references);\n    const schema_ = schema;\n    switch (schema[Kind]) {\n        case 'Array':\n            return FromArray(schema_, references_, path, value);\n        case 'Import':\n            return FromImport(schema_, references_, path, value);\n        case 'Intersect':\n            return FromIntersect(schema_, references_, path, value);\n        case 'Not':\n            return FromNot(schema_, references_, path, value);\n        case 'Object':\n            return FromObject(schema_, references_, path, value);\n        case 'Record':\n            return FromRecord(schema_, references_, path, value);\n        case 'Ref':\n            return FromRef(schema_, references_, path, value);\n        case 'Symbol':\n            return Default(schema_, path, value);\n        case 'This':\n            return FromThis(schema_, references_, path, value);\n        case 'Tuple':\n            return FromTuple(schema_, references_, path, value);\n        case 'Union':\n            return FromUnion(schema_, references_, path, value);\n        default:\n            return Default(schema_, path, value);\n    }\n}\n/**\n * `[Internal]` Decodes the value and returns the result. This function requires that\n * the caller `Check` the value before use. Passing unchecked values may result in\n * undefined behavior. Refer to the `Value.Decode()` for implementation details.\n */\nexport function TransformDecode(schema, references, value) {\n    return Visit(schema, references, '', value);\n}\n", "import { TypeSystemPolicy } from '../../system/policy.mjs';\nimport { Kind, TransformKind } from '../../type/symbols/index.mjs';\nimport { TypeBoxError } from '../../type/error/index.mjs';\nimport { KeyOfPropertyKeys, KeyOfPropertyEntries } from '../../type/keyof/index.mjs';\nimport { Deref, Pushref } from '../deref/index.mjs';\nimport { Check } from '../check/index.mjs';\n// ------------------------------------------------------------------\n// ValueGuard\n// ------------------------------------------------------------------\nimport { HasPropertyKey, IsObject, IsArray, IsValueType, IsUndefined as IsUndefinedValue } from '../guard/index.mjs';\n// ------------------------------------------------------------------\n// KindGuard\n// ------------------------------------------------------------------\nimport { IsTransform, IsSchema, IsUndefined } from '../../type/guard/kind.mjs';\n// ------------------------------------------------------------------\n// Errors\n// ------------------------------------------------------------------\n// prettier-ignore\nexport class TransformEncodeCheckError extends TypeBoxError {\n    constructor(schema, value, error) {\n        super(`The encoded value does not match the expected schema`);\n        this.schema = schema;\n        this.value = value;\n        this.error = error;\n    }\n}\n// prettier-ignore\nexport class TransformEncodeError extends TypeBoxError {\n    constructor(schema, path, value, error) {\n        super(`${error instanceof Error ? error.message : 'Unknown error'}`);\n        this.schema = schema;\n        this.path = path;\n        this.value = value;\n        this.error = error;\n    }\n}\n// ------------------------------------------------------------------\n// Encode\n// ------------------------------------------------------------------\n// prettier-ignore\nfunction Default(schema, path, value) {\n    try {\n        return IsTransform(schema) ? schema[TransformKind].Encode(value) : value;\n    }\n    catch (error) {\n        throw new TransformEncodeError(schema, path, value, error);\n    }\n}\n// prettier-ignore\nfunction FromArray(schema, references, path, value) {\n    const defaulted = Default(schema, path, value);\n    return IsArray(defaulted)\n        ? defaulted.map((value, index) => Visit(schema.items, references, `${path}/${index}`, value))\n        : defaulted;\n}\n// prettier-ignore\nfunction FromImport(schema, references, path, value) {\n    const definitions = globalThis.Object.values(schema.$defs);\n    const target = schema.$defs[schema.$ref];\n    const transform = schema[TransformKind];\n    // Note: we need to re-spec the target as TSchema + [TransformKind]\n    const transformTarget = { [TransformKind]: transform, ...target };\n    return Visit(transformTarget, [...references, ...definitions], path, value);\n}\n// prettier-ignore\nfunction FromIntersect(schema, references, path, value) {\n    const defaulted = Default(schema, path, value);\n    if (!IsObject(value) || IsValueType(value))\n        return defaulted;\n    const knownEntries = KeyOfPropertyEntries(schema);\n    const knownKeys = knownEntries.map(entry => entry[0]);\n    const knownProperties = { ...defaulted };\n    for (const [knownKey, knownSchema] of knownEntries)\n        if (knownKey in knownProperties) {\n            knownProperties[knownKey] = Visit(knownSchema, references, `${path}/${knownKey}`, knownProperties[knownKey]);\n        }\n    if (!IsTransform(schema.unevaluatedProperties)) {\n        return knownProperties;\n    }\n    const unknownKeys = Object.getOwnPropertyNames(knownProperties);\n    const unevaluatedProperties = schema.unevaluatedProperties;\n    const properties = { ...knownProperties };\n    for (const key of unknownKeys)\n        if (!knownKeys.includes(key)) {\n            properties[key] = Default(unevaluatedProperties, `${path}/${key}`, properties[key]);\n        }\n    return properties;\n}\n// prettier-ignore\nfunction FromNot(schema, references, path, value) {\n    return Default(schema.not, path, Default(schema, path, value));\n}\n// prettier-ignore\nfunction FromObject(schema, references, path, value) {\n    const defaulted = Default(schema, path, value);\n    if (!IsObject(defaulted))\n        return defaulted;\n    const knownKeys = KeyOfPropertyKeys(schema);\n    const knownProperties = { ...defaulted };\n    for (const key of knownKeys) {\n        if (!HasPropertyKey(knownProperties, key))\n            continue;\n        // if the property value is undefined, but the target is not, nor does it satisfy exact optional \n        // property policy, then we need to continue. This is a special case for optional property handling \n        // where a transforms wrapped in a optional modifiers should not run.\n        if (IsUndefinedValue(knownProperties[key]) && (!IsUndefined(schema.properties[key]) ||\n            TypeSystemPolicy.IsExactOptionalProperty(knownProperties, key)))\n            continue;\n        // encode property\n        knownProperties[key] = Visit(schema.properties[key], references, `${path}/${key}`, knownProperties[key]);\n    }\n    if (!IsSchema(schema.additionalProperties)) {\n        return knownProperties;\n    }\n    const unknownKeys = Object.getOwnPropertyNames(knownProperties);\n    const additionalProperties = schema.additionalProperties;\n    const properties = { ...knownProperties };\n    for (const key of unknownKeys)\n        if (!knownKeys.includes(key)) {\n            properties[key] = Default(additionalProperties, `${path}/${key}`, properties[key]);\n        }\n    return properties;\n}\n// prettier-ignore\nfunction FromRecord(schema, references, path, value) {\n    const defaulted = Default(schema, path, value);\n    if (!IsObject(value))\n        return defaulted;\n    const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];\n    const knownKeys = new RegExp(pattern);\n    const knownProperties = { ...defaulted };\n    for (const key of Object.getOwnPropertyNames(value))\n        if (knownKeys.test(key)) {\n            knownProperties[key] = Visit(schema.patternProperties[pattern], references, `${path}/${key}`, knownProperties[key]);\n        }\n    if (!IsSchema(schema.additionalProperties)) {\n        return knownProperties;\n    }\n    const unknownKeys = Object.getOwnPropertyNames(knownProperties);\n    const additionalProperties = schema.additionalProperties;\n    const properties = { ...knownProperties };\n    for (const key of unknownKeys)\n        if (!knownKeys.test(key)) {\n            properties[key] = Default(additionalProperties, `${path}/${key}`, properties[key]);\n        }\n    return properties;\n}\n// prettier-ignore\nfunction FromRef(schema, references, path, value) {\n    const target = Deref(schema, references);\n    const resolved = Visit(target, references, path, value);\n    return Default(schema, path, resolved);\n}\n// prettier-ignore\nfunction FromThis(schema, references, path, value) {\n    const target = Deref(schema, references);\n    const resolved = Visit(target, references, path, value);\n    return Default(schema, path, resolved);\n}\n// prettier-ignore\nfunction FromTuple(schema, references, path, value) {\n    const value1 = Default(schema, path, value);\n    return IsArray(schema.items) ? schema.items.map((schema, index) => Visit(schema, references, `${path}/${index}`, value1[index])) : [];\n}\n// prettier-ignore\nfunction FromUnion(schema, references, path, value) {\n    // test value against union variants\n    for (const subschema of schema.anyOf) {\n        if (!Check(subschema, references, value))\n            continue;\n        const value1 = Visit(subschema, references, path, value);\n        return Default(schema, path, value1);\n    }\n    // test transformed value against union variants\n    for (const subschema of schema.anyOf) {\n        const value1 = Visit(subschema, references, path, value);\n        if (!Check(schema, references, value1))\n            continue;\n        return Default(schema, path, value1);\n    }\n    return Default(schema, path, value);\n}\n// prettier-ignore\nfunction Visit(schema, references, path, value) {\n    const references_ = Pushref(schema, references);\n    const schema_ = schema;\n    switch (schema[Kind]) {\n        case 'Array':\n            return FromArray(schema_, references_, path, value);\n        case 'Import':\n            return FromImport(schema_, references_, path, value);\n        case 'Intersect':\n            return FromIntersect(schema_, references_, path, value);\n        case 'Not':\n            return FromNot(schema_, references_, path, value);\n        case 'Object':\n            return FromObject(schema_, references_, path, value);\n        case 'Record':\n            return FromRecord(schema_, references_, path, value);\n        case 'Ref':\n            return FromRef(schema_, references_, path, value);\n        case 'This':\n            return FromThis(schema_, references_, path, value);\n        case 'Tuple':\n            return FromTuple(schema_, references_, path, value);\n        case 'Union':\n            return FromUnion(schema_, references_, path, value);\n        default:\n            return Default(schema_, path, value);\n    }\n}\n/**\n * `[Internal]` Encodes the value and returns the result. This function expects the\n * caller to pass a statically checked value. This function does not check the encoded\n * result, meaning the result should be passed to `Check` before use. Refer to the\n * `Value.Encode()` function for implementation details.\n */\nexport function TransformEncode(schema, references, value) {\n    return Visit(schema, references, '', value);\n}\n", "import { Deref, Pushref } from '../deref/index.mjs';\nimport { Kind } from '../../type/symbols/index.mjs';\n// ------------------------------------------------------------------\n// KindGuard\n// ------------------------------------------------------------------\nimport { IsTransform, IsSchema } from '../../type/guard/kind.mjs';\n// ------------------------------------------------------------------\n// ValueGuard\n// ------------------------------------------------------------------\nimport { IsUndefined } from '../guard/index.mjs';\n// prettier-ignore\nfunction FromArray(schema, references) {\n    return IsTransform(schema) || Visit(schema.items, references);\n}\n// prettier-ignore\nfunction FromAsyncIterator(schema, references) {\n    return IsTransform(schema) || Visit(schema.items, references);\n}\n// prettier-ignore\nfunction FromConstructor(schema, references) {\n    return IsTransform(schema) || Visit(schema.returns, references) || schema.parameters.some((schema) => Visit(schema, references));\n}\n// prettier-ignore\nfunction FromFunction(schema, references) {\n    return IsTransform(schema) || Visit(schema.returns, references) || schema.parameters.some((schema) => Visit(schema, references));\n}\n// prettier-ignore\nfunction FromIntersect(schema, references) {\n    return IsTransform(schema) || IsTransform(schema.unevaluatedProperties) || schema.allOf.some((schema) => Visit(schema, references));\n}\n// prettier-ignore\nfunction FromIterator(schema, references) {\n    return IsTransform(schema) || Visit(schema.items, references);\n}\n// prettier-ignore\nfunction FromNot(schema, references) {\n    return IsTransform(schema) || Visit(schema.not, references);\n}\n// prettier-ignore\nfunction FromObject(schema, references) {\n    return (IsTransform(schema) ||\n        Object.values(schema.properties).some((schema) => Visit(schema, references)) ||\n        (IsSchema(schema.additionalProperties) && Visit(schema.additionalProperties, references)));\n}\n// prettier-ignore\nfunction FromPromise(schema, references) {\n    return IsTransform(schema) || Visit(schema.item, references);\n}\n// prettier-ignore\nfunction FromRecord(schema, references) {\n    const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];\n    const property = schema.patternProperties[pattern];\n    return IsTransform(schema) || Visit(property, references) || (IsSchema(schema.additionalProperties) && IsTransform(schema.additionalProperties));\n}\n// prettier-ignore\nfunction FromRef(schema, references) {\n    if (IsTransform(schema))\n        return true;\n    return Visit(Deref(schema, references), references);\n}\n// prettier-ignore\nfunction FromThis(schema, references) {\n    if (IsTransform(schema))\n        return true;\n    return Visit(Deref(schema, references), references);\n}\n// prettier-ignore\nfunction FromTuple(schema, references) {\n    return IsTransform(schema) || (!IsUndefined(schema.items) && schema.items.some((schema) => Visit(schema, references)));\n}\n// prettier-ignore\nfunction FromUnion(schema, references) {\n    return IsTransform(schema) || schema.anyOf.some((schema) => Visit(schema, references));\n}\n// prettier-ignore\nfunction Visit(schema, references) {\n    const references_ = Pushref(schema, references);\n    const schema_ = schema;\n    if (schema.$id && visited.has(schema.$id))\n        return false;\n    if (schema.$id)\n        visited.add(schema.$id);\n    switch (schema[Kind]) {\n        case 'Array':\n            return FromArray(schema_, references_);\n        case 'AsyncIterator':\n            return FromAsyncIterator(schema_, references_);\n        case 'Constructor':\n            return FromConstructor(schema_, references_);\n        case 'Function':\n            return FromFunction(schema_, references_);\n        case 'Intersect':\n            return FromIntersect(schema_, references_);\n        case 'Iterator':\n            return FromIterator(schema_, references_);\n        case 'Not':\n            return FromNot(schema_, references_);\n        case 'Object':\n            return FromObject(schema_, references_);\n        case 'Promise':\n            return FromPromise(schema_, references_);\n        case 'Record':\n            return FromRecord(schema_, references_);\n        case 'Ref':\n            return FromRef(schema_, references_);\n        case 'This':\n            return FromThis(schema_, references_);\n        case 'Tuple':\n            return FromTuple(schema_, references_);\n        case 'Union':\n            return FromUnion(schema_, references_);\n        default:\n            return IsTransform(schema);\n    }\n}\nconst visited = new Set();\n/** Returns true if this schema contains a transform codec */\nexport function HasTransform(schema, references) {\n    visited.clear();\n    return Visit(schema, references);\n}\n", "import { TransformEncode, TransformDecode, HasTransform, TransformDecodeCheckError, TransformEncodeCheckError } from '../value/transform/index.mjs';\nimport { Errors } from '../errors/index.mjs';\nimport { TypeSystemPolicy } from '../system/index.mjs';\nimport { TypeBoxError } from '../type/error/index.mjs';\nimport { Deref } from '../value/deref/index.mjs';\nimport { Hash } from '../value/hash/index.mjs';\nimport { Kind } from '../type/symbols/index.mjs';\nimport { TypeRegistry, FormatRegistry } from '../type/registry/index.mjs';\nimport { KeyOfPattern } from '../type/keyof/index.mjs';\nimport { ExtendsUndefinedCheck } from '../type/extends/extends-undefined.mjs';\nimport { Never } from '../type/never/index.mjs';\nimport { Ref } from '../type/ref/index.mjs';\n// ------------------------------------------------------------------\n// ValueGuard\n// ------------------------------------------------------------------\nimport { IsArray, IsString, IsNumber, IsBigInt } from '../value/guard/index.mjs';\n// ------------------------------------------------------------------\n// TypeGuard\n// ------------------------------------------------------------------\nimport { IsSchema } from '../type/guard/type.mjs';\n// ------------------------------------------------------------------\n// TypeCheck\n// ------------------------------------------------------------------\nexport class TypeCheck {\n    constructor(schema, references, checkFunc, code) {\n        this.schema = schema;\n        this.references = references;\n        this.checkFunc = checkFunc;\n        this.code = code;\n        this.hasTransform = HasTransform(schema, references);\n    }\n    /** Returns the generated assertion code used to validate this type. */\n    Code() {\n        return this.code;\n    }\n    /** Returns the schema type used to validate */\n    Schema() {\n        return this.schema;\n    }\n    /** Returns reference types used to validate */\n    References() {\n        return this.references;\n    }\n    /** Returns an iterator for each error in this value. */\n    Errors(value) {\n        return Errors(this.schema, this.references, value);\n    }\n    /** Returns true if the value matches the compiled type. */\n    Check(value) {\n        return this.checkFunc(value);\n    }\n    /** Decodes a value or throws if error */\n    Decode(value) {\n        if (!this.checkFunc(value))\n            throw new TransformDecodeCheckError(this.schema, value, this.Errors(value).First());\n        return (this.hasTransform ? TransformDecode(this.schema, this.references, value) : value);\n    }\n    /** Encodes a value or throws if error */\n    Encode(value) {\n        const encoded = this.hasTransform ? TransformEncode(this.schema, this.references, value) : value;\n        if (!this.checkFunc(encoded))\n            throw new TransformEncodeCheckError(this.schema, value, this.Errors(value).First());\n        return encoded;\n    }\n}\n// ------------------------------------------------------------------\n// Character\n// ------------------------------------------------------------------\nvar Character;\n(function (Character) {\n    function DollarSign(code) {\n        return code === 36;\n    }\n    Character.DollarSign = DollarSign;\n    function IsUnderscore(code) {\n        return code === 95;\n    }\n    Character.IsUnderscore = IsUnderscore;\n    function IsAlpha(code) {\n        return (code >= 65 && code <= 90) || (code >= 97 && code <= 122);\n    }\n    Character.IsAlpha = IsAlpha;\n    function IsNumeric(code) {\n        return code >= 48 && code <= 57;\n    }\n    Character.IsNumeric = IsNumeric;\n})(Character || (Character = {}));\n// ------------------------------------------------------------------\n// MemberExpression\n// ------------------------------------------------------------------\nvar MemberExpression;\n(function (MemberExpression) {\n    function IsFirstCharacterNumeric(value) {\n        if (value.length === 0)\n            return false;\n        return Character.IsNumeric(value.charCodeAt(0));\n    }\n    function IsAccessor(value) {\n        if (IsFirstCharacterNumeric(value))\n            return false;\n        for (let i = 0; i < value.length; i++) {\n            const code = value.charCodeAt(i);\n            const check = Character.IsAlpha(code) || Character.IsNumeric(code) || Character.DollarSign(code) || Character.IsUnderscore(code);\n            if (!check)\n                return false;\n        }\n        return true;\n    }\n    function EscapeHyphen(key) {\n        return key.replace(/'/g, \"\\\\'\");\n    }\n    function Encode(object, key) {\n        return IsAccessor(key) ? `${object}.${key}` : `${object}['${EscapeHyphen(key)}']`;\n    }\n    MemberExpression.Encode = Encode;\n})(MemberExpression || (MemberExpression = {}));\n// ------------------------------------------------------------------\n// Identifier\n// ------------------------------------------------------------------\nvar Identifier;\n(function (Identifier) {\n    function Encode($id) {\n        const buffer = [];\n        for (let i = 0; i < $id.length; i++) {\n            const code = $id.charCodeAt(i);\n            if (Character.IsNumeric(code) || Character.IsAlpha(code)) {\n                buffer.push($id.charAt(i));\n            }\n            else {\n                buffer.push(`_${code}_`);\n            }\n        }\n        return buffer.join('').replace(/__/g, '_');\n    }\n    Identifier.Encode = Encode;\n})(Identifier || (Identifier = {}));\n// ------------------------------------------------------------------\n// LiteralString\n// ------------------------------------------------------------------\nvar LiteralString;\n(function (LiteralString) {\n    function Escape(content) {\n        return content.replace(/'/g, \"\\\\'\");\n    }\n    LiteralString.Escape = Escape;\n})(LiteralString || (LiteralString = {}));\n// ------------------------------------------------------------------\n// Errors\n// ------------------------------------------------------------------\nexport class TypeCompilerUnknownTypeError extends TypeBoxError {\n    constructor(schema) {\n        super('Unknown type');\n        this.schema = schema;\n    }\n}\nexport class TypeCompilerTypeGuardError extends TypeBoxError {\n    constructor(schema) {\n        super('Preflight validation check failed to guard for the given schema');\n        this.schema = schema;\n    }\n}\n// ------------------------------------------------------------------\n// Policy\n// ------------------------------------------------------------------\nexport var Policy;\n(function (Policy) {\n    function IsExactOptionalProperty(value, key, expression) {\n        return TypeSystemPolicy.ExactOptionalPropertyTypes ? `('${key}' in ${value} ? ${expression} : true)` : `(${MemberExpression.Encode(value, key)} !== undefined ? ${expression} : true)`;\n    }\n    Policy.IsExactOptionalProperty = IsExactOptionalProperty;\n    function IsObjectLike(value) {\n        return !TypeSystemPolicy.AllowArrayObject ? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}))` : `(typeof ${value} === 'object' && ${value} !== null)`;\n    }\n    Policy.IsObjectLike = IsObjectLike;\n    function IsRecordLike(value) {\n        return !TypeSystemPolicy.AllowArrayObject\n            ? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}) && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))`\n            : `(typeof ${value} === 'object' && ${value} !== null && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))`;\n    }\n    Policy.IsRecordLike = IsRecordLike;\n    function IsNumberLike(value) {\n        return TypeSystemPolicy.AllowNaN ? `typeof ${value} === 'number'` : `Number.isFinite(${value})`;\n    }\n    Policy.IsNumberLike = IsNumberLike;\n    function IsVoidLike(value) {\n        return TypeSystemPolicy.AllowNullVoid ? `(${value} === undefined || ${value} === null)` : `${value} === undefined`;\n    }\n    Policy.IsVoidLike = IsVoidLike;\n})(Policy || (Policy = {}));\n/** Compiles Types for Runtime Type Checking */\nexport var TypeCompiler;\n(function (TypeCompiler) {\n    // ----------------------------------------------------------------\n    // Guards\n    // ----------------------------------------------------------------\n    function IsAnyOrUnknown(schema) {\n        return schema[Kind] === 'Any' || schema[Kind] === 'Unknown';\n    }\n    // ----------------------------------------------------------------\n    // Types\n    // ----------------------------------------------------------------\n    function* FromAny(schema, references, value) {\n        yield 'true';\n    }\n    function* FromArray(schema, references, value) {\n        yield `Array.isArray(${value})`;\n        const [parameter, accumulator] = [CreateParameter('value', 'any'), CreateParameter('acc', 'number')];\n        if (IsNumber(schema.maxItems))\n            yield `${value}.length <= ${schema.maxItems}`;\n        if (IsNumber(schema.minItems))\n            yield `${value}.length >= ${schema.minItems}`;\n        const elementExpression = CreateExpression(schema.items, references, 'value');\n        yield `${value}.every((${parameter}) => ${elementExpression})`;\n        if (IsSchema(schema.contains) || IsNumber(schema.minContains) || IsNumber(schema.maxContains)) {\n            const containsSchema = IsSchema(schema.contains) ? schema.contains : Never();\n            const checkExpression = CreateExpression(containsSchema, references, 'value');\n            const checkMinContains = IsNumber(schema.minContains) ? [`(count >= ${schema.minContains})`] : [];\n            const checkMaxContains = IsNumber(schema.maxContains) ? [`(count <= ${schema.maxContains})`] : [];\n            const checkCount = `const count = value.reduce((${accumulator}, ${parameter}) => ${checkExpression} ? acc + 1 : acc, 0)`;\n            const check = [`(count > 0)`, ...checkMinContains, ...checkMaxContains].join(' && ');\n            yield `((${parameter}) => { ${checkCount}; return ${check}})(${value})`;\n        }\n        if (schema.uniqueItems === true) {\n            const check = `const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true`;\n            const block = `const set = new Set(); for(const element of value) { ${check} }`;\n            yield `((${parameter}) => { ${block} )(${value})`;\n        }\n    }\n    function* FromAsyncIterator(schema, references, value) {\n        yield `(typeof value === 'object' && Symbol.asyncIterator in ${value})`;\n    }\n    function* FromBigInt(schema, references, value) {\n        yield `(typeof ${value} === 'bigint')`;\n        if (IsBigInt(schema.exclusiveMaximum))\n            yield `${value} < BigInt(${schema.exclusiveMaximum})`;\n        if (IsBigInt(schema.exclusiveMinimum))\n            yield `${value} > BigInt(${schema.exclusiveMinimum})`;\n        if (IsBigInt(schema.maximum))\n            yield `${value} <= BigInt(${schema.maximum})`;\n        if (IsBigInt(schema.minimum))\n            yield `${value} >= BigInt(${schema.minimum})`;\n        if (IsBigInt(schema.multipleOf))\n            yield `(${value} % BigInt(${schema.multipleOf})) === 0`;\n    }\n    function* FromBoolean(schema, references, value) {\n        yield `(typeof ${value} === 'boolean')`;\n    }\n    function* FromConstructor(schema, references, value) {\n        yield* Visit(schema.returns, references, `${value}.prototype`);\n    }\n    function* FromDate(schema, references, value) {\n        yield `(${value} instanceof Date) && Number.isFinite(${value}.getTime())`;\n        if (IsNumber(schema.exclusiveMaximumTimestamp))\n            yield `${value}.getTime() < ${schema.exclusiveMaximumTimestamp}`;\n        if (IsNumber(schema.exclusiveMinimumTimestamp))\n            yield `${value}.getTime() > ${schema.exclusiveMinimumTimestamp}`;\n        if (IsNumber(schema.maximumTimestamp))\n            yield `${value}.getTime() <= ${schema.maximumTimestamp}`;\n        if (IsNumber(schema.minimumTimestamp))\n            yield `${value}.getTime() >= ${schema.minimumTimestamp}`;\n        if (IsNumber(schema.multipleOfTimestamp))\n            yield `(${value}.getTime() % ${schema.multipleOfTimestamp}) === 0`;\n    }\n    function* FromFunction(schema, references, value) {\n        yield `(typeof ${value} === 'function')`;\n    }\n    function* FromImport(schema, references, value) {\n        const members = globalThis.Object.getOwnPropertyNames(schema.$defs).reduce((result, key) => {\n            return [...result, schema.$defs[key]];\n        }, []);\n        yield* Visit(Ref(schema.$ref), [...references, ...members], value);\n    }\n    function* FromInteger(schema, references, value) {\n        yield `Number.isInteger(${value})`;\n        if (IsNumber(schema.exclusiveMaximum))\n            yield `${value} < ${schema.exclusiveMaximum}`;\n        if (IsNumber(schema.exclusiveMinimum))\n            yield `${value} > ${schema.exclusiveMinimum}`;\n        if (IsNumber(schema.maximum))\n            yield `${value} <= ${schema.maximum}`;\n        if (IsNumber(schema.minimum))\n            yield `${value} >= ${schema.minimum}`;\n        if (IsNumber(schema.multipleOf))\n            yield `(${value} % ${schema.multipleOf}) === 0`;\n    }\n    function* FromIntersect(schema, references, value) {\n        const check1 = schema.allOf.map((schema) => CreateExpression(schema, references, value)).join(' && ');\n        if (schema.unevaluatedProperties === false) {\n            const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema))};`);\n            const check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key))`;\n            yield `(${check1} && ${check2})`;\n        }\n        else if (IsSchema(schema.unevaluatedProperties)) {\n            const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema))};`);\n            const check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key) || ${CreateExpression(schema.unevaluatedProperties, references, `${value}[key]`)})`;\n            yield `(${check1} && ${check2})`;\n        }\n        else {\n            yield `(${check1})`;\n        }\n    }\n    function* FromIterator(schema, references, value) {\n        yield `(typeof value === 'object' && Symbol.iterator in ${value})`;\n    }\n    function* FromLiteral(schema, references, value) {\n        if (typeof schema.const === 'number' || typeof schema.const === 'boolean') {\n            yield `(${value} === ${schema.const})`;\n        }\n        else {\n            yield `(${value} === '${LiteralString.Escape(schema.const)}')`;\n        }\n    }\n    function* FromNever(schema, references, value) {\n        yield `false`;\n    }\n    function* FromNot(schema, references, value) {\n        const expression = CreateExpression(schema.not, references, value);\n        yield `(!${expression})`;\n    }\n    function* FromNull(schema, references, value) {\n        yield `(${value} === null)`;\n    }\n    function* FromNumber(schema, references, value) {\n        yield Policy.IsNumberLike(value);\n        if (IsNumber(schema.exclusiveMaximum))\n            yield `${value} < ${schema.exclusiveMaximum}`;\n        if (IsNumber(schema.exclusiveMinimum))\n            yield `${value} > ${schema.exclusiveMinimum}`;\n        if (IsNumber(schema.maximum))\n            yield `${value} <= ${schema.maximum}`;\n        if (IsNumber(schema.minimum))\n            yield `${value} >= ${schema.minimum}`;\n        if (IsNumber(schema.multipleOf))\n            yield `(${value} % ${schema.multipleOf}) === 0`;\n    }\n    function* FromObject(schema, references, value) {\n        yield Policy.IsObjectLike(value);\n        if (IsNumber(schema.minProperties))\n            yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`;\n        if (IsNumber(schema.maxProperties))\n            yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`;\n        const knownKeys = Object.getOwnPropertyNames(schema.properties);\n        for (const knownKey of knownKeys) {\n            const memberExpression = MemberExpression.Encode(value, knownKey);\n            const property = schema.properties[knownKey];\n            if (schema.required && schema.required.includes(knownKey)) {\n                yield* Visit(property, references, memberExpression);\n                if (ExtendsUndefinedCheck(property) || IsAnyOrUnknown(property))\n                    yield `('${knownKey}' in ${value})`;\n            }\n            else {\n                const expression = CreateExpression(property, references, memberExpression);\n                yield Policy.IsExactOptionalProperty(value, knownKey, expression);\n            }\n        }\n        if (schema.additionalProperties === false) {\n            if (schema.required && schema.required.length === knownKeys.length) {\n                yield `Object.getOwnPropertyNames(${value}).length === ${knownKeys.length}`;\n            }\n            else {\n                const keys = `[${knownKeys.map((key) => `'${key}'`).join(', ')}]`;\n                yield `Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key))`;\n            }\n        }\n        if (typeof schema.additionalProperties === 'object') {\n            const expression = CreateExpression(schema.additionalProperties, references, `${value}[key]`);\n            const keys = `[${knownKeys.map((key) => `'${key}'`).join(', ')}]`;\n            yield `(Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key) || ${expression}))`;\n        }\n    }\n    function* FromPromise(schema, references, value) {\n        yield `(typeof value === 'object' && typeof ${value}.then === 'function')`;\n    }\n    function* FromRecord(schema, references, value) {\n        yield Policy.IsRecordLike(value);\n        if (IsNumber(schema.minProperties))\n            yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`;\n        if (IsNumber(schema.maxProperties))\n            yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`;\n        const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];\n        const variable = CreateVariable(`${new RegExp(patternKey)}`);\n        const check1 = CreateExpression(patternSchema, references, 'value');\n        const check2 = IsSchema(schema.additionalProperties) ? CreateExpression(schema.additionalProperties, references, value) : schema.additionalProperties === false ? 'false' : 'true';\n        const expression = `(${variable}.test(key) ? ${check1} : ${check2})`;\n        yield `(Object.entries(${value}).every(([key, value]) => ${expression}))`;\n    }\n    function* FromRef(schema, references, value) {\n        const target = Deref(schema, references);\n        // Reference: If we have seen this reference before we can just yield and return the function call.\n        // If this isn't the case we defer to visit to generate and set the function for subsequent passes.\n        if (state.functions.has(schema.$ref))\n            return yield `${CreateFunctionName(schema.$ref)}(${value})`;\n        yield* Visit(target, references, value);\n    }\n    function* FromRegExp(schema, references, value) {\n        const variable = CreateVariable(`${new RegExp(schema.source, schema.flags)};`);\n        yield `(typeof ${value} === 'string')`;\n        if (IsNumber(schema.maxLength))\n            yield `${value}.length <= ${schema.maxLength}`;\n        if (IsNumber(schema.minLength))\n            yield `${value}.length >= ${schema.minLength}`;\n        yield `${variable}.test(${value})`;\n    }\n    function* FromString(schema, references, value) {\n        yield `(typeof ${value} === 'string')`;\n        if (IsNumber(schema.maxLength))\n            yield `${value}.length <= ${schema.maxLength}`;\n        if (IsNumber(schema.minLength))\n            yield `${value}.length >= ${schema.minLength}`;\n        if (schema.pattern !== undefined) {\n            const variable = CreateVariable(`${new RegExp(schema.pattern)};`);\n            yield `${variable}.test(${value})`;\n        }\n        if (schema.format !== undefined) {\n            yield `format('${schema.format}', ${value})`;\n        }\n    }\n    function* FromSymbol(schema, references, value) {\n        yield `(typeof ${value} === 'symbol')`;\n    }\n    function* FromTemplateLiteral(schema, references, value) {\n        yield `(typeof ${value} === 'string')`;\n        const variable = CreateVariable(`${new RegExp(schema.pattern)};`);\n        yield `${variable}.test(${value})`;\n    }\n    function* FromThis(schema, references, value) {\n        // Note: This types are assured to be hoisted prior to this call. Just yield the function.\n        yield `${CreateFunctionName(schema.$ref)}(${value})`;\n    }\n    function* FromTuple(schema, references, value) {\n        yield `Array.isArray(${value})`;\n        if (schema.items === undefined)\n            return yield `${value}.length === 0`;\n        yield `(${value}.length === ${schema.maxItems})`;\n        for (let i = 0; i < schema.items.length; i++) {\n            const expression = CreateExpression(schema.items[i], references, `${value}[${i}]`);\n            yield `${expression}`;\n        }\n    }\n    function* FromUndefined(schema, references, value) {\n        yield `${value} === undefined`;\n    }\n    function* FromUnion(schema, references, value) {\n        const expressions = schema.anyOf.map((schema) => CreateExpression(schema, references, value));\n        yield `(${expressions.join(' || ')})`;\n    }\n    function* FromUint8Array(schema, references, value) {\n        yield `${value} instanceof Uint8Array`;\n        if (IsNumber(schema.maxByteLength))\n            yield `(${value}.length <= ${schema.maxByteLength})`;\n        if (IsNumber(schema.minByteLength))\n            yield `(${value}.length >= ${schema.minByteLength})`;\n    }\n    function* FromUnknown(schema, references, value) {\n        yield 'true';\n    }\n    function* FromVoid(schema, references, value) {\n        yield Policy.IsVoidLike(value);\n    }\n    function* FromKind(schema, references, value) {\n        const instance = state.instances.size;\n        state.instances.set(instance, schema);\n        yield `kind('${schema[Kind]}', ${instance}, ${value})`;\n    }\n    function* Visit(schema, references, value, useHoisting = true) {\n        const references_ = IsString(schema.$id) ? [...references, schema] : references;\n        const schema_ = schema;\n        // --------------------------------------------------------------\n        // Hoisting\n        // --------------------------------------------------------------\n        if (useHoisting && IsString(schema.$id)) {\n            const functionName = CreateFunctionName(schema.$id);\n            if (state.functions.has(functionName)) {\n                return yield `${functionName}(${value})`;\n            }\n            else {\n                // Note: In the case of cyclic types, we need to create a 'functions' record\n                // to prevent infinitely re-visiting the CreateFunction. Subsequent attempts\n                // to visit will be caught by the above condition.\n                state.functions.set(functionName, '<deferred>');\n                const functionCode = CreateFunction(functionName, schema, references, 'value', false);\n                state.functions.set(functionName, functionCode);\n                return yield `${functionName}(${value})`;\n            }\n        }\n        switch (schema_[Kind]) {\n            case 'Any':\n                return yield* FromAny(schema_, references_, value);\n            case 'Array':\n                return yield* FromArray(schema_, references_, value);\n            case 'AsyncIterator':\n                return yield* FromAsyncIterator(schema_, references_, value);\n            case 'BigInt':\n                return yield* FromBigInt(schema_, references_, value);\n            case 'Boolean':\n                return yield* FromBoolean(schema_, references_, value);\n            case 'Constructor':\n                return yield* FromConstructor(schema_, references_, value);\n            case 'Date':\n                return yield* FromDate(schema_, references_, value);\n            case 'Function':\n                return yield* FromFunction(schema_, references_, value);\n            case 'Import':\n                return yield* FromImport(schema_, references_, value);\n            case 'Integer':\n                return yield* FromInteger(schema_, references_, value);\n            case 'Intersect':\n                return yield* FromIntersect(schema_, references_, value);\n            case 'Iterator':\n                return yield* FromIterator(schema_, references_, value);\n            case 'Literal':\n                return yield* FromLiteral(schema_, references_, value);\n            case 'Never':\n                return yield* FromNever(schema_, references_, value);\n            case 'Not':\n                return yield* FromNot(schema_, references_, value);\n            case 'Null':\n                return yield* FromNull(schema_, references_, value);\n            case 'Number':\n                return yield* FromNumber(schema_, references_, value);\n            case 'Object':\n                return yield* FromObject(schema_, references_, value);\n            case 'Promise':\n                return yield* FromPromise(schema_, references_, value);\n            case 'Record':\n                return yield* FromRecord(schema_, references_, value);\n            case 'Ref':\n                return yield* FromRef(schema_, references_, value);\n            case 'RegExp':\n                return yield* FromRegExp(schema_, references_, value);\n            case 'String':\n                return yield* FromString(schema_, references_, value);\n            case 'Symbol':\n                return yield* FromSymbol(schema_, references_, value);\n            case 'TemplateLiteral':\n                return yield* FromTemplateLiteral(schema_, references_, value);\n            case 'This':\n                return yield* FromThis(schema_, references_, value);\n            case 'Tuple':\n                return yield* FromTuple(schema_, references_, value);\n            case 'Undefined':\n                return yield* FromUndefined(schema_, references_, value);\n            case 'Union':\n                return yield* FromUnion(schema_, references_, value);\n            case 'Uint8Array':\n                return yield* FromUint8Array(schema_, references_, value);\n            case 'Unknown':\n                return yield* FromUnknown(schema_, references_, value);\n            case 'Void':\n                return yield* FromVoid(schema_, references_, value);\n            default:\n                if (!TypeRegistry.Has(schema_[Kind]))\n                    throw new TypeCompilerUnknownTypeError(schema);\n                return yield* FromKind(schema_, references_, value);\n        }\n    }\n    // ----------------------------------------------------------------\n    // Compiler State\n    // ----------------------------------------------------------------\n    // prettier-ignore\n    const state = {\n        language: 'javascript', // target language\n        functions: new Map(), // local functions\n        variables: new Map(), // local variables\n        instances: new Map() // exterior kind instances\n    };\n    // ----------------------------------------------------------------\n    // Compiler Factory\n    // ----------------------------------------------------------------\n    function CreateExpression(schema, references, value, useHoisting = true) {\n        return `(${[...Visit(schema, references, value, useHoisting)].join(' && ')})`;\n    }\n    function CreateFunctionName($id) {\n        return `check_${Identifier.Encode($id)}`;\n    }\n    function CreateVariable(expression) {\n        const variableName = `local_${state.variables.size}`;\n        state.variables.set(variableName, `const ${variableName} = ${expression}`);\n        return variableName;\n    }\n    function CreateFunction(name, schema, references, value, useHoisting = true) {\n        const [newline, pad] = ['\\n', (length) => ''.padStart(length, ' ')];\n        const parameter = CreateParameter('value', 'any');\n        const returns = CreateReturns('boolean');\n        const expression = [...Visit(schema, references, value, useHoisting)].map((expression) => `${pad(4)}${expression}`).join(` &&${newline}`);\n        return `function ${name}(${parameter})${returns} {${newline}${pad(2)}return (${newline}${expression}${newline}${pad(2)})\\n}`;\n    }\n    function CreateParameter(name, type) {\n        const annotation = state.language === 'typescript' ? `: ${type}` : '';\n        return `${name}${annotation}`;\n    }\n    function CreateReturns(type) {\n        return state.language === 'typescript' ? `: ${type}` : '';\n    }\n    // ----------------------------------------------------------------\n    // Compile\n    // ----------------------------------------------------------------\n    function Build(schema, references, options) {\n        const functionCode = CreateFunction('check', schema, references, 'value'); // will populate functions and variables\n        const parameter = CreateParameter('value', 'any');\n        const returns = CreateReturns('boolean');\n        const functions = [...state.functions.values()];\n        const variables = [...state.variables.values()];\n        // prettier-ignore\n        const checkFunction = IsString(schema.$id) // ensure top level schemas with $id's are hoisted\n            ? `return function check(${parameter})${returns} {\\n  return ${CreateFunctionName(schema.$id)}(value)\\n}`\n            : `return ${functionCode}`;\n        return [...variables, ...functions, checkFunction].join('\\n');\n    }\n    /** Generates the code used to assert this type and returns it as a string */\n    function Code(...args) {\n        const defaults = { language: 'javascript' };\n        // prettier-ignore\n        const [schema, references, options] = (args.length === 2 && IsArray(args[1]) ? [args[0], args[1], defaults] :\n            args.length === 2 && !IsArray(args[1]) ? [args[0], [], args[1]] :\n                args.length === 3 ? [args[0], args[1], args[2]] :\n                    args.length === 1 ? [args[0], [], defaults] :\n                        [null, [], defaults]);\n        // compiler-reset\n        state.language = options.language;\n        state.variables.clear();\n        state.functions.clear();\n        state.instances.clear();\n        if (!IsSchema(schema))\n            throw new TypeCompilerTypeGuardError(schema);\n        for (const schema of references)\n            if (!IsSchema(schema))\n                throw new TypeCompilerTypeGuardError(schema);\n        return Build(schema, references, options);\n    }\n    TypeCompiler.Code = Code;\n    /** Compiles a TypeBox type for optimal runtime type checking. Types must be valid TypeBox types of TSchema */\n    function Compile(schema, references = []) {\n        const generatedCode = Code(schema, references, { language: 'javascript' });\n        const compiledFunction = globalThis.Function('kind', 'format', 'hash', generatedCode);\n        const instances = new Map(state.instances);\n        function typeRegistryFunction(kind, instance, value) {\n            if (!TypeRegistry.Has(kind) || !instances.has(instance))\n                return false;\n            const checkFunc = TypeRegistry.Get(kind);\n            const schema = instances.get(instance);\n            return checkFunc(schema, value);\n        }\n        function formatRegistryFunction(format, value) {\n            if (!FormatRegistry.Has(format))\n                return false;\n            const checkFunc = FormatRegistry.Get(format);\n            return checkFunc(value);\n        }\n        function hashFunction(value) {\n            return Hash(value);\n        }\n        const checkFunction = compiledFunction(typeRegistryFunction, formatRegistryFunction, hashFunction);\n        return new TypeCheck(schema, references, checkFunction, generatedCode);\n    }\n    TypeCompiler.Compile = Compile;\n})(TypeCompiler || (TypeCompiler = {}));\n"],
  "mappings": "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",
  "names": ["value", "IsUndefined", "schema", "Default", "FromArray", "value", "Visit", "FromImport", "FromIntersect", "FromNot", "FromObject", "IsUndefined", "FromRecord", "FromRef", "FromThis", "FromTuple", "schema", "FromUnion", "FromArray", "Visit", "schema", "FromIntersect", "FromNot", "FromObject", "FromRecord", "FromRef", "FromThis", "FromTuple", "FromUnion", "Character", "MemberExpression", "Identifier", "LiteralString", "Policy", "TypeCompiler", "FromArray", "IsSchema", "FromAsyncIterator", "FromConstructor", "Visit", "FromFunction", "FromImport", "FromIntersect", "schema", "FromIterator", "FromNot", "FromObject", "FromPromise", "FromRecord", "FromRef", "FromThis", "FromTuple", "FromUnion", "expression"]
}
