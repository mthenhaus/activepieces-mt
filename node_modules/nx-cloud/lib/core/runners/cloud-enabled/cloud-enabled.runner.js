"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.cloudEnabledTasksRunner = void 0;
const fs_1 = require("fs");
const fs_extra_1 = require("fs-extra");
const path = require("path");
const path_1 = require("path");
const environment_1 = require("../../../utilities/environment");
const metric_logger_1 = require("../../../utilities/metric-logger");
const remove_trailing_slash_1 = require("../../../utilities/remove-trailing-slash");
const error_reporter_api_1 = require("../../api/error-reporter.api");
const e2e_encryption_1 = require("../../file-storage/e2e-encryption");
const file_storage_1 = require("../../file-storage/file-storage");
const end_of_run_message_1 = require("../../terminal-output/end-of-run-message");
const message_reporter_1 = require("../../terminal-output/message-reporter");
const output_obfuscator_1 = require("../../terminal-output/output-obfuscator");
const cloud_enabled_life_cycle_1 = require("./cloud-enabled-life-cycle");
const cloud_remote_cache_1 = require("./cloud-remote-cache");
const cloud_run_api_1 = require("./cloud-run.api");
const id_generator_1 = require("./id-generator");
const { output } = require('../../../utilities/nx-imports-light');
const { tasksRunner, cacheDirectory, } = require('../../../utilities/nx-imports');
function createApi(errors, options, runContext) {
    const machineInfo = (0, environment_1.getMachineInfo)();
    return new cloud_run_api_1.CloudRunApi(errors, runContext, options, machineInfo);
}
function storeTaskHashes(taskExecutions, directory, distributedExecutionId) {
    const hashes = JSON.stringify(taskExecutions.map((t) => ({
        taskId: t.taskId,
        hash: t.hash,
    })));
    if (environment_1.VERBOSE_LOGGING) {
        output.note({
            title: `Executed tasks with hashes: ${hashes}`,
        });
    }
    (0, fs_1.writeFileSync)(path.join(directory, `tasks-hashes-${distributedExecutionId}`), hashes);
}
/*
 * It can happen that a task is executed multiple times on an agent, say for DTE1 and DTE2.
 * When it runs for DTE2, it will be a local cache hit, so it will be marked as completed.
 * However, Nx won't upload an artifact to S3 in this case. Usually this isn't a problem,
 * cause the first DTE would have uploaded it. But if you are using a DTE, with a read-only token,
 * the uploaded artifact will have a different scoped hash.
 *
 * To address this: we are finding all local cache hits, and upload everything that has a put url.
 */
function storeLocalCacheHits(taskExecutions, remoteCache, nxCacheDirectory) {
    const hashes = taskExecutions
        .filter((t) => t.cacheStatus === 'local-cache-hit')
        .map((t) => t.hash);
    hashes.forEach((hash) => remoteCache.store(hash, nxCacheDirectory));
}
function onComplete(_a) {
    return __awaiter(this, arguments, void 0, function* ({ daemon, options, fileStorage, remoteCache, api, outputObfuscator, runStartTime, messages, endOfRunMessage, taskExecutions, versionOfNxBefore133, inner, encryptionKey, storeInCurrentProcess, distributedExecutionId, runContext, }) {
        const runEndTime = new Date().toISOString();
        const branch = (0, environment_1.getBranch)();
        const runData = {
            command: outputObfuscator.obfuscate((0, environment_1.parseCommand)()),
            startTime: runStartTime,
            endTime: runEndTime,
            distributedExecutionId,
            branch: branch,
            runGroup: (0, environment_1.getRunGroup)(),
            // only set sha if branch is set because we invoke a separate process,
            // which adds a few millis
            sha: branch ? (0, environment_1.extractGitSha)() : undefined,
            inner: inner,
        };
        const ciExecutionContext = {
            branch: branch,
            runGroup: (0, environment_1.getRunGroup)(),
            ciExecutionId: (0, environment_1.getCIExecutionId)(),
            ciExecutionEnv: (0, environment_1.getCIExecutionEnv)(),
        };
        if (storeInCurrentProcess) {
            if ((0, environment_1.agentRunningInDistributedExecution)(distributedExecutionId)) {
                storeTaskHashes(taskExecutions, cacheDirectory, distributedExecutionId);
                storeLocalCacheHits(taskExecutions, remoteCache, cacheDirectory);
            }
            try {
                yield remoteCache.waitForStoreRequestsToComplete();
            }
            catch (e) {
                output.error({
                    title: `Nx Cloud wasn't able to store artifacts.`,
                });
                messages.printMessages();
                return false;
            }
            for (const hash of fileStorage.storedHashes) {
                const matchingTask = taskExecutions.find((t) => t.hash === hash);
                if (!matchingTask) {
                    throw new Error(`Task with hash ${hash} isn't recorded`);
                }
                matchingTask.uploadedToStorage = true;
            }
            try {
                yield api.endRun(runData, taskExecutions, ciExecutionContext);
            }
            catch (e) {
                output.error({
                    title: `Nx Cloud wasn't able to record its run.`,
                });
                messages.printMessages();
                return false;
            }
            yield (0, metric_logger_1.submitRunMetrics)(options);
        }
        else {
            try {
                const accessToken = environment_1.ACCESS_TOKEN ? environment_1.ACCESS_TOKEN : options.accessToken;
                const linkId = (0, id_generator_1.generateUniqueLinkId)();
                const processRunEndFullPath = require.resolve('nx-cloud/lib/daemon/process-run-end');
                yield daemon.processInBackground(processRunEndFullPath, {
                    encryptionKey,
                    runnerOptions: Object.assign(Object.assign({}, options), { accessToken }),
                    delayedStoreRequests: remoteCache.delayedStoreRequests,
                    ciExecutionContext,
                    runEnd: {
                        runData,
                        taskExecutions,
                        linkId,
                    },
                });
                runContext.runUrl = `${(0, remove_trailing_slash_1.removeTrailingSlash)(options.url || 'https://nx.app')}/runs/${linkId}`;
            }
            catch (e) {
                output.warn({
                    title: `Nx Cloud Problems`,
                    bodyLines: [e.message || e.toString()],
                });
                return false;
            }
        }
        // this workaround is required because prior to Nx 13.3 we printed
        // the end message after the runner completes, so we need to wait for the
        // message to appear in the right place
        if (versionOfNxBefore133) {
            setTimeout(() => {
                messages.printMessages();
                if (!messages.anyErrors && !inner) {
                    endOfRunMessage.printCacheHitsMessage();
                }
            }, 0);
        }
        else {
            messages.printMessages();
            if (!messages.anyErrors && !inner) {
                endOfRunMessage.printCacheHitsMessage();
            }
        }
        return true;
    });
}
function createLifeCycle(runContext, options, outputObfuscator, tasks) {
    const cloudEnabledLifeCycle = new cloud_enabled_life_cycle_1.CloudEnabledLifeCycle(runContext, cacheDirectory, true, options.cacheableOperations || [], outputObfuscator, tasks);
    try {
        const { CompositeLifeCycle } = require('../../../utilities/nx-imports');
        if (!CompositeLifeCycle)
            return cloudEnabledLifeCycle;
        return new CompositeLifeCycle([options.lifeCycle, cloudEnabledLifeCycle]);
    }
    catch (e) {
        return cloudEnabledLifeCycle;
    }
}
function fetchUrlsForKnownHashesUpfront(api, runContext, tasks, options, distributedExecutionId) {
    return __awaiter(this, void 0, void 0, function* () {
        if (options.skipNxCache)
            return;
        let hashes = tasks.map((t) => t.hash).filter((h) => !!h);
        // filter out the urls that don't have artifact stored locally
        const exists = yield Promise.all(hashes.map((hash) => {
            const tdCommit = (0, path_1.join)(cacheDirectory, `${hash}.commit`);
            return (0, fs_extra_1.pathExists)(tdCommit);
        }));
        const missingHashes = [];
        for (let i = 0; i < exists.length; ++i) {
            if (!exists[i]) {
                missingHashes.push(hashes[i]);
            }
        }
        if (missingHashes.length > 0) {
            const startRunRequest = api.startRun(distributedExecutionId, missingHashes);
            for (const hash of missingHashes) {
                runContext.requests[hash] = startRunRequest;
            }
        }
    });
}
function cloudEnabledTasksRunner(tasks, options, context, inner = false) {
    var _a;
    const distributedExecutionId = process.env.NX_CLOUD_DISTRIBUTED_EXECUTION_ID;
    const runContext = {
        statuses: {},
        scheduledTasks: [],
        requests: {},
        allTasks: tasks,
    };
    const versionOfNxBefore133 = options.lifeCycle === undefined;
    const taskExecutions = [];
    const messages = new message_reporter_1.MessageReporter(options);
    const api = createApi(messages, options, runContext);
    const endOfRunMessage = new end_of_run_message_1.EndOfRunMessage(runContext, taskExecutions, distributedExecutionId);
    const outputObfuscator = new output_obfuscator_1.OutputObfuscator(options.maskedProperties);
    const runStartTime = new Date().toISOString();
    const lifeCycle = createLifeCycle(runContext, options, outputObfuscator, taskExecutions);
    const encryptionKey = environment_1.ENCRYPTION_KEY || options.encryptionKey;
    const encryption = new e2e_encryption_1.E2EEncryption(encryptionKey);
    const errorApi = new error_reporter_api_1.ErrorReporterApi(options);
    const storeInCurrentProcess = (0, environment_1.agentRunningInDistributedExecution)(distributedExecutionId) ||
        !((_a = context.daemon) === null || _a === void 0 ? void 0 : _a.enabled());
    const fileStorage = new file_storage_1.FileStorage(encryption, errorApi, options, 'cloud-enabled-runner');
    const remoteCache = new cloud_remote_cache_1.CloudRemoteCache(messages, api, runContext, fileStorage, distributedExecutionId, storeInCurrentProcess);
    // we don't await for it cause this step is optional
    fetchUrlsForKnownHashesUpfront(api, runContext, tasks, options, distributedExecutionId);
    // have to reset it so we don't capture inner tasks
    delete process.env.NX_CLOUD_DISTRIBUTED_EXECUTION_ID;
    const res = tasksRunner(tasks, Object.assign(Object.assign({}, options), { remoteCache, lifeCycle }), context);
    // observable -> legacy
    if (res.subscribe) {
        const { Subject } = require('rxjs/internal/Subject');
        const wrappedRes = new Subject();
        res.subscribe({
            next: (value) => wrappedRes.next(value),
            error: (err) => wrappedRes.error(err),
            complete: () => __awaiter(this, void 0, void 0, function* () {
                const success = yield onComplete({
                    daemon: context.daemon,
                    options,
                    fileStorage,
                    remoteCache,
                    api,
                    outputObfuscator,
                    runStartTime,
                    messages,
                    endOfRunMessage,
                    taskExecutions,
                    versionOfNxBefore133,
                    inner,
                    encryptionKey,
                    storeInCurrentProcess,
                    runContext,
                    distributedExecutionId,
                });
                if (!success &&
                    (0, environment_1.agentRunningInDistributedExecution)(distributedExecutionId)) {
                    process.exit(environment_1.DISTRIBUTED_TASK_EXECUTION_INTERNAL_ERROR_STATUS_CODE);
                }
                wrappedRes.complete();
            }),
        });
        return wrappedRes;
        // promise
    }
    else {
        return res
            .then((r) => __awaiter(this, void 0, void 0, function* () {
            const success = yield onComplete({
                daemon: context.daemon,
                options,
                fileStorage,
                remoteCache,
                api,
                outputObfuscator,
                runStartTime,
                messages,
                endOfRunMessage,
                taskExecutions,
                versionOfNxBefore133,
                inner,
                encryptionKey,
                storeInCurrentProcess,
                runContext,
                distributedExecutionId,
            });
            if (!success &&
                (0, environment_1.agentRunningInDistributedExecution)(distributedExecutionId)) {
                process.exit(environment_1.DISTRIBUTED_TASK_EXECUTION_INTERNAL_ERROR_STATUS_CODE);
            }
            return r;
        }))
            .catch((e) => __awaiter(this, void 0, void 0, function* () {
            const success = yield onComplete({
                daemon: context.daemon,
                options,
                fileStorage,
                remoteCache,
                api,
                outputObfuscator,
                runStartTime,
                messages,
                endOfRunMessage,
                taskExecutions,
                versionOfNxBefore133,
                inner,
                encryptionKey,
                storeInCurrentProcess,
                runContext,
                distributedExecutionId,
            });
            if (!success &&
                (0, environment_1.agentRunningInDistributedExecution)(distributedExecutionId)) {
                process.exit(environment_1.DISTRIBUTED_TASK_EXECUTION_INTERNAL_ERROR_STATUS_CODE);
            }
            throw e;
        }));
    }
}
exports.cloudEnabledTasksRunner = cloudEnabledTasksRunner;
//# sourceMappingURL=cloud-enabled.runner.js.map