"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CloudRemoteCache = void 0;
const environment_1 = require("../../../utilities/environment");
const { output } = require('../../../utilities/nx-imports-light');
class CloudRemoteCache {
    constructor(messages, api, runContext, fileStorage, distributedExecutionId, storeInCurrentProcess) {
        this.messages = messages;
        this.api = api;
        this.runContext = runContext;
        this.fileStorage = fileStorage;
        this.distributedExecutionId = distributedExecutionId;
        this.storeInCurrentProcess = storeInCurrentProcess;
        this.storeRequests = [];
        this.delayedStoreRequests = [];
    }
    retrieve(hash, cacheDirectory) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            if (this.messages.cacheError)
                return false;
            const hashUrls = yield this.hashUrls(hash);
            if (!hashUrls || !hashUrls.get) {
                if (environment_1.VERBOSE_LOGGING) {
                    output.note({ title: `Nx Cloud: Cache miss ${hash}.` });
                }
                this.runContext.statuses[hash] = 'cache-miss';
                return false;
            }
            try {
                yield this.fileStorage.retrieve(hash, hashUrls.get, cacheDirectory);
                this.runContext.statuses[hash] = 'remote-cache-hit';
                return true;
            }
            catch (ee) {
                const e = (_a = ee.axiosException) !== null && _a !== void 0 ? _a : ee;
                // TODO: vsavkin remove this handling Oct 2023
                // 404 indicates that something is broken, but older versions
                // of the api can result in such errors
                // we ignore them for now
                if (e.response && e.response.status === 404) {
                    if (environment_1.VERBOSE_LOGGING) {
                        output.note({ title: `Nx Cloud: Cache miss ${hash}. Status 404.` });
                    }
                    // cache miss. print nothing
                }
                else {
                    this.messages.cacheError = this.messages.extractErrorMessage(e, 'storage');
                }
                this.runContext.statuses[hash] = 'cache-miss';
                return false;
            }
        });
    }
    store(hash, cacheDirectory) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.messages.cacheError)
                return false;
            const res = Promise.resolve().then(() => __awaiter(this, void 0, void 0, function* () {
                var _a;
                const hashUrls = yield this.hashUrls(hash);
                if (!hashUrls)
                    return false;
                if (!hashUrls.put) {
                    if (environment_1.VERBOSE_LOGGING) {
                        output.note({
                            title: `Nx Cloud: Skipping storing ${hash}.`,
                            bodyLines: [
                                `There are several reasons why this can happen.`,
                                `Maybe you are using a read-only token or the artifact has already being uploaded.`,
                            ],
                        });
                    }
                    return true;
                }
                if (!this.storeInCurrentProcess) {
                    this.delayedStoreRequests.push({ hash: hash, url: hashUrls.put });
                    return true;
                }
                try {
                    yield this.fileStorage.store(hash, hashUrls.put, cacheDirectory);
                    return true;
                }
                catch (ee) {
                    const e = (_a = ee.axiosException) !== null && _a !== void 0 ? _a : ee;
                    this.messages.cacheError = this.messages.extractErrorMessage(e, 'storage');
                    return false;
                }
            }));
            this.storeRequests.push(res);
            return res;
        });
    }
    hashUrls(hash) {
        return __awaiter(this, void 0, void 0, function* () {
            if (hash in this.runContext.requests) {
                return (yield this.runContext.requests[hash])[hash];
            }
            else {
                const scheduledTaskHashesWithoutRequests = this.runContext.scheduledTasks
                    .filter((t) => !this.runContext.requests[t.hash])
                    .map((t) => t.hash);
                if (scheduledTaskHashesWithoutRequests.indexOf(hash) === -1) {
                    scheduledTaskHashesWithoutRequests.push(hash);
                }
                const request = this.api.startRun(this.distributedExecutionId, scheduledTaskHashesWithoutRequests);
                scheduledTaskHashesWithoutRequests.forEach((taskHash) => {
                    this.runContext.requests[taskHash] = request;
                });
                return (yield request)[hash];
            }
        });
    }
    waitForStoreRequestsToComplete() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield Promise.all(this.storeRequests).then((r) => r.reduce((a, b) => a && b, true));
            if (!res) {
                throw new Error(`Error when storing artifacts`);
            }
        });
    }
}
exports.CloudRemoteCache = CloudRemoteCache;
//# sourceMappingURL=cloud-remote-cache.js.map