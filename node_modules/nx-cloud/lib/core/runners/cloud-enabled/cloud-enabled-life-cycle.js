"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CloudEnabledLifeCycle = void 0;
const crypto_1 = require("crypto");
const serializer_overrides_1 = require("../../../utilities/serializer-overrides");
const read_task_terminal_output_1 = require("../../terminal-output/read-task-terminal-output");
class CloudEnabledLifeCycle {
    constructor(runContext, cacheDirectory, collectTerminalOutput, cacheableOperations, outputObfuscator, tasks) {
        this.runContext = runContext;
        this.cacheDirectory = cacheDirectory;
        this.collectTerminalOutput = collectTerminalOutput;
        this.cacheableOperations = cacheableOperations;
        this.outputObfuscator = outputObfuscator;
        this.tasks = tasks;
    }
    scheduleTask(task) {
        this.runContext.scheduledTasks.push(task);
    }
    // this gets called for every tasks that starts.
    startTask(task) {
        this.tasks.push({
            taskId: task.id,
            startTime: new Date().toISOString(),
            target: task.target.target,
            projectName: task.target.project,
            hash: task.hash,
            hashDetails: this.cleanUpHashDetails(task.hashDetails), // the case is needed if you use older version of Nx
            params: (0, serializer_overrides_1.serializeOverrides)(task),
            uploadedToStorage: false,
        });
    }
    endTasks(tasks) {
        // this can be called multiple times changing this time.
        for (let t of tasks) {
            let cacheStatus;
            const taskIsRemoteCacheHit = t.status === 'remote-cache';
            const taskIsLocalCacheHitPreNx135 = t.status === 'cache';
            const taskIsLocalCacheHit = t.status === 'local-cache' ||
                t.status === 'local-cache-kept-existing' ||
                taskIsLocalCacheHitPreNx135;
            if (this.runContext.statuses[t.task.hash]) {
                cacheStatus = this.runContext.statuses[t.task.hash];
            }
            else if (taskIsRemoteCacheHit) {
                cacheStatus = 'remote-cache-hit';
            }
            else if (taskIsLocalCacheHit) {
                cacheStatus = 'local-cache-hit';
            }
            else {
                cacheStatus = 'cache-miss';
            }
            this.updateStartedTask(t, cacheStatus);
        }
    }
    endCommand() { }
    updateStartedTask(result, cacheStatus) {
        const startedTask = this.tasks.find((t) => t.taskId === result.task.id);
        if (!startedTask) {
            throw new Error(`Cannot find task ${result.task.id}`);
        }
        if ((result === null || result === void 0 ? void 0 : result.startTime) && (result === null || result === void 0 ? void 0 : result.endTime)) {
            startedTask.startTime = new Date(result.startTime).toISOString();
            startedTask.endTime = new Date(result.endTime).toISOString();
        }
        else {
            startedTask.endTime = new Date().toISOString();
        }
        startedTask.status = result.code;
        startedTask.params = this.outputObfuscator.obfuscate(startedTask.params);
        startedTask.cacheStatus = cacheStatus;
        if (this.collectTerminalOutput) {
            startedTask.terminalOutput = this.getTerminalOutput(result.task.hash, startedTask.cacheStatus, result.code);
        }
    }
    getTerminalOutput(hash, cacheStatus, code) {
        return (0, read_task_terminal_output_1.readTaskTerminalOutput)(this.cacheDirectory, this.outputObfuscator, hash, cacheStatus, code);
    }
    cleanUpHashDetails(hashDetails) {
        const nodes = {};
        const npm = [];
        for (const k of Object.keys(hashDetails.nodes)) {
            if (k.startsWith('npm:')) {
                npm.push(hashDetails.nodes[k]);
            }
            else {
                nodes[k] = hashDetails.nodes[k];
            }
        }
        npm.sort();
        if (npm.length > 0) {
            const hasher = (0, crypto_1.createHash)('md5');
            hasher.update(npm.join('|'));
            nodes['npmDependencies'] = hasher.digest('base64');
        }
        return {
            nodes,
            runtime: hashDetails.runtime,
            implicitDeps: hashDetails.implicitDeps,
        };
    }
}
exports.CloudEnabledLifeCycle = CloudEnabledLifeCycle;
//# sourceMappingURL=cloud-enabled-life-cycle.js.map