"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.executeTasks = void 0;
const create_unchanged_value_timeout_1 = require("../../../utilities/create-unchanged-value-timeout");
const environment_1 = require("../../../utilities/environment");
const waiter_1 = require("../../../utilities/waiter");
const { output } = require('../../../utilities/nx-imports-light');
function executeTasks(agentName, api, dteArtifactStorage, invokeTasks, targets) {
    return __awaiter(this, void 0, void 0, function* () {
        let completedStatusCode = 0;
        let apiResponse = null;
        const failIfSameTasksAfterTimeout = (0, create_unchanged_value_timeout_1.createUnchangedValueTimeout)({
            title: `No new messages received after ${environment_1.NO_MESSAGES_TIMEOUT / 1000} seconds`,
            timeout: environment_1.NO_MESSAGES_TIMEOUT,
        });
        const waiter = new waiter_1.Waiter();
        let completedTasks = [];
        const startTime = new Date();
        let executedAnyTasks = false;
        const processedTasks = {};
        while (true) {
            if (environment_1.VERBOSE_LOGGING) {
                output.note({
                    title: `${agentName} fetching tasks...`,
                });
            }
            apiResponse = yield api.tasks(apiResponse ? apiResponse.executionId : null, completedStatusCode, completedTasks, targets);
            if (environment_1.VERBOSE_LOGGING) {
                output.note({
                    title: `${agentName} received an API Response`,
                    bodyLines: [
                        `completed: ${apiResponse.completed}`,
                        `status: ${apiResponse.status}`,
                        `retryDuring: ${apiResponse.retryDuring}`,
                        `executionId: ${apiResponse.executionId}`,
                        `number of tasks: ${apiResponse.tasks.length}`,
                        `error: ${apiResponse.criticalErrorMessage}`,
                        `maxParallel: ${apiResponse.maxParallel}`,
                    ],
                });
            }
            if (apiResponse.criticalErrorMessage) {
                output.error({
                    title: 'Distributed Execution Terminated',
                    bodyLines: ['Error:', apiResponse.criticalErrorMessage],
                });
                process.exit(1);
            }
            // run group is completed but it might be a rerun
            // we will try several times before going further and
            // completed the response
            // we only do it if we haven't executed any tasks
            if ((apiResponse === null || apiResponse === void 0 ? void 0 : apiResponse.retryDuring) &&
                (apiResponse === null || apiResponse === void 0 ? void 0 : apiResponse.retryDuring) !== 0 &&
                !executedAnyTasks &&
                new Date().getTime() - startTime.getTime() > apiResponse.retryDuring) {
                yield waiter.wait();
                continue;
            }
            if ((apiResponse === null || apiResponse === void 0 ? void 0 : apiResponse.status) !== undefined) {
                if (apiResponse.status === 'RUN_GROUP_COMPLETED' ||
                    apiResponse.status === 'NO_FURTHER_TASKS_TO_RUN') {
                    return;
                }
            }
            else if (apiResponse.completed) {
                return;
            }
            // if status is present that use the status instead of completed, otherwise use completed
            failIfSameTasksAfterTimeout(apiResponse.tasks.map((t) => t.taskId).join(''));
            if (!apiResponse.executionId) {
                if (environment_1.VERBOSE_LOGGING) {
                    output.note({
                        title: `${agentName} waiting...`,
                    });
                }
                yield waiter.wait();
                completedStatusCode = 0;
                completedTasks = [];
                continue;
            }
            waiter.reset();
            executedAnyTasks = true;
            if (apiResponse.completedTasks) {
                for (const t of apiResponse.completedTasks) {
                    if (processedTasks[t.taskId])
                        continue;
                    output.note({
                        title: `${agentName} downloading artifacts for ${t.taskId} Hash: ${t.hash} Url: ${t.url}`,
                    });
                    yield dteArtifactStorage.retrieveAndExtract(t.hash, t.url);
                    processedTasks[t.taskId] = true;
                }
            }
            const r = yield invokeTasks(apiResponse.executionId, apiResponse.tasks, apiResponse.maxParallel);
            for (const t of r.completedTasks) {
                processedTasks[t.taskId] = true;
            }
            completedStatusCode = r.completedStatusCode;
            completedTasks = r.completedTasks;
        }
    });
}
exports.executeTasks = executeTasks;
//# sourceMappingURL=execute-tasks.js.map