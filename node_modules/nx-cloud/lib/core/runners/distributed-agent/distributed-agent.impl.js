"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.startAgent = void 0;
const fs_1 = require("fs");
const yargsParser = require("yargs-parser");
const dte_artifact_storage_1 = require("../../../utilities/dte-artifact-storage");
const environment_1 = require("../../../utilities/environment");
const get_cloud_options_1 = require("../../../utilities/get-cloud-options");
const is_workspace_enabled_1 = require("../../../utilities/is-workspace-enabled");
const metric_logger_1 = require("../../../utilities/metric-logger");
const error_reporter_api_1 = require("../../api/error-reporter.api");
const print_cacheable_targets_error_1 = require("../../error/print-cacheable-targets-error");
const print_invalid_runner_error_1 = require("../../error/print-invalid-runner-error");
const print_run_group_error_1 = require("../../error/print-run-group-error");
const e2e_encryption_1 = require("../../file-storage/e2e-encryption");
const file_storage_1 = require("../../file-storage/file-storage");
const distributed_agent_api_1 = require("./distributed-agent.api");
const execute_tasks_1 = require("./execute-tasks");
const invoke_tasks_using_nx_imperative_api_1 = require("./invoke-tasks-using-nx-imperative-api");
const invoke_tasks_using_run_many_1 = require("./invoke-tasks-using-run-many");
const { output } = require('../../../utilities/nx-imports-light');
const { initTasksRunner, cacheDirectory, } = require('../../../utilities/nx-imports');
const args = yargsParser(process.argv, {
    array: ['targets'],
    default: {},
});
// just in case someone passes the args with commas
// cf. https://github.com/yargs/yargs/issues/846
if (args.targets && args.targets.length === 1) {
    args.targets = args.targets[0].split(',').map((x) => x.trim());
}
function startAgent() {
    return __awaiter(this, void 0, void 0, function* () {
        const branch = (0, environment_1.getBranch)();
        const runGroup = (0, environment_1.getRunGroup)();
        const ciExecutionId = (0, environment_1.getCIExecutionId)();
        const ciExecutionEnv = (0, environment_1.getCIExecutionEnv)();
        if (!(0, print_run_group_error_1.canDetectRunGroup)(runGroup, ciExecutionId)) {
            (0, print_run_group_error_1.printRunGroupError)();
            process.exit(1);
        }
        if (args.targets && args.targets.length) {
            output.note({
                title: `Starting an agent for running Nx target(s) [${args.targets.join(', ')}]`,
            });
        }
        else {
            output.note({
                title: 'Starting an agent for running Nx tasks',
            });
        }
        // TODO: Remove this as light client is default
        const { nxJson, nxCloudOptions: options } = (0, get_cloud_options_1.getCloudOptions)('default');
        function isNxCloudDefault() {
            var _a;
            const defaultRunnerConfig = (_a = nxJson.tasksRunnerOptions) === null || _a === void 0 ? void 0 : _a.default;
            if (nxJson.nxCloudAccessToken && !defaultRunnerConfig) {
                return true;
            }
            return ((!(defaultRunnerConfig === null || defaultRunnerConfig === void 0 ? void 0 : defaultRunnerConfig.runner) && process.env.NX_CLOUD_ACCESS_TOKEN) ||
                (!(defaultRunnerConfig === null || defaultRunnerConfig === void 0 ? void 0 : defaultRunnerConfig.runner) && nxJson.nxCloudAccessToken) ||
                (defaultRunnerConfig === null || defaultRunnerConfig === void 0 ? void 0 : defaultRunnerConfig.runner) === 'nx-cloud' ||
                (defaultRunnerConfig === null || defaultRunnerConfig === void 0 ? void 0 : defaultRunnerConfig.runner) === '@nrwl/nx-cloud');
        }
        if (!isNxCloudDefault()) {
            (0, print_invalid_runner_error_1.printInvalidRunnerError)();
            return process.exit(1);
        }
        if (args.targets &&
            args.targets.some((target) => { var _a; return !((_a = options.cacheableOperations) === null || _a === void 0 ? void 0 : _a.includes(target)); })) {
            const wrongTargets = args.targets.filter((target) => { var _a; return !((_a = options.cacheableOperations) === null || _a === void 0 ? void 0 : _a.includes(target)); });
            (0, print_cacheable_targets_error_1.printCacheableTargetsError)(wrongTargets);
            return process.exit(1);
        }
        const workspaceEnabled = yield (0, is_workspace_enabled_1.isWorkspaceEnabled)(options);
        if (!workspaceEnabled) {
            output.error({
                title: 'Nx Cloud: Workspace is disabled',
                bodyLines: [
                    'Distributed Task Execution is disabled when your workspace is disabled',
                    '',
                    "Organization administrators can find more information on the 'Billing' page in the Nx Cloud Webapp",
                ],
            });
            process.exit(1);
        }
        const agentName = getAgentName();
        const api = new distributed_agent_api_1.DistributedAgentApi(options, branch, runGroup, ciExecutionId, ciExecutionEnv, agentName);
        createAgentLockfileAndSetUpListeners(api, options, agentName);
        const encryption = new e2e_encryption_1.E2EEncryption(environment_1.ENCRYPTION_KEY || options.encryptionKey);
        const errorReporter = new error_reporter_api_1.ErrorReporterApi(options);
        const dteArtifactStorage = new dte_artifact_storage_1.DteArtifactStorage(new file_storage_1.FileStorage(encryption, errorReporter, options, 'dte-agent'), cacheDirectory);
        const invokeTasks = initTasksRunner
            ? yield (0, invoke_tasks_using_nx_imperative_api_1.invokeTasksUsingNxImperativeApi)(options)
            : yield (0, invoke_tasks_using_run_many_1.invokeTasksUsingRunMany)();
        return (0, execute_tasks_1.executeTasks)(agentName, api, dteArtifactStorage, invokeTasks, args.targets)
            .then((res) => __awaiter(this, void 0, void 0, function* () {
            yield (0, metric_logger_1.submitRunMetrics)(options);
            return res;
        }))
            .catch((e) => __awaiter(this, void 0, void 0, function* () {
            yield api.completeRunGroupWithError(`Critical Error in Agent: "${e.message}"`);
            throw e;
        }));
    });
}
exports.startAgent = startAgent;
function getAgentName() {
    if (process.env.NX_AGENT_NAME !== undefined) {
        return process.env.NX_AGENT_NAME;
    }
    else if (process.env.CIRCLECI !== undefined && process.env.CIRCLE_STAGE) {
        return process.env.CIRCLE_STAGE;
    }
    else if (process.env.CIRCLECI !== undefined && process.env.CIRCLE_JOB) {
        return process.env.CIRCLE_JOB;
    }
    else {
        return `Agent ${Math.floor(Math.random() * 100000)}`;
    }
}
function createAgentLockfileAndSetUpListeners(api, options, agentName) {
    const lockFileDirectory = `${cacheDirectory}/lockfiles`;
    const lockFilePath = `${lockFileDirectory}/${agentName}.lock`;
    if (!(0, fs_1.existsSync)(lockFileDirectory)) {
        (0, fs_1.mkdirSync)(lockFileDirectory, { recursive: true });
    }
    // Check for other agents' lockfiles and warn if exist
    const lockFiles = (0, fs_1.readdirSync)(lockFileDirectory);
    if (lockFiles.length) {
        // Check to make sure the current agent name is not in use (only 1/100000 ^ 2 chance of this)
        if (lockFiles.includes(`${agentName}.lock`)) {
            output.error({
                title: 'Duplicate Agent ID Detected',
                bodyLines: [
                    'We have detected another agent with this ID running in this workspace. This should not happen.',
                    '',
                    'End all currently running agents, run "npx nx-cloud clean-up-agents", and try again.',
                ],
            });
            process.exit(1);
        }
        output.warn({
            title: 'Other Nx Cloud Agents Detected',
            bodyLines: [
                'We have detected other agents running in this workspace. This can cause unexpected behavior.',
                '',
                'This can also be a false positive caused by agents that did not shut down correctly.',
                'If you believe this is the case, run "npx nx-cloud clean-up-agents".',
            ],
        });
    }
    (0, fs_1.writeFileSync)(lockFilePath, '');
    process.on('exit', (code) => {
        cleanupAgentLockfile(lockFilePath, code);
    });
    process.on('SIGTERM', () => __awaiter(this, void 0, void 0, function* () {
        yield api.completeRunGroupWithError('Agent was terminated via SIGTERM');
        cleanupAgentLockfile(lockFilePath, 1);
    }));
    process.on('SIGINT', () => __awaiter(this, void 0, void 0, function* () {
        yield api.completeRunGroupWithError('Agent was terminated via SIGINT');
        cleanupAgentLockfile(lockFilePath, 1);
    }));
}
function cleanupAgentLockfile(lockFilePath, code) {
    if ((0, fs_1.existsSync)(lockFilePath)) {
        (0, fs_1.unlinkSync)(lockFilePath);
        process.exit(code);
    }
}
//# sourceMappingURL=distributed-agent.impl.js.map