"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createStartRequest = exports.DistributedExecutionApi = void 0;
const axios_1 = require("../../../utilities/axios");
const environment_1 = require("../../../utilities/environment");
const metric_logger_1 = require("../../../utilities/metric-logger");
const serializer_overrides_1 = require("../../../utilities/serializer-overrides");
const { output } = require('../../../utilities/nx-imports-light');
class DistributedExecutionApi {
    constructor(options) {
        this.apiAxiosInstance = (0, axios_1.createApiAxiosInstance)(options);
    }
    start(params) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            const recorder = (0, metric_logger_1.createMetricRecorder)('dteStart');
            let resp;
            if (environment_1.VERBOSE_LOGGING) {
                output.note({
                    title: 'Starting a distributed execution',
                    bodyLines: [JSON.stringify(params, null, 2)],
                });
            }
            try {
                resp = yield (0, axios_1.axiosMultipleTries)(() => this.apiAxiosInstance.post('/nx-cloud/executions/start', params));
                recorder.recordMetric((0, metric_logger_1.mapRespToPerfEntry)(resp));
            }
            catch (e) {
                recorder.recordMetric(((_a = e === null || e === void 0 ? void 0 : e.axiosException) === null || _a === void 0 ? void 0 : _a.response)
                    ? (0, metric_logger_1.mapRespToPerfEntry)(e.axiosException.response)
                    : metric_logger_1.RUNNER_FAILURE_PERF_ENTRY);
                throw e;
            }
            if (!resp.data.enabled) {
                throw new Error(`Workspace is disabled. Cannot perform distributed task executions.`);
            }
            if (resp.data.error) {
                throw new Error(resp.data.error);
            }
            return resp.data.id;
        });
    }
    status(id) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            const recorder = (0, metric_logger_1.createMetricRecorder)('dteStatus');
            try {
                const resp = yield (0, axios_1.axiosMultipleTries)(() => this.apiAxiosInstance.post('/nx-cloud/executions/status', {
                    id,
                }));
                recorder.recordMetric((0, metric_logger_1.mapRespToPerfEntry)(resp));
                return resp.data;
            }
            catch (e) {
                recorder.recordMetric(((_a = e === null || e === void 0 ? void 0 : e.axiosException) === null || _a === void 0 ? void 0 : _a.response)
                    ? (0, metric_logger_1.mapRespToPerfEntry)(e.axiosException.response)
                    : metric_logger_1.RUNNER_FAILURE_PERF_ENTRY);
                output.error({
                    title: e.message,
                });
                process.exit(1);
            }
        });
    }
    completeRunGroupWithError(branch, runGroup, ciExecutionId, ciExecutionEnv, error) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            const recorder = (0, metric_logger_1.createMetricRecorder)('completeRunGroup');
            if (environment_1.VERBOSE_LOGGING) {
                output.note({
                    title: 'Completing with an error',
                    bodyLines: [
                        `ciExecutionId: ${ciExecutionId}`,
                        `ciExecutionEnv: ${ciExecutionEnv}`,
                        `runGroup: ${runGroup}`,
                        `error: ${error}`,
                    ],
                });
            }
            try {
                const resp = yield (0, axios_1.axiosMultipleTries)(() => this.apiAxiosInstance.post('/nx-cloud/executions/complete-run-group', {
                    branch,
                    runGroup,
                    ciExecutionId,
                    ciExecutionEnv,
                    criticalErrorMessage: error,
                }), 3);
                recorder.recordMetric((0, metric_logger_1.mapRespToPerfEntry)(resp));
            }
            catch (e) {
                recorder.recordMetric(((_a = e === null || e === void 0 ? void 0 : e.axiosException) === null || _a === void 0 ? void 0 : _a.response)
                    ? (0, metric_logger_1.mapRespToPerfEntry)(e.axiosException.response)
                    : metric_logger_1.RUNNER_FAILURE_PERF_ENTRY);
            }
        });
    }
}
exports.DistributedExecutionApi = DistributedExecutionApi;
function createStartRequest(branch, runGroup, ciExecutionId, ciExecutionEnv, task, options, commitSha) {
    const tasksToExecute = task.map((arr) => {
        return arr.map((t) => {
            return {
                taskId: t.id,
                hash: t.hash,
                projectName: t.target.project,
                target: t.target.target,
                configuration: t.target.configuration || null,
                params: (0, serializer_overrides_1.serializeOverrides)(t),
                projectRoot: t.projectRoot,
            };
        });
    });
    const request = {
        command: (0, environment_1.parseCommand)(),
        branch,
        runGroup,
        ciExecutionId,
        ciExecutionEnv,
        tasks: tasksToExecute,
        maxParallel: calculateMaxParallel(options),
        commitSha,
    };
    if (environment_1.NX_CLOUD_DISTRIBUTED_EXECUTION_AGENT_COUNT) {
        request.agentCount = environment_1.NX_CLOUD_DISTRIBUTED_EXECUTION_AGENT_COUNT;
    }
    if (!environment_1.NX_CLOUD_DISTRIBUTED_EXECUTION_STOP_AGENTS_ON_FAILURE) {
        request.stopAgentsOnFailure = false;
    }
    return request;
}
exports.createStartRequest = createStartRequest;
function calculateMaxParallel(options) {
    if (options.parallel === 'false' || options.parallel === false) {
        return 1;
    }
    else if (options.parallel === 'true' || options.parallel === true) {
        return Number(options.maxParallel || 3);
    }
    else if (options.parallel === undefined) {
        return options.maxParallel ? Number(options.maxParallel) : 3;
    }
    else {
        return Number(options.parallel) || 3;
    }
}
//# sourceMappingURL=distributed-execution.api.js.map