"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.nxCloudDistributedTasksRunner = void 0;
const dte_artifact_storage_1 = require("../../../utilities/dte-artifact-storage");
const environment_1 = require("../../../utilities/environment");
const metric_logger_1 = require("../../../utilities/metric-logger");
const error_reporter_api_1 = require("../../api/error-reporter.api");
const print_run_group_error_1 = require("../../error/print-run-group-error");
const e2e_encryption_1 = require("../../file-storage/e2e-encryption");
const file_storage_1 = require("../../file-storage/file-storage");
const distributed_execution_api_1 = require("./distributed-execution.api");
const process_tasks_1 = require("./process-tasks");
const split_task_graph_into_stages_1 = require("./split-task-graph-into-stages");
const task_graph_creator_1 = require("./task-graph-creator");
const { output } = require('../../../utilities/nx-imports-light');
const { cacheDirectory } = require('../../../utilities/nx-imports');
class NoopLifeCycle {
    scheduleTask(task) { }
    startTask(task) { }
    endTasks(tasks) { }
}
const nxCloudDistributedTasksRunner = (tasks, options, context) => __awaiter(void 0, void 0, void 0, function* () {
    if (options.skipNxCache) {
        output.warn({
            title: `--skip-nx-cache is ignored when using distributed tasks execution (DTE).`,
            bodyLine: [`DTE needs the cache to share files between agents.`],
        });
    }
    if (environment_1.VERBOSE_LOGGING) {
        output.note({
            title: 'Starting distributed command execution',
        });
    }
    options.lifeCycle = new NoopLifeCycle();
    const branch = (0, environment_1.getBranch)();
    const runGroup = (0, environment_1.getRunGroup)();
    const ciExecutionId = (0, environment_1.getCIExecutionId)();
    const ciExecutionEnv = (0, environment_1.getCIExecutionEnv)();
    const commitSha = (0, environment_1.extractGitSha)();
    const commitRef = (0, environment_1.extractGitRef)();
    if (!(0, print_run_group_error_1.canDetectRunGroup)(runGroup, ciExecutionId)) {
        (0, print_run_group_error_1.printRunGroupError)();
        process.exit(1);
    }
    const encryption = new e2e_encryption_1.E2EEncryption(environment_1.ENCRYPTION_KEY || options.encryptionKey);
    const errorReporter = new error_reporter_api_1.ErrorReporterApi(options);
    const dteArtifactStorage = new dte_artifact_storage_1.DteArtifactStorage(new file_storage_1.FileStorage(encryption, errorReporter, options, 'dte-main'), cacheDirectory);
    const api = new distributed_execution_api_1.DistributedExecutionApi(options);
    attachSignalListenersToCompleteRunGroupOnError(api, branch, runGroup, ciExecutionId, ciExecutionEnv);
    try {
        const taskGraph = getTaskGraph(context, tasks, options);
        const r = yield runDistributedExecution(api, options, dteArtifactStorage, branch, runGroup, ciExecutionId, ciExecutionEnv, taskGraph, commitSha, commitRef);
        if (r.commandStatus === 0) {
            output.success({
                title: 'Successfully completed running the command.',
                bodyLines: [`See run details at ${r.runUrl}`],
            });
        }
        else {
            output.error({
                title: 'Command execution failed.',
                bodyLines: [`See run details at ${r.runUrl}`],
            });
        }
        yield (0, metric_logger_1.submitRunMetrics)(options);
        process.exit(r.commandStatus);
    }
    catch (e) {
        output.error({
            title: 'Unable to complete a run.',
            bodyLines: [e.message],
        });
        if (e.axiosException) {
            console.log(e.axiosException);
        }
        else {
            console.log(e);
        }
        try {
            yield api.completeRunGroupWithError(branch, runGroup, ciExecutionId, ciExecutionEnv, `Main job terminated with an error: "${e.message}"`);
        }
        finally {
            process.exit(1);
        }
    }
});
exports.nxCloudDistributedTasksRunner = nxCloudDistributedTasksRunner;
function getTaskGraph(context, tasks, options) {
    if (context.taskGraph) {
        return context.taskGraph;
    }
    else {
        return (0, task_graph_creator_1.createTaskGraphCompat)(options, context.projectGraph, tasks);
    }
}
function attachSignalListenersToCompleteRunGroupOnError(api, branch, runGroup, ciExecutionId, ciExecutionEnv) {
    process.on('SIGINT', () => __awaiter(this, void 0, void 0, function* () {
        yield api.completeRunGroupWithError(branch, runGroup, ciExecutionId, ciExecutionEnv, 'Main job was terminated via SIGINT');
        process.exit(1);
    }));
    process.on('SIGTERM', () => __awaiter(this, void 0, void 0, function* () {
        yield api.completeRunGroupWithError(branch, runGroup, ciExecutionId, ciExecutionEnv, 'Main job was terminated via SIGTERM');
        process.exit(1);
    }));
}
function runDistributedExecution(api, options, dteArtifactStorage, branch, runGroup, ciExecutionId, ciExecutionEnv, taskGraph, commitSha, commitRef) {
    return __awaiter(this, void 0, void 0, function* () {
        const id = yield api.start((0, distributed_execution_api_1.createStartRequest)(branch, runGroup, ciExecutionId, ciExecutionEnv, (0, split_task_graph_into_stages_1.splitTasksIntoStages)(taskGraph), options, commitSha));
        return yield (0, process_tasks_1.processTasks)(api, dteArtifactStorage, id, Object.values(taskGraph.tasks));
    });
}
//# sourceMappingURL=distributed-execution.runner.js.map