"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TaskGraphCreator = exports.createTaskGraphCompat = void 0;
const fs_1 = require("fs");
const strip_json_comments_1 = require("../../../utilities/strip-json-comments");
const { workspaceRoot } = require('../../../utilities/nx-imports-light');
const { getDependencyConfigs } = require('../../../utilities/nx-imports');
function createTaskGraphCompat(options, projectGraph, tasks) {
    const nxjson = JSON.parse((0, strip_json_comments_1.stripJsonComments)((0, fs_1.readFileSync)(`${workspaceRoot}/nx.json`).toString(), {
        trailingCommas: true,
    }));
    return new TaskGraphCreator(projectGraph, getDefaultDependencyConfigs(nxjson, options)).createTaskGraph(tasks);
}
exports.createTaskGraphCompat = createTaskGraphCompat;
function getDefaultDependencyConfigs(nxJson, runnerOptions) {
    var _a, _b;
    const defaults = (_a = nxJson.targetDependencies) !== null && _a !== void 0 ? _a : {};
    const strictlyOrderedTargets = runnerOptions
        ? (_b = runnerOptions.strictlyOrderedTargets) !== null && _b !== void 0 ? _b : ['build']
        : [];
    // Strictly Ordered Targets depend on their dependencies
    for (const target of strictlyOrderedTargets) {
        defaults[target] = defaults[target] || [];
        defaults[target].push({
            target,
            projects: 'dependencies',
        });
    }
    return defaults;
}
/**
 * This is only used for versions of Nx prior to 14 where the task graph
 * wasn't part of the context so we have to recreate it
 */
class TaskGraphCreator {
    constructor(projectGraph, defaultTargetDependencies) {
        this.projectGraph = projectGraph;
        this.defaultTargetDependencies = defaultTargetDependencies;
    }
    createTaskGraph(tasks) {
        const graph = {
            roots: [],
            tasks: {},
            dependencies: {},
        };
        for (const task of tasks) {
            this.addTaskToGraph(task, graph);
            const dependencyConfigs = getDependencyConfigs(task.target, this.defaultTargetDependencies, this.projectGraph);
            if (!dependencyConfigs) {
                continue;
            }
            this.addTaskDependencies(task, dependencyConfigs, tasks, graph);
        }
        graph.roots = Object.keys(graph.dependencies).filter((k) => graph.dependencies[k].length === 0);
        return graph;
    }
    addTaskDependencies(task, dependencyConfigs, tasks, graph) {
        for (const dependencyConfig of dependencyConfigs) {
            if (dependencyConfig.projects === 'self') {
                for (const t of tasks) {
                    if (t.target.project === task.target.project &&
                        t.target.target === dependencyConfig.target) {
                        graph.dependencies[task.id].push(t.id);
                    }
                }
            }
            else if (dependencyConfig.projects === 'dependencies') {
                const seen = new Set();
                this.addDependencies(task.target.project, dependencyConfig.target, tasks, graph, task.id, seen);
            }
        }
    }
    addDependencies(project, target, tasks, graph, taskId, seen) {
        seen.add(project);
        const dependencies = this.projectGraph.dependencies[project];
        if (dependencies) {
            const projectDependencies = dependencies.map((dependency) => dependency.target);
            for (const projectDependency of projectDependencies) {
                if (seen.has(projectDependency)) {
                    continue;
                }
                const dependency = this.findTask({ project: projectDependency, target }, tasks);
                if (dependency) {
                    if (graph.dependencies[taskId].indexOf(dependency.id) === -1) {
                        graph.dependencies[taskId].push(dependency.id);
                    }
                }
                else {
                    this.addDependencies(projectDependency, target, tasks, graph, taskId, seen);
                }
            }
        }
    }
    findTask({ project, target }, tasks) {
        return tasks.find((t) => t.target.project === project && t.target.target === target);
    }
    addTaskToGraph(task, graph) {
        graph.tasks[task.id] = task;
        graph.dependencies[task.id] = [];
    }
}
exports.TaskGraphCreator = TaskGraphCreator;
//# sourceMappingURL=task-graph-creator.js.map